{
  "scriptForMigrateSchema": "CREATE TABLE Categoria (\n    id SERIAL PRIMARY KEY,\n    descripcion VARCHAR NOT NULL\n);\n\nCREATE TABLE Producto (\n    id BIGSERIAL PRIMARY KEY,\n    nombre VARCHAR NOT NULL,\n    precio DECIMAL NOT NULL,\n    descripcion TEXT,\n    imagenURL TEXT,\n    fabricante VARCHAR NOT NULL,\n    stock INTEGER NOT NULL\n);\n\nCREATE TABLE ProductoRelacionado (\n    id SERIAL PRIMARY KEY,\n    id_producto_relacionado BIGINT REFERENCES Producto(id) ON DELETE CASCADE\n);\n\nCREATE TABLE ItemPedido (\n    id SERIAL PRIMARY KEY,\n    _productos_productoId BIGINT REFERENCES Producto(id) ON DELETE CASCADE,\n    nombreItem VARCHAR NOT NULL,\n    cantidad INTEGER NOT NULL,\n    subtotal DECIMAL NOT NULL\n);\n\nCREATE TABLE Descuento (\n    id SERIAL PRIMARY KEY,\n    descripcion VARCHAR NOT NULL,\n    ratioDescuento DECIMAL NOT NULL\n);\n\nCREATE TABLE Pedido (\n    id BIGSERIAL PRIMARY KEY,\n    fechaPedido TIMESTAMP NOT NULL,\n    precioTotal DECIMAL NOT NULL\n);\n\nCREATE TABLE MetodoPago (\n    id SERIAL PRIMARY KEY,\n    nombreMetodo VARCHAR NOT NULL,\n    infoMetodo TEXT NOT NULL\n);\n\nCREATE TABLE Usuario (\n    id BIGSERIAL PRIMARY KEY,\n    nombre VARCHAR NOT NULL,\n    email VARCHAR UNIQUE NOT NULL,\n    password VARCHAR NOT NULL,\n    direccion TEXT,\n    pais VARCHAR NOT NULL,\n    fechaRegistro TIMESTAMP NOT NULL,\n    _usuarios_recomendadoPor BIGINT REFERENCES Usuario(id) ON DELETE SET NULL,\n    valoracionTienda INTEGER NOT NULL,\n    premium BOOLEAN NOT NULL,\n    fecha_premium TIMESTAMP,\n    premium_fee DECIMAL\n);\n\nCREATE TABLE UsuariosMetodosPago (\n    usuario_id BIGINT REFERENCES Usuario(id) ON DELETE CASCADE,\n    metodo_pago_id BIGINT REFERENCES MetodoPago(id) ON DELETE CASCADE,\n    PRIMARY KEY (usuario_id, metodo_pago_id)\n);\n\nCREATE TABLE PedidosDescuentos (\n    pedido_id BIGINT REFERENCES Pedido(id) ON DELETE CASCADE,\n    descuento_id BIGINT REFERENCES Descuento(id) ON DELETE CASCADE,\n    PRIMARY KEY (pedido_id, descuento_id)\n);\n\nCREATE TABLE ProductosRelacionados (\n    producto_id BIGINT REFERENCES Producto(id) ON DELETE CASCADE,\n    producto_relacionado_id BIGINT REFERENCES ProductoRelacionado(id) ON DELETE CASCADE,\n    PRIMARY KEY (producto_id, producto_relacionado_id)\n);\n\nCREATE INDEX idx_usuario_email ON Usuario(email);\nCREATE INDEX idx_producto_nombre ON Producto(nombre);",
  "metadataForMigrateSchema": "El script crea un esquema en PostgreSQL que refleja la estructura de la base de datos MongoDB original. Se definen tablas para cada entidad utilizando SERIAL o BIGSERIAL para los identificadores únicos. Las relaciones entre entidades se manejan a través de claves foráneas, y se crean tablas intermedias para reemplazar las estructuras anidadas. Se han agregado índices para los campos críticos como el email en la tabla Usuario y el nombre en la tabla Producto, asegurando la unicidad del email. Las conversiones de tipos de datos se han realizado para cumplir con las especificaciones de PostgreSQL.",
  "guidelinesForValidateSchema": "Para validar la migración del esquema desde MongoDB a PostgreSQL y asegurar que la implementación y optimización del nuevo esquema en la base de datos de destino sea correcta, sigue las siguientes pautas y recomendaciones:\n\n### 1. Verificación de la Estructura de Tablas\n- **Listar Tablas**: Utiliza el comando `\\dt` en psql para listar todas las tablas y asegúrate de que todas las tablas definidas en el script de migración estén presentes: `Categoria`, `Producto`, `ProductoRelacionado`, `ItemPedido`, `Descuento`, `Pedido`, `MetodoPago`, `Usuario`, `UsuariosMetodosPago`, `PedidosDescuentos`, y `ProductosRelacionados`.\n\n### 2. Verificación de Tipos de Datos\n- **Tipos de Datos**: Para cada tabla, utiliza el comando `\\d nombre_tabla` para verificar que los tipos de datos de las columnas sean los correctos según las especificaciones de la migración. Asegúrate de que:\n  - `String` se haya convertido a `VARCHAR` o `TEXT`.\n  - `Number` se haya convertido a `INTEGER` o `DECIMAL`.\n  - `Boolean` se haya convertido a `BOOLEAN`.\n  - `Date` se haya convertido a `TIMESTAMP`.\n\n### 3. Verificación de Claves Primarias y Foráneas\n- **Claves Primarias**: Asegúrate de que todas las claves primarias están definidas correctamente. Verifica que cada tabla tenga su clave primaria única.\n- **Claves Foráneas**: Revisa que todas las claves foráneas estén implementadas y referencien las tablas correctas. Utiliza el comando `\\d nombre_tabla` para ver las restricciones de clave foránea y confirmar que las relaciones están correctamente establecidas.\n\n### 4. Revisión de Tablas Intermedias\n- **Tablas Intermedias**: Confirma que las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) estén creadas y que contengan las claves foráneas apropiadas que enlazan las tablas correspondientes. Verifica que las relaciones muchos a muchos estén correctamente implementadas.\n\n### 5. Verificación de Índices\n- **Índices**: Comprueba que los índices estén creados en los campos clave, como `email` en la tabla `Usuario` y `nombre` en la tabla `Producto`. Utiliza el comando `\\di` para listar los índices en la base de datos y asegúrate de que los índices estén siendo utilizados adecuadamente en las consultas.\n\n### 6. Pruebas de Integridad de Datos\n- **Inserciones de Prueba**: Realiza inserciones de prueba en cada tabla para verificar que las restricciones de integridad (como `NOT NULL`, `UNIQUE`, etc.) funcionen correctamente. Intenta insertar datos que violen las restricciones y asegúrate de que la base de datos arroje errores apropiados.\n\n### 7. Pruebas de Consultas\n- **Consultas de Prueba**: Realiza consultas de prueba que simulen las consultas que se realizaban en MongoDB. Por ejemplo:\n  - Buscar productos por nombre: `SELECT * FROM Producto WHERE nombre ILIKE '%camisa%';`\n  - Obtener productos en un rango de precio: `SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;`\n  - Contar productos por fabricante: `SELECT fabricante, COUNT(*) FROM Producto GROUP BY fabricante;`\n  - Buscar pedidos de un usuario: `SELECT pedidos FROM Usuario WHERE id = 123;`\n  - Obtener productos relacionados: `SELECT ref_productos_relacionados FROM Producto WHERE id = 456;`\n  - Filtrar usuarios premium: `SELECT * FROM Usuario WHERE premium = TRUE;`\n- **Resultados**: Asegúrate de que los resultados sean los esperados y que las consultas se ejecuten en un tiempo razonable.\n\n### 8. Verificación de Rendimiento\n- **Pruebas de Rendimiento**: Realiza pruebas de rendimiento para asegurarte de que el esquema está optimizado para consultas. Utiliza herramientas como `EXPLAIN` para analizar el rendimiento de las consultas y verifica que los índices estén siendo utilizados adecuadamente.\n\n### 9. Revisión de Documentación\n- **Documentación**: Mantén documentación sobre el esquema migrado, incluyendo descripciones de cada tabla y sus relaciones. Esto será útil para futuras referencias y mantenimiento.\n\n### 10. Validación de Datos Existentes\n- **Comparación de Datos**: Si es posible, realiza una comparación de datos entre la base de datos MongoDB original y la nueva base de datos PostgreSQL para asegurarte de que todos los datos se han migrado correctamente.\n- **Conteo de Registros**: Verifica que la cantidad de registros en cada tabla de PostgreSQL coincida con la cantidad de documentos en las colecciones de MongoDB correspondientes.\n\nSiguiendo estas pautas y recomendaciones, podrás validar de manera efectiva la migración del esquema y asegurar la integridad y optimización del nuevo esquema en la base de datos de destino.",
  "scriptForDataMigration": "import psycopg2\nimport pymongo\n\n# Conexión a MongoDB\ndb_mongo = pymongo.MongoClient('mongodb://localhost:27017/')['nombre_base_datos']\n\n# Conexión a PostgreSQL\ndb_postgres = psycopg2.connect(\n    dbname='nombre_base_datos_postgres', \n    user='usuario', \n    password='contraseña', \n    host='localhost', \n    port='5432'\n)\ncursor = db_postgres.cursor()\n\n# Migrar Categoria\nfor categoria in db_mongo.categoria.find():\n    cursor.execute('INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;', (categoria['descripcion'],))\n    categoria_id = cursor.fetchone()[0]\n\n# Migrar Producto\nfor producto in db_mongo.producto.find():\n    cursor.execute('INSERT INTO Producto (id, nombre, precio, descripcion, imagenURL, fabricante, stock) VALUES (%s, %s, %s, %s, %s, %s, %s);', \n                   (producto['id'], producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock']))\n    \n    # Migrar categorías de producto\n    categorias = producto['categorias']\n    cursor.execute('INSERT INTO ProductosRelacionados (producto_id, producto_relacionado_id) VALUES (%s, %s);', (producto['id'], categorias['id']))\n    \n    # Migrar productos relacionados\n    for relacionado in producto['ref_productos_relacionados']:\n        cursor.execute('INSERT INTO ProductoRelacionado (id_producto_relacionado) VALUES (%s);', (relacionado['id_producto_relacionado'],))\n\n# Migrar Descuento\nfor descuento in db_mongo.descuento.find():\n    cursor.execute('INSERT INTO Descuento (id, descripcion, ratioDescuento) VALUES (%s, %s, %s);', (descuento['id'], descuento['descripcion'], descuento['ratioDescuento']))\n\n# Migrar MetodoPago\nfor metodo_pago in db_mongo.metodopago.find():\n    cursor.execute('INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s);', (metodo_pago['nombreMetodo'], metodo_pago['infoMetodo']))\n\n# Migrar Usuario\nfor usuario in db_mongo.usuario.find():\n    cursor.execute('INSERT INTO Usuario (id, nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);', \n                   (usuario['id'], usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\n    \n    # Migrar metodos de pago de usuario\n    for metodo in usuario['metodosDePago']:\n        cursor.execute('INSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id) VALUES (%s, (SELECT id FROM MetodoPago WHERE nombreMetodo = %s));', (usuario['id'], metodo['nombreMetodo']))\n\n    # Migrar pedidos\n    for pedido in usuario['pedidos']:\n        cursor.execute('INSERT INTO Pedido (id, fechaPedido, precioTotal) VALUES (%s, %s, %s) RETURNING id;', (pedido['id'], pedido['fechaPedido'], pedido['precioTotal']))\n        pedido_id = cursor.fetchone()[0]\n        \n        # Migrar descuentos de pedido\n        for descuento in pedido['descuentos']:\n            cursor.execute('INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES (%s, %s);', (pedido_id, descuento['id']))\n        \n        # Migrar items de pedido\n        for item in pedido['items']:\n            cursor.execute('INSERT INTO ItemPedido (_productos_productoId, nombreItem, cantidad, subtotal) VALUES ((SELECT id FROM Producto WHERE id = %s), %s, %s, %s);', (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\n\n# Guardar cambios y cerrar conexiones\ndb_postgres.commit()\ncursor.close()\ndb_postgres.close()",
  "metadataForDataMigration": "El script realiza la migración de datos desde MongoDB a PostgreSQL utilizando las bibliotecas pymongo y psycopg2. Se establece una conexión a ambas bases de datos y se recorre cada colección de MongoDB para insertar los datos en las tablas correspondientes en PostgreSQL. Las relaciones se manejan mediante la inserción de datos en tablas intermedias para asegurar la integridad referencial. Se insertan categorías, productos, descuentos, métodos de pago, usuarios, pedidos y elementos de pedido, asegurando que se respeten las claves foráneas y las estructuras anidadas se conviertan en tablas separadas. Este enfoque permite una migración eficiente y estructurada, cumpliendo con los requisitos especificados.",
  "scriptForDataValidation": "import psycopg2\n\n# Conexión a PostgreSQL\ndb_postgres = psycopg2.connect(\n    dbname='nombre_base_datos_postgres', \n    user='usuario', \n    password='contraseña', \n    host='localhost', \n    port='5432'\n)\ncursor = db_postgres.cursor()\n\n# 1. Validar búsqueda de productos por nombre\nprint('Validando búsqueda de productos por nombre...')\ncursor.execute(\"SELECT * FROM Producto WHERE nombre ILIKE '%camisa%';\")\nproductos_por_nombre = cursor.fetchall()\nprint('Productos encontrados por nombre:', productos_por_nombre)\n\n# 2. Validar obtener productos en un rango de precio\nprint('Validando obtener productos en un rango de precio...')\ncursor.execute(\"SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;\")\nproductos_rango_precio = cursor.fetchall()\nprint('Productos en rango de precio:', productos_rango_precio)\n\n# 3. Validar contar productos por fabricante\nprint('Validando contar productos por fabricante...')\ncursor.execute(\"SELECT fabricante, COUNT(*) as total FROM Producto GROUP BY fabricante;\")\nproductos_por_fabricante = cursor.fetchall()\nprint('Conteo de productos por fabricante:', productos_por_fabricante)\n\n# 4. Buscar pedidos de un usuario\nprint('Validando búsqueda de pedidos de un usuario...')\ncursor.execute(\"SELECT pedidos FROM Usuario WHERE id = 123;\")\npedidos_usuario = cursor.fetchall()\nprint('Pedidos del usuario con id 123:', pedidos_usuario)\n\n# 5. Obtener productos relacionados\nprint('Validando obtener productos relacionados...')\ncursor.execute(\"SELECT ref_productos_relacionados FROM Producto WHERE id = 456;\")\nproductos_relacionados = cursor.fetchall()\nprint('Productos relacionados para el producto con id 456:', productos_relacionados)\n\n# 6. Filtrar usuarios premium\nprint('Validando filtrado de usuarios premium...')\ncursor.execute(\"SELECT * FROM Usuario WHERE premium = TRUE;\")\nusarios_premium = cursor.fetchall()\nprint('Usuarios premium:', usuarios_premium)\n\n# Cerrar conexión\ncursor.close()\ndb_postgres.close()",
  "metadataForDataValidation": "El script se conecta a la base de datos PostgreSQL y ejecuta una serie de consultas para validar que los datos migrados desde MongoDB se hayan trasladado correctamente y que las consultas funcionen como se esperaba. Se realizan búsquedas de productos por nombre, se obtienen productos en un rango de precio, se cuenta el número de productos por fabricante, se buscan pedidos de un usuario específico, se obtienen productos relacionados y se filtran usuarios premium. Los resultados de cada consulta se imprimen en la consola para su revisión. Este enfoque asegura que la migración de datos y esquema sea correcta y que la funcionalidad de la aplicación se mantenga intacta."
}
