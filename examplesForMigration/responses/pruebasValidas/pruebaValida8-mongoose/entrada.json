{
  "sourceDatabaseType": "MongoDB",
  "targetDatabaseType": "PostgreSQL",
  "applicationRequirements": "Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });",
  "applicationArchitecture": "La aplicación está estructurada de acuerdo con una arquitectura monolítica.",
  "underlyingTechnologies": "Estamos utilizando Python con Pydantic.",
  "databaseSchema": "const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });",
  "migrationRequirements": "Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email. Además, ten en cuenta que los campos 'id' son identificadores son únicos de cada entidad que pueden ser referenciados"
}
