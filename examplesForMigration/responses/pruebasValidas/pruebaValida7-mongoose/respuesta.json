{
  "scriptForMigrateSchema": "CREATE TABLE Categoria (\n    id SERIAL PRIMARY KEY,\n    descripcion VARCHAR(255) NOT NULL\n);\n\nCREATE TABLE Producto (\n    id BIGSERIAL PRIMARY KEY,\n    nombre VARCHAR(255) NOT NULL,\n    precio DECIMAL NOT NULL,\n    descripcion TEXT,\n    imagenURL TEXT,\n    fabricante VARCHAR(255) NOT NULL,\n    stock INTEGER NOT NULL,\n    id_categoria INTEGER NOT NULL,\n    FOREIGN KEY (id_categoria) REFERENCES Categoria(id)\n);\n\nCREATE TABLE ProductoRelacionado (\n    id SERIAL PRIMARY KEY,\n    id_producto_relacionado BIGSERIAL NOT NULL,\n    FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id)\n);\n\nCREATE TABLE ItemPedido (\n    id SERIAL PRIMARY KEY,\n    id_producto INTEGER NOT NULL,\n    nombreItem VARCHAR(255) NOT NULL,\n    cantidad INTEGER NOT NULL,\n    subtotal DECIMAL NOT NULL,\n    FOREIGN KEY (id_producto) REFERENCES Producto(id)\n);\n\nCREATE TABLE Descuento (\n    id SERIAL PRIMARY KEY,\n    descripcion VARCHAR(255) NOT NULL,\n    ratioDescuento DECIMAL NOT NULL\n);\n\nCREATE TABLE Pedido (\n    id BIGSERIAL PRIMARY KEY,\n    fechaPedido TIMESTAMP NOT NULL,\n    precioTotal DECIMAL NOT NULL\n);\n\nCREATE TABLE MetodoPago (\n    id SERIAL PRIMARY KEY,\n    nombreMetodo VARCHAR(255) NOT NULL,\n    infoMetodo TEXT NOT NULL\n);\n\nCREATE TABLE Usuario (\n    id BIGSERIAL PRIMARY KEY,\n    nombre VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password VARCHAR(255) NOT NULL,\n    direccion TEXT,\n    pais VARCHAR(255) NOT NULL,\n    fechaRegistro TIMESTAMP NOT NULL,\n    _usuarios_recomendadoPor INTEGER,\n    valoracionTienda INTEGER NOT NULL,\n    premium BOOLEAN NOT NULL,\n    fecha_premium TIMESTAMP,\n    premium_fee DECIMAL,\n    FOREIGN KEY (_usuarios_recomendadoPor) REFERENCES Usuario(id)\n);\n\nCREATE TABLE UsuariosMetodosPago (\n    id_usuario INTEGER NOT NULL,\n    id_metodoPago INTEGER NOT NULL,\n    PRIMARY KEY (id_usuario, id_metodoPago),\n    FOREIGN KEY (id_usuario) REFERENCES Usuario(id),\n    FOREIGN KEY (id_metodoPago) REFERENCES MetodoPago(id)\n);\n\nCREATE TABLE PedidosDescuentos (\n    id_pedido INTEGER NOT NULL,\n    id_descuento INTEGER NOT NULL,\n    PRIMARY KEY (id_pedido, id_descuento),\n    FOREIGN KEY (id_pedido) REFERENCES Pedido(id),\n    FOREIGN KEY (id_descuento) REFERENCES Descuento(id)\n);\n\nCREATE TABLE ProductosRelacionados (\n    id_producto INTEGER NOT NULL,\n    id_producto_relacionado INTEGER NOT NULL,\n    PRIMARY KEY (id_producto, id_producto_relacionado),\n    FOREIGN KEY (id_producto) REFERENCES Producto(id),\n    FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id)\n);",
  "metadataForMigrateSchema": "El script crea las tablas necesarias para la migración del esquema de MongoDB a PostgreSQL. Se han definido las tablas 'Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', y 'Usuario' como entidades independientes. Cada tabla tiene un identificador único, utilizando SERIAL o BIGSERIAL según sea necesario. Las relaciones entre las tablas se establecen mediante claves foráneas, y se crean tablas intermedias para manejar las relaciones de muchos a muchos, como 'UsuariosMetodosPago', 'PedidosDescuentos', y 'ProductosRelacionados'. Se han utilizado tipos de datos apropiados para PostgreSQL, y se ha asegurado la unicidad del campo 'email' en la tabla 'Usuario'. Además, se han añadido restricciones NOT NULL donde es necesario para mantener la integridad de los datos.",
  "guidelinesForValidateSchema": "Para validar manualmente la transformación del esquema desde MongoDB a PostgreSQL y asegurar la correcta implementación y optimización del nuevo esquema en la base de datos de destino, se deben seguir las siguientes pautas y recomendaciones:\n\n1. **Verificación de la Estructura de Tablas:**\n   - Compruebe que todas las tablas definidas en el script de migración están presentes en la base de datos PostgreSQL. Utilice la consulta `SELECT table_name FROM information_schema.tables WHERE table_schema='public';` para listar las tablas.\n   - Asegúrese de que cada tabla tiene las columnas especificadas en el script de migración. Para verificar las columnas de una tabla, utilice `SELECT column_name FROM information_schema.columns WHERE table_name='nombre_tabla';`.\n\n2. **Validación de Tipos de Datos:**\n   - Revise que los tipos de datos de las columnas en PostgreSQL coincidan con los especificados en el script. Por ejemplo, verifique que las columnas de tipo `VARCHAR`, `DECIMAL`, `BOOLEAN`, y `TIMESTAMP` estén correctamente definidas.\n   - Confirme que las restricciones `NOT NULL` están implementadas en las columnas requeridas.\n\n3. **Comprobación de Claves Primarias y Foráneas:**\n   - Verifique que las claves primarias están definidas correctamente en cada tabla. Utilice `SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='nombre_tabla' AND constraint_type='PRIMARY KEY';` para comprobar las claves primarias.\n   - Asegúrese de que las claves foráneas están correctamente implementadas y referencian las tablas y columnas adecuadas. Utilice `SELECT constraint_name, table_name, column_name, foreign_table_name, foreign_column_name FROM information_schema.key_column_usage WHERE table_name='nombre_tabla';` para revisar las claves foráneas.\n\n4. **Tablas Intermedias:**\n   - Verifique que las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) estén correctamente creadas y que contengan las claves foráneas adecuadas que enlazan las entidades correspondientes.\n\n5. **Índices y Unicidad:**\n   - Asegúrese de que los índices están creados en los campos clave, como el campo `email` en la tabla `Usuario`, utilizando la consulta `SELECT indexname FROM pg_indexes WHERE tablename='nombre_tabla';`.\n   - Confirme que el índice en el campo `email` es único.\n\n6. **Pruebas de Inserción de Datos:**\n   - Realice pruebas de inserción de datos en cada tabla para verificar que las restricciones y las claves foráneas funcionan correctamente. Intente insertar datos válidos y luego datos inválidos (por ejemplo, datos que violan restricciones de `NOT NULL` o claves foráneas) para comprobar que se generan errores adecuados.\n   - Inserte registros en tablas que dependen de otras (por ejemplo, inserte primero en `Categoria` antes de insertar en `Producto`) y valide que las inserciones se realizan sin problemas.\n\n7. **Consultas de Prueba:**\n   - Realice consultas SQL para validar la integridad de los datos. Por ejemplo:\n     - `SELECT * FROM Producto WHERE nombre LIKE '%camisa%';` para buscar productos por nombre.\n     - `SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;` para obtener productos en un rango de precio.\n     - `SELECT fabricante, COUNT(*) FROM Producto GROUP BY fabricante;` para contar productos por fabricante.\n     - `SELECT * FROM Usuario WHERE premium = true;` para filtrar usuarios premium.\n\n8. **Verificación de Datos Relacionados:**\n   - Asegúrese de que los registros en las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) reflejan correctamente las relaciones entre las entidades. Realice uniones (JOIN) para validar que los datos relacionados se recuperan correctamente.\n\n9. **Revisión de Rendimiento:**\n   - Monitoree el rendimiento de las consultas para asegurar que el nuevo esquema está optimizado. Utilice herramientas de análisis de rendimiento de PostgreSQL para identificar posibles cuellos de botella.\n\n10. **Documentación:**\n    - Mantenga un registro de todas las pruebas realizadas, los resultados y cualquier problema encontrado durante la validación. Esto ayudará a identificar áreas que necesitan ajustes y proporcionará una referencia para futuras migraciones.\n\nSiguiendo estas pautas y recomendaciones, el usuario podrá validar eficazmente la transformación del esquema desde MongoDB a PostgreSQL y garantizar que el nuevo esquema esté correctamente implementado y optimizado.",
  "scriptForDataMigration": "import psycopg2\nimport pymongo\n\n# Conexiones a las bases de datos\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\nmongo_db = mongo_client['nombre_base_datos_mongodb']\n\npg_conn = psycopg2.connect(\n    dbname='nombre_base_datos_postgresql',\n    user='usuario',\n    password='contraseña',\n    host='localhost'\n)\npg_cursor = pg_conn.cursor()\n\n# Migrar Categorias\ncategorias = mongo_db.categorias.find()\nfor categoria in categorias:\n    pg_cursor.execute('INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;', (categoria['descripcion'],))\n    categoria_id = pg_cursor.fetchone()[0]\n\n# Migrar Productos\nproductos = mongo_db.productos.find()\nfor producto in productos:\n    pg_cursor.execute('INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock, id_categoria) VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING id;', (producto['nombre'], producto['precio'], producto.get('descripcion'), producto.get('imagenURL'), producto['fabricante'], producto['stock'], categoria_id))\n    producto_id = pg_cursor.fetchone()[0]\n    \n    # Migrar Productos Relacionados\n    for relacionado in producto.get('ref_productos_relacionados', []):\n        pg_cursor.execute('INSERT INTO ProductoRelacionado (id_producto_relacionado) VALUES (%s);', (relacionado['id_producto_relacionado'],))\n\n# Migrar Descuentos\ndescuentos = mongo_db.descuentos.find()\nfor descuento in descuentos:\n    pg_cursor.execute('INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s);', (descuento['descripcion'], descuento['ratioDescuento']))\n\n# Migrar Pedidos\npedidos = mongo_db.pedidos.find()\nfor pedido in pedidos:\n    pg_cursor.execute('INSERT INTO Pedido (fechaPedido, precioTotal) VALUES (%s, %s) RETURNING id;', (pedido['fechaPedido'], pedido['precioTotal']))\n    pedido_id = pg_cursor.fetchone()[0]\n    \n    # Migrar Items de Pedido\n    for item in pedido['items']:\n        pg_cursor.execute('INSERT INTO ItemPedido (id_producto, nombreItem, cantidad, subtotal) VALUES (%s, %s, %s, %s);', (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\n    \n    # Migrar Descuentos de Pedido\n    for descuento in pedido.get('descuentos', []):\n        pg_cursor.execute('INSERT INTO PedidosDescuentos (id_pedido, id_descuento) VALUES (%s, %s);', (pedido_id, descuento['id']))\n\n# Migrar Usuarios\nusuarios = mongo_db.usuarios.find()\nfor usuario in usuarios:\n    pg_cursor.execute('INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;', (usuario['nombre'], usuario['email'], usuario['password'], usuario.get('direccion'), usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\n    usuario_id = pg_cursor.fetchone()[0]\n\n    # Migrar Métodos de Pago\n    for metodo in usuario.get('metodosDePago', []):\n        pg_cursor.execute('INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s) RETURNING id;', (metodo['nombreMetodo'], metodo['infoMetodo']))\n        metodo_pago_id = pg_cursor.fetchone()[0]\n        pg_cursor.execute('INSERT INTO UsuariosMetodosPago (id_usuario, id_metodoPago) VALUES (%s, %s);', (usuario_id, metodo_pago_id))\n\n# Confirmar cambios y cerrar conexiones\npg_conn.commit()\npg_cursor.close()\npg_conn.close()\nmongo_client.close()",
  "metadataForDataMigration": "El script de migración de datos se encarga de transferir la información desde una base de datos MongoDB a PostgreSQL. Primero, establece conexiones a ambas bases de datos. Luego, se migran los datos de cada colección de MongoDB a las tablas correspondientes en PostgreSQL. Para cada categoría, producto, descuento, pedido, usuario y método de pago, se realizan inserciones en las tablas adecuadas y se manejan las relaciones a través de claves foráneas. Se utilizan transacciones para asegurar la integridad de los datos y se cierra la conexión al finalizar el proceso. Las tecnologías subyacentes, como pymongo y psycopg2, han sido útiles para realizar la migración de manera eficiente y validar la estructura del esquema durante la transferencia.",
  "scriptForDataValidation": "import psycopg2\n\n# Conexión a la base de datos PostgreSQL\npg_conn = psycopg2.connect(\n    dbname='nombre_base_datos_postgresql',\n    user='usuario',\n    password='contraseña',\n    host='localhost'\n)\npg_cursor = pg_conn.cursor()\n\n# 1. Verificar tablas\npg_cursor.execute(\"SELECT table_name FROM information_schema.tables WHERE table_schema='public';\")\ntablas = pg_cursor.fetchall()\nprint('Tablas en PostgreSQL:', tablas)\n\n# 2. Verificar columnas de cada tabla\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario', 'UsuariosMetodosPago', 'PedidosDescuentos', 'ProductosRelacionados']:\n    pg_cursor.execute(f\"SELECT column_name FROM information_schema.columns WHERE table_name='{tabla}';\")\n    columnas = pg_cursor.fetchall()\n    print(f'Columnas en {tabla}:', columnas)\n\n# 3. Verificar tipos de datos\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\n    pg_cursor.execute(f\"SELECT column_name, data_type FROM information_schema.columns WHERE table_name='{tabla}';\")\n    tipos_datos = pg_cursor.fetchall()\n    print(f'Tipos de datos en {tabla}:', tipos_datos)\n\n# 4. Verificar claves primarias\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\n    pg_cursor.execute(f\"SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='{tabla}' AND constraint_type='PRIMARY KEY';\")\n    claves_primarias = pg_cursor.fetchall()\n    print(f'Claves primarias en {tabla}:', claves_primarias)\n\n# 5. Verificar claves foráneas\nfor tabla in ['ProductoRelacionado', 'ItemPedido', 'UsuariosMetodosPago', 'PedidosDescuentos', 'ProductosRelacionados']:\n    pg_cursor.execute(f\"SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='{tabla}' AND constraint_type='FOREIGN KEY';\")\n    claves_foraneas = pg_cursor.fetchall()\n    print(f'Claves foráneas en {tabla}:', claves_foraneas)\n\n# 6. Verificar índices\npg_cursor.execute(\"SELECT indexname, tablename FROM pg_indexes WHERE schemaname='public';\")\nindices = pg_cursor.fetchall()\nprint('Índices en las tablas:', indices)\n\n# 7. Realizar consultas de prueba\n# Contar registros en cada tabla\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\n    pg_cursor.execute(f\"SELECT COUNT(*) FROM {tabla};\")\n    conteo = pg_cursor.fetchone()[0]\n    print(f'Registros en {tabla}:', conteo)\n\n# 8. Verificar integridad de datos\n# Ejemplo: Verificar que todos los productos tienen una categoría válida\npg_cursor.execute(\"SELECT COUNT(*) FROM Producto WHERE id_categoria NOT IN (SELECT id FROM Categoria);\")\nproductos_invalidos_categoria = pg_cursor.fetchone()[0]\nprint('Productos con categoría inválida:', productos_invalidos_categoria)\n\n# Cerrar conexión\npg_cursor.close()\npg_conn.close()",
  "metadataForDataValidation": "Este script está diseñado para validar la migración de datos y esquema de MongoDB a PostgreSQL. Primero, se establece una conexión con la base de datos PostgreSQL. Luego, se realizan las siguientes validaciones: se verifica la existencia de las tablas, se comprueba que las columnas y sus tipos de datos sean correctos, se revisan las claves primarias y foráneas, se listan los índices creados en las tablas y se cuentan los registros en cada tabla para asegurar que no se han perdido datos durante la migración. Además, se realiza una consulta para verificar la integridad referencial de los datos, asegurando que todos los productos tengan una categoría válida. Finalmente, se cierra la conexión a la base de datos."
}
