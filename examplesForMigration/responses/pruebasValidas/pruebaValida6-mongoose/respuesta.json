{
  "scriptForMigrateSchema": "CREATE TABLE Categoria ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL ); CREATE TABLE Producto ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, precio DECIMAL NOT NULL, descripcion TEXT, imagenURL TEXT, fabricante VARCHAR NOT NULL, stock INTEGER NOT NULL ); CREATE TABLE ProductoRelacionado ( id_producto_relacionado INTEGER NOT NULL, producto_id INTEGER NOT NULL, PRIMARY KEY (id_producto_relacionado, producto_id), FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id), FOREIGN KEY (producto_id) REFERENCES Producto(id) ); CREATE TABLE ItemPedido ( id SERIAL PRIMARY KEY, _productos_productoId INTEGER NOT NULL, nombreItem VARCHAR NOT NULL, cantidad INTEGER NOT NULL, subtotal DECIMAL NOT NULL, FOREIGN KEY (_productos_productoId) REFERENCES Producto(id) ); CREATE TABLE Descuento ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL, ratioDescuento DECIMAL NOT NULL ); CREATE TABLE Pedido ( id SERIAL PRIMARY KEY, fechaPedido TIMESTAMP NOT NULL, precioTotal DECIMAL NOT NULL ); CREATE TABLE UsuariosMetodosPago ( usuario_id INTEGER NOT NULL, metodo_id INTEGER NOT NULL, PRIMARY KEY (usuario_id, metodo_id), FOREIGN KEY (usuario_id) REFERENCES Usuario(id), FOREIGN KEY (metodo_id) REFERENCES MetodoPago(id) ); CREATE TABLE MetodoPago ( id SERIAL PRIMARY KEY, nombreMetodo VARCHAR NOT NULL, infoMetodo VARCHAR NOT NULL ); CREATE TABLE Usuario ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, email VARCHAR NOT NULL UNIQUE, password VARCHAR NOT NULL, direccion TEXT, pais VARCHAR NOT NULL, fechaRegistro TIMESTAMP NOT NULL, _usuarios_recomendadoPor INTEGER, valoracionTienda INTEGER NOT NULL, premium BOOLEAN NOT NULL, fecha_premium TIMESTAMP, premium_fee DECIMAL, FOREIGN KEY (_usuarios_recomendadoPor) REFERENCES Usuario(id) ); CREATE TABLE PedidosDescuentos ( pedido_id INTEGER NOT NULL, descuento_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, descuento_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (descuento_id) REFERENCES Descuento(id) ); CREATE TABLE ProductosRelacionados ( producto_id INTEGER NOT NULL, relacionado_id INTEGER NOT NULL, PRIMARY KEY (producto_id, relacionado_id), FOREIGN KEY (producto_id) REFERENCES Producto(id), FOREIGN KEY (relacionado_id) REFERENCES Producto(id) ); CREATE TABLE PedidosItems ( pedido_id INTEGER NOT NULL, item_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, item_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (item_id) REFERENCES ItemPedido(id) );",
  "metadataForMigrateSchema": "El script crea un esquema de base de datos en PostgreSQL basado en el esquema de MongoDB proporcionado. Se han definido tablas separadas para cada entidad, garantizando que las estructuras anidadas se conviertan en tablas independientes. Se utilizan claves foráneas para mantener la integridad referencial entre las tablas. Las restricciones de tipo de datos se han aplicado correctamente, utilizando SERIAL para los identificadores y asegurando que los campos clave como 'email' en Usuario sean únicos. Este enfoque permite una base de datos bien estructurada y normalizada, adecuada para PostgreSQL.",
  "guidelinesForValidateSchema": "{\r\n  \"validationGuidelines\": {\r\n    \"schemaTransformationValidation\": {\r\n      \"steps\": [\r\n        {\r\n          \"step\": 1,\r\n          \"description\": \"Revisar la creación de tablas\",\r\n          \"action\": \"Verificar que todas las tablas especificadas en el script de migración se hayan creado en la base de datos PostgreSQL. Listar las tablas y compararlas con el script.\"\r\n        },\r\n        {\r\n          \"step\": 2,\r\n          \"description\": \"Verificar tipos de datos\",\r\n          \"action\": \"Asegurarse de que los tipos de datos en las tablas coincidan con los tipos especificados en el script (ej. VARCHAR, DECIMAL, TIMESTAMP). Realizar consultas para verificar los tipos de cada columna.\"\r\n        },\r\n        {\r\n          \"step\": 3,\r\n          \"description\": \"Revisar claves primarias\",\r\n          \"action\": \"Confirmar que cada tabla tenga una clave primaria definida y que se utilice 'SERIAL' para los identificadores. Ejecutar consultas para comprobar la existencia de claves primarias.\"\r\n        },\r\n        {\r\n          \"step\": 4,\r\n          \"description\": \"Verificar claves foráneas\",\r\n          \"action\": \"Asegurarse de que todas las claves foráneas estén correctamente definidas y que referencien las tablas adecuadas. Realizar consultas para verificar las relaciones entre las tablas.\"\r\n        },\r\n        {\r\n          \"step\": 5,\r\n          \"description\": \"Revisar tablas intermedias\",\r\n          \"action\": \"Confirmar que las relaciones muchos a muchos se hayan implementado correctamente a través de tablas intermedias. Listar las tablas intermedias y verificar sus relaciones.\"\r\n        },\r\n        {\r\n          \"step\": 6,\r\n          \"description\": \"Revisar restricciones de unicidad\",\r\n          \"action\": \"Asegurarse de que las restricciones de unicidad, como la del campo 'email' en la tabla Usuario, estén implementadas. Realizar pruebas de inserción para verificar el comportamiento de las restricciones.\"\r\n        }\r\n      ]\r\n    },\r\n    \"schemaOptimizationValidation\": {\r\n      \"steps\": [\r\n        {\r\n          \"step\": 1,\r\n          \"description\": \"Verificar índices\",\r\n          \"action\": \"Confirmar que se hayan creado índices en columnas clave como 'email' en Usuario y 'nombre' en Producto. Consultar la información del esquema para verificar la existencia de índices.\"\r\n        },\r\n        {\r\n          \"step\": 2,\r\n          \"description\": \"Ejecutar consultas de prueba\",\r\n          \"action\": \"Realizar consultas de prueba para verificar que el rendimiento sea adecuado y que los resultados sean correctos (ej. búsqueda por nombre, filtrado por precio, etc.). Comparar tiempos de respuesta con los esperados.\"\r\n        },\r\n        {\r\n          \"step\": 3,\r\n          \"description\": \"Evaluar la normalización\",\r\n          \"action\": \"Asegurarse de que el esquema esté normalizado adecuadamente para evitar la redundancia de datos. Revisar las tablas y sus relaciones para identificar posibles redundancias.\"\r\n        },\r\n        {\r\n          \"step\": 4,\r\n          \"description\": \"Revisar integridad referencial\",\r\n          \"action\": \"Probar la integridad referencial realizando inserciones, actualizaciones y eliminaciones para verificar que las restricciones funcionen como se espera. Intentar eliminar registros que tengan dependencias y observar el comportamiento.\"\r\n        },\r\n        {\r\n          \"step\": 5,\r\n          \"description\": \"Verificar la documentación\",\r\n          \"action\": \"Asegurarse de que la documentación del esquema esté actualizada y refleje la estructura actual en PostgreSQL. Comparar la documentación con el esquema actual.\"\r\n        }\r\n      ]\r\n    },\r\n    \"manualTestingSuggestions\": [\r\n      \"Crear registros de prueba en cada tabla para verificar que las inserciones se realicen correctamente.\",\r\n      \"Ejecutar consultas de selección en cada tabla para asegurar que los datos se recuperen como se espera.\",\r\n      \"Probar la eliminación de registros y verificar que las restricciones de claves foráneas se apliquen correctamente.\",\r\n      \"Realizar consultas de unión para comprobar que las relaciones entre tablas funcionen adecuadamente.\",\r\n      \"Ejecutar pruebas de rendimiento para asegurarse de que las consultas se ejecuten en un tiempo razonable.\"\r\n    ],\r\n    \"checkpoints\": [\r\n      \"Confirmar que todas las tablas y columnas tengan los nombres correctos y que no haya errores tipográficos.\",\r\n      \"Verificar que las restricciones y las claves foráneas se apliquen correctamente y no generen errores al intentar insertar datos.\",\r\n      \"Asegurarse de que los datos migrados desde MongoDB a PostgreSQL se mantengan consistentes y completos.\",\r\n      \"Revisar los registros de errores durante la migración para identificar y corregir problemas potenciales.\"\r\n    ]\r\n  }\r\n}",
  "scriptForDataMigration": "import psycopg2\nimport pymongo\n\n# Conexiones a las bases de datos\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\nmongo_db = mongo_client['nombre_base_datos_mongo']\n\npostgres_conn = psycopg2.connect(\n    dbname='nombre_base_datos_postgres',\n    user='usuario',\n    password='contraseña',\n    host='localhost',\n    port='5432'\n)\npostgres_cursor = postgres_conn.cursor()\n\n# Migrar Categorias\ncategorias = mongo_db.categoria.find()\nfor categoria in categorias:\n    postgres_cursor.execute(\"INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;\", (categoria['descripcion'],))\n    categoria_id = postgres_cursor.fetchone()[0]\n\n# Migrar Productos\nproductos = mongo_db.producto.find()\nfor producto in productos:\n    postgres_cursor.execute(\"INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock) VALUES (%s, %s, %s, %s, %s, %s) RETURNING id;\", (producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock']))\n    producto_id = postgres_cursor.fetchone()[0]\n    # Migrar categorias\n    for categoria in producto['categorias']:\n        postgres_cursor.execute(\"INSERT INTO ProductosRelacionados (producto_id, relacionado_id) VALUES (%s, %s);\", (producto_id, categoria['id']))\n    # Migrar productos relacionados\n    for relacionado in producto['ref_productos_relacionados']:\n        postgres_cursor.execute(\"INSERT INTO ProductoRelacionado (id_producto_relacionado, producto_id) VALUES (%s, %s);\", (relacionado['id_producto_relacionado'], producto_id))\n\n# Migrar Usuarios\nusuarios = mongo_db.usuario.find()\nfor usuario in usuarios:\n    postgres_cursor.execute(\"INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;\", (usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\n    usuario_id = postgres_cursor.fetchone()[0]\n    # Migrar metodos de pago\n    for metodo in usuario['metodosDePago']:\n        postgres_cursor.execute(\"INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s) RETURNING id;\", (metodo['nombreMetodo'], metodo['infoMetodo']))\n        metodo_id = postgres_cursor.fetchone()[0]\n        postgres_cursor.execute(\"INSERT INTO UsuariosMetodosPago (usuario_id, metodo_id) VALUES (%s, %s);\", (usuario_id, metodo_id))\n    # Migrar pedidos\n    for pedido in usuario['pedidos']:\n        postgres_cursor.execute(\"INSERT INTO Pedido (fechaPedido, precioTotal) VALUES (%s, %s) RETURNING id;\", (pedido['fechaPedido'], pedido['precioTotal']))\n        pedido_id = postgres_cursor.fetchone()[0]\n        # Migrar descuentos\n        for descuento in pedido['descuentos']:\n            postgres_cursor.execute(\"INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s) RETURNING id;\", (descuento['descripcion'], descuento['ratioDescuento']))\n            descuento_id = postgres_cursor.fetchone()[0]\n            postgres_cursor.execute(\"INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES (%s, %s);\", (pedido_id, descuento_id))\n        # Migrar items\n        for item in pedido['items']:\n            postgres_cursor.execute(\"INSERT INTO ItemPedido (_productos_productoId, nombreItem, cantidad, subtotal) VALUES (%s, %s, %s, %s) RETURNING id;\", (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\n            item_id = postgres_cursor.fetchone()[0]\n            postgres_cursor.execute(\"INSERT INTO PedidosItems (pedido_id, item_id) VALUES (%s, %s);\", (pedido_id, item_id))\n\n# Confirmar cambios y cerrar conexiones\npostgres_conn.commit()\npostgres_cursor.close()\npostgres_conn.close()\nmongo_client.close()",
  "metadataForDataMigration": "El script de migración de datos utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectar y migrar datos de MongoDB a PostgreSQL. Primero, se establecen las conexiones a ambas bases de datos. Luego, se migran las categorías, productos, usuarios, métodos de pago, pedidos, descuentos e items de pedidos, asegurando que se inserten correctamente en las tablas correspondientes en PostgreSQL. Se utilizan claves foráneas para mantener la integridad referencial. Este enfoque permite una migración eficiente y estructurada, garantizando que las relaciones entre los datos se mantengan. La validación de datos y la verificación de la migración se pueden realizar mediante pruebas manuales y consultas en la base de datos de destino después de la migración.",
  "scriptForDataValidation": "import psycopg2\nimport pymongo\n\n# Conexiones a las bases de datos\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\nmongo_db = mongo_client['nombre_base_datos_mongo']\n\npostgres_conn = psycopg2.connect(\n    dbname='nombre_base_datos_postgres',\n    user='usuario',\n    password='contraseña',\n    host='localhost',\n    port='5432'\n)\npostgres_cursor = postgres_conn.cursor()\n\n# Validar Categorias\nmongo_categorias = mongo_db.categoria.find()\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Categoria;\")\npostgres_categoria_count = postgres_cursor.fetchone()[0]\nassert postgres_categoria_count == mongo_categorias.count(), \"El conteo de categorias no coincide.\"\n\n# Validar Productos\nmongo_productos = mongo_db.producto.find()\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Producto;\")\npostgres_producto_count = postgres_cursor.fetchone()[0]\nassert postgres_producto_count == mongo_productos.count(), \"El conteo de productos no coincide.\"\n\n# Validar Usuarios\nmongo_usuarios = mongo_db.usuario.find()\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Usuario;\")\npostgres_usuario_count = postgres_cursor.fetchone()[0]\nassert postgres_usuario_count == mongo_usuarios.count(), \"El conteo de usuarios no coincide.\"\n\n# Validar Productos Relacionados\npostgres_cursor.execute(\"SELECT COUNT(*) FROM ProductoRelacionado;\")\npostgres_producto_relacionado_count = postgres_cursor.fetchone()[0]\n# Aquí se debe validar la lógica de los productos relacionados si es necesario\n\n# Validar ItemPedido\npostgres_cursor.execute(\"SELECT COUNT(*) FROM ItemPedido;\")\npostgres_itempedido_count = postgres_cursor.fetchone()[0]\n# Aquí se debe validar la lógica de los items de pedido si es necesario\n\n# Validar Pedidos\nmongo_pedidos = mongo_db.pedido.find()\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Pedido;\")\npostgres_pedido_count = postgres_cursor.fetchone()[0]\nassert postgres_pedido_count == mongo_pedidos.count(), \"El conteo de pedidos no coincide.\"\n\n# Validar Descuentos\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Descuento;\")\npostgres_descuento_count = postgres_cursor.fetchone()[0]\n# Aquí se debe validar la lógica de los descuentos si es necesario\n\n# Validar Metodos de Pago\nmongo_metodos_pago = mongo_db.metodoPago.find()\npostgres_cursor.execute(\"SELECT COUNT(*) FROM MetodoPago;\")\npostgres_metodo_pago_count = postgres_cursor.fetchone()[0]\nassert postgres_metodo_pago_count == mongo_metodos_pago.count(), \"El conteo de métodos de pago no coincide.\"\n\n# Validar integridad referencial\n# Comprobar que todas las claves foráneas tengan registros correspondientes\n# Ejemplo para Usuario recomendado\npostgres_cursor.execute(\"SELECT COUNT(*) FROM Usuario WHERE _usuarios_recomendadoPor IS NOT NULL;\")\nusuarios_recomendados_count = postgres_cursor.fetchone()[0]\nassert usuarios_recomendados_count == mongo_db.usuario.count_documents({'_usuarios_recomendadoPor': {'$exists': True}}), \"Los usuarios recomendados no coinciden.\"\n\n# Confirmar cambios y cerrar conexiones\npostgres_conn.commit()\npostgres_cursor.close()\npostgres_conn.close()\nmongo_client.close()",
  "metadataForDataValidation": "El script de validación de la migración de datos y esquema utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectarse a las bases de datos MongoDB y PostgreSQL. Se realizan varias validaciones, incluyendo la comparación del conteo de registros en cada tabla de PostgreSQL con los documentos correspondientes en MongoDB. Además, se verifica la integridad referencial, asegurando que las claves foráneas tengan registros correspondientes. Esto garantiza que la migración se haya realizado correctamente y que los datos sean consistentes entre ambas bases de datos. El uso de Python permite una validación automatizada y eficiente, lo que facilita el proceso de verificación de la migración."
}
