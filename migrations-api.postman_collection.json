{
  "info": {
    "_postman_id": "6f4b34f4-0070-43e7-8335-1d82e310546a",
    "name": "TFG API - PROMPTS API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "36968954"
  },
  "item": [
    {
      "name": "prueba-1-sencilla",
      "request": {
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"MongoDB\",\r\n  \"applicationRequirements\": \"The application is a simple event management system that allows users to create events and register attendees.\\nThe operations supported by the application are:\\n\\n- Create an event\\nINSERT INTO evento (nombre, fecha, ubicacion) VALUES ('Conferencia Tech', '2025-03-15 10:00:00', 'Centro de Convenciones');\\n\\n- Register an attendee\\nINSERT INTO asistente (nombre, email, evento_id) VALUES ('Juan Pérez', 'juan.perez@example.com', 1);\\n\\n- Count how many attendees are registered for each event\\nSELECT e.nombre AS evento, COUNT(a.id) AS total_asistentes\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nGROUP BY e.id, e.nombre;\\n\\n- Get a list of events without attendees\\nSELECT e.id, e.nombre, e.fecha, e.ubicacion\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nWHERE a.id IS NULL;\",\r\n  \"applicationArchitecture\": \"The application is a monolithic application.\",\r\n  \"underlyingTechnologies\": \"The application is built with Java and Spring Boot.\",\r\n  \"databaseSchema\": \"CREATE DATABASE eventos_db;\\nUSE eventos_db;\\n\\n-- Tabla de eventos\\nCREATE TABLE evento (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nfecha DATETIME NOT NULL,\\nubicacion VARCHAR(255) NOT NULL\\n);\\n\\n-- Tabla de asistentes\\nCREATE TABLE asistente (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nemail VARCHAR(255) UNIQUE NOT NULL,\\nevento_id INT NOT NULL,\\nFOREIGN KEY (evento_id) REFERENCES evento(id) ON DELETE CASCADE\\n);\",\r\n  \"migrationRequirements\": \"Seleccionar los registros de las tablas 'evento' y 'asistente'.\\nConvertir la columna 'id' en '_id' para alinearla con MongoDB.\\nLa columna 'fecha' en 'evento' debe convertirse a formato ISODate.\\nEn la tabla 'asistente', el campo 'evento_id' debe mapearse como una referencia a '_id' en la colección 'evento'\\nInsertar los eventos en la colección 'evento' con '_id' como ObjectId y 'fecha' en formato ISODate.\\nInsertar los asistentes en la colección 'asistente', asegurando que 'evento_id' almacene una referencia a '_id' en 'evento'.\\nMantener la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente.\"\r\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{migrations_url}}",
          "host": ["{{migrations_url}}"]
        }
      },
      "response": [
        {
          "name": "prueba-1-sencilla-response",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"MongoDB\",\r\n  \"applicationRequirements\": \"The application is a simple event management system that allows users to create events and register attendees.\\nThe operations supported by the application are:\\n\\n- Create an event\\nINSERT INTO evento (nombre, fecha, ubicacion) VALUES ('Conferencia Tech', '2025-03-15 10:00:00', 'Centro de Convenciones');\\n\\n- Register an attendee\\nINSERT INTO asistente (nombre, email, evento_id) VALUES ('Juan Pérez', 'juan.perez@example.com', 1);\\n\\n- Count how many attendees are registered for each event\\nSELECT e.nombre AS evento, COUNT(a.id) AS total_asistentes\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nGROUP BY e.id, e.nombre;\\n\\n- Get a list of events without attendees\\nSELECT e.id, e.nombre, e.fecha, e.ubicacion\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nWHERE a.id IS NULL;\",\r\n  \"applicationArchitecture\": \"The application is a monolithic application.\",\r\n  \"underlyingTechnologies\": \"The application is built with Java and Spring Boot.\",\r\n  \"databaseSchema\": \"CREATE DATABASE eventos_db;\\nUSE eventos_db;\\n\\n-- Tabla de eventos\\nCREATE TABLE evento (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nfecha DATETIME NOT NULL,\\nubicacion VARCHAR(255) NOT NULL\\n);\\n\\n-- Tabla de asistentes\\nCREATE TABLE asistente (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nemail VARCHAR(255) UNIQUE NOT NULL,\\nevento_id INT NOT NULL,\\nFOREIGN KEY (evento_id) REFERENCES evento(id) ON DELETE CASCADE\\n);\",\r\n  \"migrationRequirements\": \"Seleccionar los registros de las tablas 'evento' y 'asistente'.\\nConvertir la columna 'id' en '_id' para alinearla con MongoDB.\\nLa columna 'fecha' en 'evento' debe convertirse a formato ISODate.\\nEn la tabla 'asistente', el campo 'evento_id' debe mapearse como una referencia a '_id' en la colección 'evento'\\nInsertar los eventos en la colección 'evento' con '_id' como ObjectId y 'fecha' en formato ISODate.\\nInsertar los asistentes en la colección 'asistente', asegurando que 'evento_id' almacene una referencia a '_id' en 'evento'.\\nMantener la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json",
              "description": "",
              "type": "text"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sun, 02 Mar 2025 22:02:07 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"db.evento.insertMany([\\n  { _id: ObjectId(), nombre: 'Evento 1', fecha: ISODate('2023-10-01T10:00:00Z'), ubicacion: 'Ubicacion 1' },\\n  { _id: ObjectId(), nombre: 'Evento 2', fecha: ISODate('2023-10-02T10:00:00Z'), ubicacion: 'Ubicacion 2' }\\n]);\\n\\ndb.asistente.insertMany([\\n  { _id: ObjectId(), nombre: 'Asistente 1', email: 'asistente1@example.com', evento_id: ObjectId('eventoid1') },\\n  { _id: ObjectId(), nombre: 'Asistente 2', email: 'asistente2@example.com', evento_id: ObjectId('eventoid2') }\\n]);\",\n    \"metadataForMigrateSchema\": \"El script inserta datos en la colección 'evento' de MongoDB con los campos requeridos, donde '_id' es un ObjectId generado automáticamente y 'fecha' se convierte a formato ISODate. Luego, se inserta en la colección 'asistente', donde 'evento_id' hace referencia al '_id' del evento correspondiente. Es importante reemplazar 'eventoid1' y 'eventoid2' con los ObjectId reales de los eventos insertados para mantener la integridad referencial.\",\n    \"guidelinesForValidateSchema\": \"A continuación se presentan pautas y recomendaciones detalladas para validar manualmente la migración del esquema desde MySQL a MongoDB, así como para garantizar la correcta implementación y optimización del nuevo esquema en la base de datos de destino:\\n\\n### 1. Verificación de la Transformación del Esquema\\n\\n#### Pasos de Verificación:\\n- **Verificar la Estructura de la Colección 'evento':**\\n  - Asegúrate de que cada documento en la colección `evento` tenga los siguientes campos:\\n    - `_id`: Debe ser un ObjectId generado automáticamente.\\n    - `nombre`: Debe ser una cadena de texto (string).\\n    - `fecha`: Debe estar en formato ISODate.\\n    - `ubicacion`: Debe ser una cadena de texto (string).\\n\\n- **Verificar la Estructura de la Colección 'asistente':**\\n  - Asegúrate de que cada documento en la colección `asistente` tenga los siguientes campos:\\n    - `_id`: Debe ser un ObjectId generado automáticamente.\\n    - `nombre`: Debe ser una cadena de texto (string).\\n    - `email`: Debe ser una cadena de texto (string) y debe ser único.\\n    - `evento_id`: Debe ser un ObjectId que referencia a un documento en la colección `evento`.\\n\\n#### Sugerencias de Pruebas Manuales:\\n- Ejecuta consultas en MongoDB para listar todos los documentos en ambas colecciones:\\n  ```javascript\\n  db.evento.find().pretty();\\n  db.asistente.find().pretty();\\n  ```\\n- Revisa manualmente que los campos y tipos de datos coincidan con lo esperado.\\n\\n### 2. Verificación de la Integridad Referencial\\n\\n#### Pasos de Verificación:\\n- **Validar las Referencias en 'asistente':**\\n  - Comprueba que todos los `evento_id` en la colección `asistente` correspondan a un `_id` existente en la colección `evento`. Esto se puede hacer mediante una consulta que verifique la existencia de cada `evento_id`:\\n  ```javascript\\n  db.asistente.find().forEach(function(asistente) {\\n    if (!db.evento.findOne({ _id: asistente.evento_id })) {\\n      print('Inconsistencia encontrada: ' + asistente.nombre + ' tiene un evento_id no válido.');\\n    }\\n  });\\n  ```\\n\\n### 3. Optimización del Esquema\\n\\n#### Puntos de Control para la Optimización:\\n- **Indexación:**\\n  - Asegúrate de que haya índices en los campos que se utilizan con frecuencia en las consultas, como `email` en `asistente` y `fecha` en `evento`.\\n  ```javascript\\n  db.asistente.createIndex({ email: 1 }, { unique: true });\\n  db.evento.createIndex({ fecha: 1 });\\n  ```\\n\\n- **Estructura de Documentos:**\\n  - Considera si es necesario anidar la información de los asistentes dentro de los eventos para mejorar el rendimiento de las consultas. Esto puede ser útil si las consultas para obtener eventos y sus asistentes son comunes.\\n\\n### 4. Validación de Consultas Comunes\\n\\n#### Pasos de Verificación:\\n- **Crear un Evento:**\\n  - Realiza una inserción de prueba para un nuevo evento y verifica que se haya añadido correctamente.\\n  ```javascript\\n  db.evento.insertOne({ _id: ObjectId(), nombre: 'Evento de Prueba', fecha: ISODate('2025-04-01T10:00:00Z'), ubicacion: 'Ubicacion de Prueba' });\\n  ```\\n\\n- **Registrar un Asistente:**\\n  - Realiza una inserción de prueba para un nuevo asistente y verifica que se haya añadido correctamente y que la referencia al evento sea válida.\\n  ```javascript\\n  db.asistente.insertOne({ _id: ObjectId(), nombre: 'Asistente de Prueba', email: 'prueba@example.com', evento_id: ObjectId('eventoid1') });\\n  ```\\n\\n- **Contar Asistentes por Evento:**\\n  - Realiza una consulta para contar los asistentes por evento.\\n  ```javascript\\n  db.evento.aggregate([\\n    {\\n      $lookup: {\\n        from: 'asistente',\\n        localField: '_id',\\n        foreignField: 'evento_id',\\n        as: 'asistentes'\\n      }\\n    },\\n    {\\n      $project: {\\n        nombre: 1,\\n        total_asistentes: { $size: '$asistentes' }\\n      }\\n    }\\n  ]);\\n  ```\\n\\n- **Listar Eventos sin Asistentes:**\\n  - Realiza una consulta para listar eventos que no tienen asistentes.\\n  ```javascript\\n  db.evento.aggregate([\\n    {\\n      $lookup: {\\n        from: 'asistente',\\n        localField: '_id',\\n        foreignField: 'evento_id',\\n        as: 'asistentes'\\n      }\\n    },\\n    {\\n      $match: { 'asistentes': { $eq: [] } }\\n    }\\n  ]);\\n  ```\\n\\n### 5. Identificación de Inconsistencias o Riesgos\\n\\n#### Posibles Inconsistencias:\\n- **Referencias Rotos:** Si un `evento_id` en `asistente` no corresponde a un `_id` en `evento`, esto causará problemas en la integridad de los datos.\\n- **Duplicados en Emails:** Asegúrate de que no haya duplicados en el campo `email` de `asistente`, ya que esto podría llevar a problemas de autenticación o identificación de usuarios.\\n- **Formato de Fecha:** Verifica que todas las fechas estén en el formato correcto (ISODate) para evitar problemas al realizar consultas.\\n\\n### 6. Resumen de Recomendaciones para Pruebas Manuales\\n\\n- Realiza consultas de verificación después de cada inserción de datos.\\n- Asegúrate de revisar la integridad referencial manualmente.\\n- Optimiza el esquema mediante la creación de índices y considera la posibilidad de anidar documentos si es necesario.\\n- Mantén un registro de cualquier inconsistencia o problema encontrado durante la validación y toma medidas correctivas.\\n\\nSiguiendo estas pautas, podrás validar la migración del esquema de MySQL a MongoDB de manera efectiva y asegurar que la base de datos de destino esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"const eventos = [\\n  { _id: ObjectId(), nombre: 'Evento 1', fecha: ISODate('2023-10-01T10:00:00Z'), ubicacion: 'Ubicacion 1' },\\n  { _id: ObjectId(), nombre: 'Evento 2', fecha: ISODate('2023-10-02T10:00:00Z'), ubicacion: 'Ubicacion 2' }\\n];\\n\\nconst asistentes = [\\n  { _id: ObjectId(), nombre: 'Asistente 1', email: 'asistente1@example.com', evento_id: eventos[0]._id },\\n  { _id: ObjectId(), nombre: 'Asistente 2', email: 'asistente2@example.com', evento_id: eventos[1]._id }\\n];\\n\\ndb.evento.insertMany(eventos);\\n\\ndb.asistente.insertMany(asistentes);\",\n    \"metadataForDataMigration\": \"El script primero define un arreglo de eventos que contiene los datos a insertar en la colección 'evento', donde cada evento tiene un '_id' generado como ObjectId y la 'fecha' convertida a formato ISODate. Luego, se define un arreglo de asistentes, asegurando que el campo 'evento_id' se mapee correctamente a los ObjectId de los eventos correspondientes. Finalmente, se insertan los eventos en la colección 'evento' y los asistentes en la colección 'asistente', manteniendo la integridad referencial al utilizar los ObjectId generados.\",\n    \"scriptForDataValidation\": \"const eventosMigrados = db.evento.find().toArray();\\nconst asistentesMigrados = db.asistente.find().toArray();\\n\\n// Validación de eventos\\nconst eventosValidos = eventosMigrados.every(evento => {\\n  return evento._id && typeof evento.nombre === 'string' &&\\n         evento.fecha instanceof Date && evento.ubicacion;\\n});\\n\\nif (!eventosValidos) {\\n  print('Error: Uno o más eventos no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los eventos son válidos.');\\n}\\n\\n// Validación de asistentes\\nconst asistentesValidos = asistentesMigrados.every(asistente => {\\n  return asistente._id && typeof asistente.nombre === 'string' &&\\n         typeof asistente.email === 'string' &&\\n         asistente.evento_id && db.evento.findOne({ _id: asistente.evento_id });\\n});\\n\\nif (!asistentesValidos) {\\n  print('Error: Uno o más asistentes no cumplen con el esquema esperado o tienen un evento_id no válido.');\\n} else {\\n  print('Todos los asistentes son válidos y tienen referencias de evento_id correctas.');\\n}\\n\\n// Contar eventos y asistentes\\nprint('Total de eventos migrados: ' + eventosMigrados.length);\\nprint('Total de asistentes migrados: ' + asistentesMigrados.length);\",\n    \"metadataForDataValidation\": \"El script comienza recuperando todos los documentos de las colecciones 'evento' y 'asistente' en MongoDB. Luego, valida que cada evento tenga los campos requeridos y que la 'fecha' sea un objeto Date. Para los asistentes, valida que tengan los campos requeridos y que el 'evento_id' referencie un evento existente en la colección 'evento'. Si se encuentra algún error, se imprime un mensaje de error; de lo contrario, se confirma que todos los documentos son válidos. Finalmente, se imprime el total de eventos y asistentes migrados.\"\n}"
        },
        {
          "name": "prueba-1-sencilla-2",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"MongoDB\",\r\n  \"applicationRequirements\": \"The application is a simple event management system that allows users to create events and register attendees.\\nThe operations supported by the application are:\\n\\n- Create an event\\nINSERT INTO evento (nombre, fecha, ubicacion) VALUES ('Conferencia Tech', '2025-03-15 10:00:00', 'Centro de Convenciones');\\n\\n- Register an attendee\\nINSERT INTO asistente (nombre, email, evento_id) VALUES ('Juan Pérez', 'juan.perez@example.com', 1);\\n\\n- Count how many attendees are registered for each event\\nSELECT e.nombre AS evento, COUNT(a.id) AS total_asistentes\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nGROUP BY e.id, e.nombre;\\n\\n- Get a list of events without attendees\\nSELECT e.id, e.nombre, e.fecha, e.ubicacion\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nWHERE a.id IS NULL;\",\r\n  \"applicationArchitecture\": \"The application is a monolithic application.\",\r\n  \"underlyingTechnologies\": \"The application is built with Java and Spring Boot.\",\r\n  \"databaseSchema\": \"CREATE DATABASE eventos_db;\\nUSE eventos_db;\\n\\n-- Tabla de eventos\\nCREATE TABLE evento (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nfecha DATETIME NOT NULL,\\nubicacion VARCHAR(255) NOT NULL\\n);\\n\\n-- Tabla de asistentes\\nCREATE TABLE asistente (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nemail VARCHAR(255) UNIQUE NOT NULL,\\nevento_id INT NOT NULL,\\nFOREIGN KEY (evento_id) REFERENCES evento(id) ON DELETE CASCADE\\n);\",\r\n  \"migrationRequirements\": \"Seleccionar los registros de las tablas 'evento' y 'asistente'.\\nConvertir la columna 'id' en '_id' para alinearla con MongoDB.\\nLa columna 'fecha' en 'evento' debe convertirse a formato ISODate.\\nEn la tabla 'asistente', el campo 'evento_id' debe mapearse como una referencia a '_id' en la colección 'evento'\\nInsertar los eventos en la colección 'evento' con '_id' como ObjectId y 'fecha' en formato ISODate.\\nInsertar los asistentes en la colección 'asistente', asegurando que 'evento_id' almacene una referencia a '_id' en 'evento'.\\nMantener la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:26:30 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"db.createCollection('evento');\\n\\ndb.evento.insertMany([\\n  { _id: ObjectId(), nombre: 'Concierto de Rock', fecha: ISODate('2023-10-15T20:00:00Z'), ubicacion: 'Estadio Nacional' },\\n  { _id: ObjectId(), nombre: 'Feria de Tecnología', fecha: ISODate('2023-11-01T10:00:00Z'), ubicacion: 'Centro de Convenciones' }\\n]);\\n\\ndb.createCollection('asistente');\\n\\ndb.asistente.insertMany([\\n  { _id: ObjectId(), nombre: 'Juan Pérez', email: 'juan.perez@example.com', evento_id: ObjectId('evento_id_1') },\\n  { _id: ObjectId(), nombre: 'María López', email: 'maria.lopez@example.com', evento_id: ObjectId('evento_id_2') }\\n]);\",\n    \"metadataForMigrateSchema\": \"El script crea dos colecciones en MongoDB: 'evento' y 'asistente'. En la colección 'evento', se insertan registros con los campos '_id', 'nombre', 'fecha' (en formato ISODate) y 'ubicacion'. En la colección 'asistente', se insertan registros que incluyen '_id', 'nombre', 'email' y 'evento_id', donde 'evento_id' hace referencia al '_id' de un evento en la colección 'evento'. Las referencias se manejan manualmente, ya que MongoDB no tiene claves foráneas como MySQL.\",\n    \"guidelinesForValidateSchema\": \"Aquí tienes un conjunto de pautas y recomendaciones detalladas para validar manualmente la migración del esquema desde MySQL a MongoDB, así como la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### Pautas para la Verificación de la Migración\\n\\n#### 1. Verificación de la Estructura de las Colecciones\\n\\n- **Paso 1:** Conéctate a la base de datos MongoDB utilizando una herramienta como MongoDB Compass o la línea de comandos de MongoDB.\\n  \\n- **Paso 2:** Verifica que las colecciones 'evento' y 'asistente' hayan sido creadas correctamente.\\n  ```javascript\\n  show collections;\\n  ```\\n\\n- **Paso 3:** Inspecciona la estructura de la colección 'evento'.\\n  ```javascript\\n  db.evento.find().pretty();\\n  ```\\n  - **Punto de Control:** Asegúrate de que cada documento contenga los campos `_id`, `nombre`, `fecha` (en formato ISODate) y `ubicacion`.\\n\\n- **Paso 4:** Inspecciona la estructura de la colección 'asistente'.\\n  ```javascript\\n  db.asistente.find().pretty();\\n  ```\\n  - **Punto de Control:** Verifica que cada documento contenga los campos `_id`, `nombre`, `email` y `evento_id`, y que `evento_id` sea un ObjectId.\\n\\n#### 2. Validación de los Datos Migrados\\n\\n- **Paso 5:** Comprueba que los eventos se hayan insertado correctamente.\\n  ```javascript\\n  db.evento.count();\\n  ```\\n  - **Punto de Control:** El número de eventos debe coincidir con el número de registros en la tabla `evento` de MySQL.\\n\\n- **Paso 6:** Comprueba que los asistentes se hayan insertado correctamente.\\n  ```javascript\\n  db.asistente.count();\\n  ```\\n  - **Punto de Control:** El número de asistentes debe coincidir con el número de registros en la tabla `asistente` de MySQL.\\n\\n- **Paso 7:** Verifica que `evento_id` en la colección 'asistente' referencie correctamente los `_id` de la colección 'evento'.\\n  ```javascript\\n  db.asistente.find().forEach(function(a) {\\n      var evento = db.evento.findOne({ _id: a.evento_id });\\n      if (!evento) {\\n          print(\\\"Evento no encontrado para el asistente: \\\" + a.nombre);\\n      }\\n  });\\n  ```\\n\\n#### 3. Pruebas de Consultas\\n\\n- **Paso 8:** Realiza pruebas de las consultas que se utilizarán en la aplicación.\\n\\n  - **Contar asistentes por evento:**\\n    ```javascript\\n    db.evento.aggregate([\\n        {\\n            $lookup: {\\n                from: \\\"asistente\\\",\\n                localField: \\\"_id\\\",\\n                foreignField: \\\"evento_id\\\",\\n                as: \\\"asistentes\\\"\\n            }\\n        },\\n        {\\n            $project: {\\n                nombre: 1,\\n                total_asistentes: { $size: \\\"$asistentes\\\" }\\n            }\\n        }\\n    ]);\\n    ```\\n\\n  - **Obtener eventos sin asistentes:**\\n    ```javascript\\n    db.evento.aggregate([\\n        {\\n            $lookup: {\\n                from: \\\"asistente\\\",\\n                localField: \\\"_id\\\",\\n                foreignField: \\\"evento_id\\\",\\n                as: \\\"asistentes\\\"\\n            }\\n        },\\n        {\\n            $match: {\\n                \\\"asistentes\\\": { $eq: [] }\\n            }\\n        },\\n        {\\n            $project: {\\n                _id: 1,\\n                nombre: 1,\\n                fecha: 1,\\n                ubicacion: 1\\n            }\\n        }\\n    ]);\\n    ```\\n\\n#### 4. Optimización del Esquema\\n\\n- **Paso 9:** Asegúrate de que las colecciones estén indexadas adecuadamente. Por ejemplo, considera crear un índice en el campo `evento_id` en la colección 'asistente' para optimizar las consultas.\\n  ```javascript\\n  db.asistente.createIndex({ evento_id: 1 });\\n  ```\\n\\n- **Paso 10:** Revisa el uso de los tipos de datos. Asegúrate de que todos los campos sean del tipo correcto y optimizados para su uso.\\n\\n#### 5. Mantenimiento de la Integridad Referencial\\n\\n- **Paso 11:** Dado que MongoDB no impone claves foráneas, implementa un proceso manual para verificar la integridad referencial. Puedes crear un script que valide periódicamente que todos los `evento_id` en 'asistente' correspondan a un `_id` en 'evento'.\\n\\n### Conclusión\\n\\nSiguiendo estas pautas, podrás validar que la migración del esquema desde MySQL a MongoDB se ha realizado correctamente y que el nuevo esquema está optimizado para las consultas y el rendimiento. Recuerda documentar cualquier inconsistencia o error encontrado durante el proceso para su posterior corrección.\",\n    \"scriptForDataMigration\": \"import mysql.connector\\nfrom pymongo import MongoClient\\nfrom bson import ObjectId\\n\\n# Conexión a la base de datos MySQL\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_user',\\n    password='your_password',\\n    database='eventos_db'\\n)\\n\\n# Conexión a la base de datos MongoDB\\nmongo_client = MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['eventos_db']\\n\\ndef migrate_events():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM evento')\\n    eventos = cursor.fetchall()\\n    for evento in eventos:\\n        mongo_db.evento.insert_one({\\n            '_id': ObjectId(),\\n            'nombre': evento['nombre'],\\n            'fecha': evento['fecha'],\\n            'ubicacion': evento['ubicacion']\\n        })\\n    cursor.close()\\n\\n\\ndef migrate_assistants():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM asistente')\\n    asistentes = cursor.fetchall()\\n    for asistente in asistentes:\\n        # Obtener el evento_id de MySQL\\n        evento_id = asistente['evento_id']\\n        # Buscar el _id correspondiente en MongoDB\\n        evento = mongo_db.evento.find_one({'evento_id': evento_id})\\n        if evento:\\n            mongo_db.asistente.insert_one({\\n                '_id': ObjectId(),\\n                'nombre': asistente['nombre'],\\n                'email': asistente['email'],\\n                'evento_id': evento['_id']\\n            })\\n    cursor.close()\\n\\n# Ejecutar migraciones\\nmigrate_events()\\nmigrate_assistants()\\n\\n# Cerrar conexiones\\nmysql_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataMigration\": \"El script establece conexiones a las bases de datos MySQL y MongoDB. Primero, se migran los eventos desde la tabla 'evento' de MySQL a la colección 'evento' en MongoDB, transformando el campo 'id' en '_id' y manteniendo la fecha en formato ISODate. Luego, se migran los asistentes desde la tabla 'asistente', donde se busca el 'evento_id' en MongoDB para asegurar la integridad referencial, almacenando el '_id' del evento correspondiente. Finalmente, se cierran las conexiones a ambas bases de datos.\",\n    \"scriptForDataValidation\": \"import mysql.connector\\nfrom pymongo import MongoClient\\n\\n# Conexión a la base de datos MySQL\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_user',\\n    password='your_password',\\n    database='eventos_db'\\n)\\n\\n# Conexión a la base de datos MongoDB\\nmongo_client = MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['eventos_db']\\n\\ndef validate_events():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM evento')\\n    mysql_eventos = cursor.fetchall()\\n    mongo_eventos = list(mongo_db.evento.find())\\n\\n    # Verificar conteo de eventos\\n    if len(mysql_eventos) != len(mongo_eventos):\\n        print(f'Error: Número de eventos no coincide. MySQL: {len(mysql_eventos)}, MongoDB: {len(mongo_eventos)}')\\n    else:\\n        print('Número de eventos coincide.')\\n\\n    # Verificar contenido de eventos\\n    for evento in mysql_eventos:\\n        mongo_evento = next((e for e in mongo_eventos if e['nombre'] == evento['nombre']), None)\\n        if mongo_evento:\\n            if mongo_evento['fecha'] != evento['fecha']:\\n                print(f'Error: La fecha no coincide para el evento {evento['nombre']}.')\\n            if mongo_evento['ubicacion'] != evento['ubicacion']:\\n                print(f'Error: La ubicación no coincide para el evento {evento['nombre']}.')\\n        else:\\n            print(f'Error: Evento {evento['nombre']} no encontrado en MongoDB.')\\n    cursor.close()\\n\\n\\ndef validate_assistants():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM asistente')\\n    mysql_asistentes = cursor.fetchall()\\n    mongo_asistentes = list(mongo_db.asistente.find())\\n\\n    # Verificar conteo de asistentes\\n    if len(mysql_asistentes) != len(mongo_asistentes):\\n        print(f'Error: Número de asistentes no coincide. MySQL: {len(mysql_asistentes)}, MongoDB: {len(mongo_asistentes)}')\\n    else:\\n        print('Número de asistentes coincide.')\\n\\n    # Verificar contenido de asistentes\\n    for asistente in mysql_asistentes:\\n        mongo_asistente = next((a for a in mongo_asistentes if a['email'] == asistente['email']), None)\\n        if mongo_asistente:\\n            # Verificar referencia a evento\\n            evento_id = asistente['evento_id']\\n            mongo_evento = mongo_db.evento.find_one({'_id': mongo_asistente['evento_id']})\\n            if not mongo_evento:\\n                print(f'Error: Evento referenciado por el asistente {asistente['nombre']} no encontrado en MongoDB.')\\n        else:\\n            print(f'Error: Asistente {asistente['nombre']} no encontrado en MongoDB.')\\n    cursor.close()\\n\\n# Ejecutar validaciones\\nvalidate_events()\\nvalidate_assistants()\\n\\n# Cerrar conexiones\\nmysql_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataValidation\": \"El script establece conexiones a las bases de datos MySQL y MongoDB. Primero, valida los eventos comparando el conteo y el contenido de cada evento entre MySQL y MongoDB, verificando que las fechas y ubicaciones coincidan. Luego, valida los asistentes, asegurando que el conteo coincida y que cada asistente tenga un evento referenciado correctamente en MongoDB. Se imprimen errores si hay discrepancias. Finalmente, se cierran las conexiones a ambas bases de datos.\"\n}"
        },
        {
          "name": "prueba-1-sencilla-3",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"MongoDB\",\r\n  \"applicationRequirements\": \"The application is a simple event management system that allows users to create events and register attendees.\\nThe operations supported by the application are:\\n\\n- Create an event\\nINSERT INTO evento (nombre, fecha, ubicacion) VALUES ('Conferencia Tech', '2025-03-15 10:00:00', 'Centro de Convenciones');\\n\\n- Register an attendee\\nINSERT INTO asistente (nombre, email, evento_id) VALUES ('Juan Pérez', 'juan.perez@example.com', 1);\\n\\n- Count how many attendees are registered for each event\\nSELECT e.nombre AS evento, COUNT(a.id) AS total_asistentes\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nGROUP BY e.id, e.nombre;\\n\\n- Get a list of events without attendees\\nSELECT e.id, e.nombre, e.fecha, e.ubicacion\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nWHERE a.id IS NULL;\",\r\n  \"applicationArchitecture\": \"The application is a monolithic application.\",\r\n  \"underlyingTechnologies\": \"The application is built with Java and Spring Boot.\",\r\n  \"databaseSchema\": \"CREATE DATABASE eventos_db;\\nUSE eventos_db;\\n\\n-- Tabla de eventos\\nCREATE TABLE evento (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nfecha DATETIME NOT NULL,\\nubicacion VARCHAR(255) NOT NULL\\n);\\n\\n-- Tabla de asistentes\\nCREATE TABLE asistente (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nemail VARCHAR(255) UNIQUE NOT NULL,\\nevento_id INT NOT NULL,\\nFOREIGN KEY (evento_id) REFERENCES evento(id) ON DELETE CASCADE\\n);\",\r\n  \"migrationRequirements\": \"Seleccionar los registros de las tablas 'evento' y 'asistente'.\\nConvertir la columna 'id' en '_id' para alinearla con MongoDB.\\nLa columna 'fecha' en 'evento' debe convertirse a formato ISODate.\\nEn la tabla 'asistente', el campo 'evento_id' debe mapearse como una referencia a '_id' en la colección 'evento'\\nInsertar los eventos en la colección 'evento' con '_id' como ObjectId y 'fecha' en formato ISODate.\\nInsertar los asistentes en la colección 'asistente', asegurando que 'evento_id' almacene una referencia a '_id' en 'evento'.\\nMantener la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:33:46 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"db.createCollection('evento');\\n\\ndb.evento.insertMany([\\n  { _id: ObjectId(), nombre: 'Concierto de Rock', fecha: ISODate('2023-10-15T20:00:00Z'), ubicacion: 'Estadio Nacional' },\\n  { _id: ObjectId(), nombre: 'Feria de Tecnología', fecha: ISODate('2023-11-01T10:00:00Z'), ubicacion: 'Centro de Convenciones' }\\n]);\\n\\ndb.createCollection('asistente');\\n\\ndb.asistente.insertMany([\\n  { _id: ObjectId(), nombre: 'Juan Pérez', email: 'juan.perez@example.com', evento_id: ObjectId('evento_id_1') },\\n  { _id: ObjectId(), nombre: 'María López', email: 'maria.lopez@example.com', evento_id: ObjectId('evento_id_2') }\\n]);\",\n    \"metadataForMigrateSchema\": \"El script crea dos colecciones en MongoDB: 'evento' y 'asistente'. En la colección 'evento', se insertan registros con los campos '_id', 'nombre', 'fecha' (en formato ISODate) y 'ubicacion'. En la colección 'asistente', se insertan registros que incluyen '_id', 'nombre', 'email' y 'evento_id', donde 'evento_id' hace referencia al '_id' de un evento en la colección 'evento'. Las referencias se manejan manualmente, ya que MongoDB no tiene claves foráneas como MySQL.\",\n    \"guidelinesForValidateSchema\": \"Aquí tienes un conjunto de pautas y recomendaciones detalladas para validar manualmente la migración del esquema desde MySQL a MongoDB, así como la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### Pautas para la Verificación de la Migración del Esquema\\n\\n#### 1. Verificación de la Estructura de las Colecciones\\n\\n- **Paso 1:** Conéctate a la base de datos MongoDB utilizando una herramienta como MongoDB Compass o la línea de comandos de MongoDB.\\n\\n- **Paso 2:** Verifica que las colecciones 'evento' y 'asistente' han sido creadas correctamente.\\n  ```javascript\\n  show collections;\\n  ```\\n\\n- **Paso 3:** Inspecciona la estructura de la colección 'evento'.\\n  ```javascript\\n  db.evento.find().pretty();\\n  ```\\n  - **Punto de Control:** Asegúrate de que cada documento contenga los campos `_id`, `nombre`, `fecha` (en formato ISODate) y `ubicacion`.\\n\\n- **Paso 4:** Inspecciona la estructura de la colección 'asistente'.\\n  ```javascript\\n  db.asistente.find().pretty();\\n  ```\\n  - **Punto de Control:** Verifica que cada documento contenga los campos `_id`, `nombre`, `email` y `evento_id`, y que `evento_id` sea un ObjectId.\\n\\n#### 2. Validación de los Datos Migrados\\n\\n- **Paso 5:** Comprueba que los eventos se hayan insertado correctamente.\\n  ```javascript\\n  db.evento.count();\\n  ```\\n  - **Punto de Control:** El número de eventos debe coincidir con el número de registros en la tabla `evento` de MySQL.\\n\\n- **Paso 6:** Comprueba que los asistentes se hayan insertado correctamente.\\n  ```javascript\\n  db.asistente.count();\\n  ```\\n  - **Punto de Control:** El número de asistentes debe coincidir con el número de registros en la tabla `asistente` de MySQL.\\n\\n- **Paso 7:** Verifica que `evento_id` en la colección 'asistente' referencie correctamente los `_id` de la colección 'evento'.\\n  ```javascript\\n  db.asistente.find().forEach(function(a) {\\n      var evento = db.evento.findOne({ _id: a.evento_id });\\n      if (!evento) {\\n          print(\\\"Evento no encontrado para el asistente: \\\" + a.nombre);\\n      }\\n  });\\n  ```\\n\\n#### 3. Pruebas de Consultas\\n\\n- **Paso 8:** Realiza pruebas de las consultas que se utilizarán en la aplicación.\\n\\n  - **Contar asistentes por evento:**\\n    ```javascript\\n    db.evento.aggregate([\\n        {\\n            $lookup: {\\n                from: \\\"asistente\\\",\\n                localField: \\\"_id\\\",\\n                foreignField: \\\"evento_id\\\",\\n                as: \\\"asistentes\\\"\\n            }\\n        },\\n        {\\n            $project: {\\n                nombre: 1,\\n                total_asistentes: { $size: \\\"$asistentes\\\" }\\n            }\\n        }\\n    ]);\\n    ```\\n\\n  - **Obtener eventos sin asistentes:**\\n    ```javascript\\n    db.evento.aggregate([\\n        {\\n            $lookup: {\\n                from: \\\"asistente\\\",\\n                localField: \\\"_id\\\",\\n                foreignField: \\\"evento_id\\\",\\n                as: \\\"asistentes\\\"\\n            }\\n        },\\n        {\\n            $match: {\\n                \\\"asistentes\\\": { $eq: [] }\\n            }\\n        },\\n        {\\n            $project: {\\n                _id: 1,\\n                nombre: 1,\\n                fecha: 1,\\n                ubicacion: 1\\n            }\\n        }\\n    ]);\\n    ```\\n\\n#### 4. Optimización del Esquema\\n\\n- **Paso 9:** Asegúrate de que las colecciones estén indexadas adecuadamente. Por ejemplo, considera crear un índice en el campo `evento_id` en la colección 'asistente' para optimizar las consultas.\\n  ```javascript\\n  db.asistente.createIndex({ evento_id: 1 });\\n  ```\\n\\n- **Paso 10:** Revisa el uso de los tipos de datos. Asegúrate de que todos los campos sean del tipo correcto y optimizados para su uso.\\n\\n#### 5. Mantenimiento de la Integridad Referencial\\n\\n- **Paso 11:** Dado que MongoDB no impone claves foráneas, implementa un proceso manual para verificar la integridad referencial. Puedes crear un script que valide periódicamente que todos los `evento_id` en 'asistente' correspondan a un `_id` en 'evento'.\\n\\n### Conclusión\\n\\nSiguiendo estas pautas, podrás validar que la migración del esquema desde MySQL a MongoDB se ha realizado correctamente y que el nuevo esquema está optimizado para las consultas y el rendimiento. Recuerda documentar cualquier inconsistencia o error encontrado durante el proceso para su posterior corrección.\",\n    \"scriptForDataMigration\": \"import mysql.connector\\nfrom pymongo import MongoClient\\nfrom bson import ObjectId\\n\\n# Conexión a la base de datos MySQL\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_mysql_user',\\n    password='your_mysql_password',\\n    database='eventos_db'\\n)\\n\\n# Conexión a la base de datos MongoDB\\nmongo_client = MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['eventos_db']\\n\\ndef migrate_events():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM evento')\\n    eventos = cursor.fetchall()\\n    for evento in eventos:\\n        mongo_db.evento.insert_one({\\n            '_id': ObjectId(),\\n            'nombre': evento['nombre'],\\n            'fecha': evento['fecha'],\\n            'ubicacion': evento['ubicacion']\\n        })\\n    cursor.close()\\n\\n\\ndef migrate_assistants():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM asistente')\\n    asistentes = cursor.fetchall()\\n    for asistente in asistentes:\\n        # Obtener el evento_id de MySQL\\n        evento_id = asistente['evento_id']\\n        # Buscar el _id correspondiente en MongoDB\\n        evento = mongo_db.evento.find_one({'nombre': evento_id})\\n        if evento:\\n            mongo_db.asistente.insert_one({\\n                '_id': ObjectId(),\\n                'nombre': asistente['nombre'],\\n                'email': asistente['email'],\\n                'evento_id': evento['_id']\\n            })\\n    cursor.close()\\n\\n# Ejecutar migraciones\\nmigrate_events()\\nmigrate_assistants()\\n\\n# Cerrar conexiones\\nmysql_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataMigration\": \"El script establece conexiones a las bases de datos MySQL y MongoDB. Primero, se migran los eventos desde la tabla 'evento' de MySQL a la colección 'evento' en MongoDB, transformando el campo 'id' en '_id' y manteniendo la fecha en formato ISODate. Luego, se migran los asistentes desde la tabla 'asistente', donde se busca el 'evento_id' en MongoDB para asegurar la integridad referencial, almacenando el '_id' del evento correspondiente. Finalmente, se cierran las conexiones a ambas bases de datos.\",\n    \"scriptForDataValidation\": \"import mysql.connector\\nfrom pymongo import MongoClient\\n\\n# Conexión a la base de datos MySQL\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_mysql_user',\\n    password='your_mysql_password',\\n    database='eventos_db'\\n)\\n\\n# Conexión a la base de datos MongoDB\\nmongo_client = MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['eventos_db']\\n\\n# Función para validar eventos\\ndef validate_events():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM evento')\\n    mysql_eventos = cursor.fetchall()\\n    mongo_eventos = list(mongo_db.evento.find())\\n\\n    # Verificar conteo de eventos\\n    if len(mysql_eventos) != len(mongo_eventos):\\n        print(f'Error: Número de eventos no coincide. MySQL: {len(mysql_eventos)}, MongoDB: {len(mongo_eventos)}')\\n    else:\\n        print('Número de eventos coincide.')\\n\\n    # Verificar contenido de eventos\\n    for evento in mysql_eventos:\\n        mongo_evento = next((e for e in mongo_eventos if e['nombre'] == evento['nombre']), None)\\n        if mongo_evento:\\n            if mongo_evento['fecha'] != evento['fecha']:\\n                print(f'Error: La fecha no coincide para el evento {evento['nombre']}.')\\n            if mongo_evento['ubicacion'] != evento['ubicacion']:\\n                print(f'Error: La ubicación no coincide para el evento {evento['nombre']}.')\\n        else:\\n            print(f'Error: Evento {evento['nombre']} no encontrado en MongoDB.')\\n    cursor.close()\\n\\n# Función para validar asistentes\\ndef validate_assistants():\\n    cursor = mysql_conn.cursor(dictionary=True)\\n    cursor.execute('SELECT * FROM asistente')\\n    mysql_asistentes = cursor.fetchall()\\n    mongo_asistentes = list(mongo_db.asistente.find())\\n\\n    # Verificar conteo de asistentes\\n    if len(mysql_asistentes) != len(mongo_asistentes):\\n        print(f'Error: Número de asistentes no coincide. MySQL: {len(mysql_asistentes)}, MongoDB: {len(mongo_asistentes)}')\\n    else:\\n        print('Número de asistentes coincide.')\\n\\n    # Verificar contenido de asistentes\\n    for asistente in mysql_asistentes:\\n        mongo_asistente = next((a for a in mongo_asistentes if a['email'] == asistente['email']), None)\\n        if mongo_asistente:\\n            # Verificar referencia a evento\\n            evento_id = asistente['evento_id']\\n            mongo_evento = mongo_db.evento.find_one({'_id': mongo_asistente['evento_id']})\\n            if not mongo_evento:\\n                print(f'Error: Evento referenciado por el asistente {asistente['nombre']} no encontrado en MongoDB.')\\n        else:\\n            print(f'Error: Asistente {asistente['nombre']} no encontrado en MongoDB.')\\n    cursor.close()\\n\\n# Ejecutar validaciones\\nvalidate_events()\\nvalidate_assistants()\\n\\n# Cerrar conexiones\\nmysql_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataValidation\": \"El script establece conexiones a las bases de datos MySQL y MongoDB. Primero, valida los eventos comparando el conteo y el contenido de cada evento entre MySQL y MongoDB, verificando que las fechas y ubicaciones coincidan. Luego, valida los asistentes, asegurando que el conteo coincida y que cada asistente tenga un evento referenciado correctamente en MongoDB. Se imprimen errores si hay discrepancias. Finalmente, se cierran las conexiones a ambas bases de datos.\"\n}"
        },
        {
          "name": "prueba-1-sencilla-4",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"MongoDB\",\r\n  \"applicationRequirements\": \"The application is a simple event management system that allows users to create events and register attendees.\\nThe operations supported by the application are:\\n\\n- Create an event\\nINSERT INTO evento (nombre, fecha, ubicacion) VALUES ('Conferencia Tech', '2025-03-15 10:00:00', 'Centro de Convenciones');\\n\\n- Register an attendee\\nINSERT INTO asistente (nombre, email, evento_id) VALUES ('Juan Pérez', 'juan.perez@example.com', 1);\\n\\n- Count how many attendees are registered for each event\\nSELECT e.nombre AS evento, COUNT(a.id) AS total_asistentes\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nGROUP BY e.id, e.nombre;\\n\\n- Get a list of events without attendees\\nSELECT e.id, e.nombre, e.fecha, e.ubicacion\\nFROM evento e\\nLEFT JOIN asistente a ON e.id = a.evento_id\\nWHERE a.id IS NULL;\",\r\n  \"applicationArchitecture\": \"The application is a monolithic application.\",\r\n  \"underlyingTechnologies\": \"The application is built with Java and Spring Boot.\",\r\n  \"databaseSchema\": \"CREATE DATABASE eventos_db;\\nUSE eventos_db;\\n\\n-- Tabla de eventos\\nCREATE TABLE evento (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nfecha DATETIME NOT NULL,\\nubicacion VARCHAR(255) NOT NULL\\n);\\n\\n-- Tabla de asistentes\\nCREATE TABLE asistente (\\nid INT PRIMARY KEY AUTO_INCREMENT,\\nnombre VARCHAR(255) NOT NULL,\\nemail VARCHAR(255) UNIQUE NOT NULL,\\nevento_id INT NOT NULL,\\nFOREIGN KEY (evento_id) REFERENCES evento(id) ON DELETE CASCADE\\n);\",\r\n  \"migrationRequirements\": \"Seleccionar los registros de las tablas 'evento' y 'asistente'.\\nConvertir la columna 'id' en '_id' para alinearla con MongoDB.\\nLa columna 'fecha' en 'evento' debe convertirse a formato ISODate.\\nEn la tabla 'asistente', el campo 'evento_id' debe mapearse como una referencia a '_id' en la colección 'evento'\\nInsertar los eventos en la colección 'evento' con '_id' como ObjectId y 'fecha' en formato ISODate.\\nInsertar los asistentes en la colección 'asistente', asegurando que 'evento_id' almacene una referencia a '_id' en 'evento'.\\nMantener la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:58:12 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"db.createCollection('evento');\\n\\ndb.evento.insertMany([\\n    { _id: ObjectId(), nombre: 'Evento 1', fecha: ISODate('2023-10-01T10:00:00Z'), ubicacion: 'Ubicación 1' },\\n    { _id: ObjectId(), nombre: 'Evento 2', fecha: ISODate('2023-10-15T10:00:00Z'), ubicacion: 'Ubicación 2' },\\n    { _id: ObjectId(), nombre: 'Evento 3', fecha: ISODate('2023-11-01T10:00:00Z'), ubicacion: 'Ubicación 3' }\\n]);\\n\\ndb.createCollection('asistente');\\n\\ndb.asistente.insertMany([\\n    { _id: ObjectId(), nombre: 'Asistente 1', email: 'asistente1@example.com', evento_id: ObjectId('EVENTO_ID_1') },\\n    { _id: ObjectId(), nombre: 'Asistente 2', email: 'asistente2@example.com', evento_id: ObjectId('EVENTO_ID_2') },\\n    { _id: ObjectId(), nombre: 'Asistente 3', email: 'asistente3@example.com', evento_id: ObjectId('EVENTO_ID_3') }\\n]);\",\n    \"metadataForMigrateSchema\": \"El script crea dos colecciones en MongoDB: 'evento' y 'asistente'. En la colección 'evento', se insertan documentos con un campo '_id' que utiliza ObjectId y un campo 'fecha' que se almacena en formato ISODate. En la colección 'asistente', cada documento también tiene un campo '_id' y se almacena una referencia a 'evento_id', que corresponde al '_id' de la colección 'evento'. Esto mantiene la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente. Los valores de 'EVENTO_ID_X' deben ser reemplazados por los ObjectId reales de los documentos insertados en la colección 'evento'.\",\n    \"guidelinesForValidateSchema\": \"### Pautas y Recomendaciones para la Validación de la Migración de Esquema de MySQL a MongoDB\\n\\nA continuación se presentan pasos detallados que el usuario puede seguir para validar manualmente la transformación del esquema desde MySQL a MongoDB y asegurar que el nuevo esquema esté correctamente implementado y optimizado.\\n\\n#### 1. Verificación de la Estructura del Esquema\\n\\n**Paso 1: Comparar la Estructura de las Colecciones**\\n- Utilizar herramientas como `MongoDB Compass` o `mongosh` para visualizar la estructura de las colecciones en la base de datos MongoDB.\\n- Comparar cada colección del esquema original de MySQL con el esquema de MongoDB:\\n  - **Nombres de Colecciones y Campos**: Asegurarse de que los nombres de las colecciones y los campos sean correctos.\\n  - **Tipos de Datos**: Verificar que los tipos de datos sean correctos (ej. `ObjectId`, `String`, `Date`).\\n  - **Estructura Anidada**: Confirmar que las estructuras anidadas se hayan convertido correctamente en documentos.\\n\\n**Paso 2: Validar las Referencias**\\n- Comprobar que los campos que actúan como referencias (ej. `evento_id` en la colección `asistente`) estén correctamente asignados con los `ObjectId` de la colección `evento`.\\n- Realizar consultas para verificar que los `evento_id` en `asistente` corresponden a documentos existentes en `evento`:\\n  ```javascript\\n  db.asistente.find().forEach(function(asistente) {\\n      if (!db.evento.findOne({ _id: asistente.evento_id })) {\\n          print('Referencia inválida para asistente: ' + asistente.nombre);\\n      }\\n  });\\n  ```\\n\\n#### 2. Verificación de Datos\\n\\n**Paso 3: Validar la Migración de Datos**\\n- Comparar el conteo de documentos entre las tablas de origen en MySQL y las colecciones de destino en MongoDB:\\n  ```javascript\\n  db.evento.count(); // Debería coincidir con el número de eventos en MySQL\\n  db.asistente.count(); // Debería coincidir con el número de asistentes en MySQL\\n  ```\\n- Verificar algunos documentos aleatorios de cada colección para asegurarse de que los datos se han migrado correctamente:\\n  ```javascript\\n  db.evento.find().limit(5).pretty();\\n  db.asistente.find().limit(5).pretty();\\n  ```\\n\\n#### 3. Optimización del Esquema\\n\\n**Paso 4: Evaluar la Indexación**\\n- Revisar los índices en las colecciones de MongoDB y asegurarse de que se han creado índices adecuados para mejorar el rendimiento de las consultas.\\n- Crear índices en campos clave como `email` en `asistente` para garantizar la unicidad:\\n  ```javascript\\n  db.asistente.createIndex({ email: 1 }, { unique: true });\\n  ```\\n\\n#### 4. Pruebas de Funcionalidad\\n\\n**Paso 5: Probar Funcionalidades de la Aplicación**\\n- Si hay una aplicación que interactúa con la base de datos, realizar pruebas funcionales para garantizar que todas las características y funcionalidades funcionan como se espera.\\n- Asegurarse de que las operaciones de inserción, actualización y eliminación funcionan correctamente y que las referencias se mantienen.\\n\\n#### 5. Documentación y Reportes\\n\\n**Paso 6: Documentar Resultados**\\n- Documentar todos los resultados de las pruebas de validación, incluyendo cualquier discrepancia encontrada y cómo se resolvió.\\n- Mantener un registro de las consultas de rendimiento y cualquier ajuste realizado en el esquema.\\n\\n### Conclusión\\nSiguiendo estos pasos y recomendaciones, el usuario podrá validar de manera efectiva la migración del esquema de MySQL a MongoDB, asegurando que la nueva base de datos esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"-- Migración de datos desde MySQL a MongoDB\\n\\n-- 1. Seleccionar los registros de la tabla evento\\nSELECT id AS _id, nombre, fecha, ubicacion \\nFROM evento;\\n\\n-- 2. Insertar los eventos en la colección evento en MongoDB\\n\\n-- Suponiendo que se ha ejecutado el SELECT anterior y se tiene el resultado en un formato adecuado para insertarlo en MongoDB:\\n\\ndb.evento.insertMany([\\n    { _id: ObjectId(), nombre: 'Evento 1', fecha: ISODate('2023-10-01T10:00:00Z'), ubicacion: 'Ubicación 1' },\\n    { _id: ObjectId(), nombre: 'Evento 2', fecha: ISODate('2023-10-15T10:00:00Z'), ubicacion: 'Ubicación 2' },\\n    { _id: ObjectId(), nombre: 'Evento 3', fecha: ISODate('2023-11-01T10:00:00Z'), ubicacion: 'Ubicación 3' }\\n]);\\n\\n-- 3. Seleccionar los registros de la tabla asistente\\nSELECT id AS _id, nombre, email, evento_id \\nFROM asistente;\\n\\n-- 4. Insertar los asistentes en la colección asistente en MongoDB\\n\\n-- Suponiendo que se ha ejecutado el SELECT anterior y se tiene el resultado en un formato adecuado para insertarlo en MongoDB:\\n\\ndb.asistente.insertMany([\\n    { _id: ObjectId(), nombre: 'Asistente 1', email: 'asistente1@example.com', evento_id: ObjectId('EVENTO_ID_1') },\\n    { _id: ObjectId(), nombre: 'Asistente 2', email: 'asistente2@example.com', evento_id: ObjectId('EVENTO_ID_2') },\\n    { _id: ObjectId(), nombre: 'Asistente 3', email: 'asistente3@example.com', evento_id: ObjectId('EVENTO_ID_3') }\\n]);\",\n    \"metadataForDataMigration\": \"El script de migración de datos está diseñado para transferir datos desde una base de datos MySQL a MongoDB. Primero, se seleccionan los registros de la tabla 'evento' y se insertan en la colección 'evento' en MongoDB, asegurando que el campo 'id' se convierta en '_id' y que 'fecha' se almacene en formato ISODate. Luego, se seleccionan los registros de la tabla 'asistente' y se insertan en la colección 'asistente', donde 'evento_id' se mapea como una referencia a '_id' en la colección 'evento'. Este enfoque mantiene la integridad referencial manualmente, ya que MongoDB no impone claves foráneas automáticamente. Los valores de 'EVENTO_ID_X' deben ser reemplazados por los ObjectId reales de los documentos insertados en la colección 'evento'.\",\n    \"scriptForDataValidation\": \"-- Validación de la migración de datos y esquema de MySQL a MongoDB\\n\\n-- 1. Verificar la existencia de colecciones en MongoDB\\ndb.getCollectionNames();\\n\\n-- 2. Comparar la estructura de las colecciones\\n-- Para cada colección, verificar campos y tipos de datos\\n\\n-- Colección evento\\ndb.evento.findOne();\\n\\n-- Colección asistente\\ndb.asistente.findOne();\\n\\n-- 3. Verificar los documentos en la colección evento\\ndb.evento.find().pretty();\\n\\n-- 4. Verificar los documentos en la colección asistente\\ndb.asistente.find().pretty();\\n\\n-- 5. Verificar la integridad referencial\\n-- Comprobar que cada evento_id en asistente existe en evento\\ndb.asistente.find().forEach(function(asistente) {\\n    if (!db.evento.findOne({ _id: asistente.evento_id })) {\\n        print('Referencia inválida para asistente: ' + asistente.nombre);\\n    }\\n});\\n\\n-- 6. Verificar la unicidad del campo email en la colección asistente\\nvar duplicates = db.asistente.aggregate([\\n    { $group: { _id: \\\"$email\\\", count: { $sum: 1 } } },\\n    { $match: { count: { $gt: 1 } } }\\n]);\\n\\nif (duplicates.count() > 0) {\\n    print('Se encontraron correos duplicados en la colección asistente.');\\n} else {\\n    print('No se encontraron correos duplicados en la colección asistente.');\\n}\\n\\n-- 7. Contar documentos en cada colección y comparar con MySQL\\nprint('Conteo de documentos en evento: ' + db.evento.count());\\nprint('Conteo de documentos en asistente: ' + db.asistente.count());\",\n    \"metadataForDataValidation\": \"El script de validación está diseñado para asegurar que la migración de datos y esquema desde MySQL a MongoDB se haya realizado correctamente. Incluye pasos para verificar la existencia de colecciones, comparar la estructura de las colecciones en términos de campos y tipos de datos, y verificar los documentos en cada colección para asegurar que se han migrado correctamente. También se comprueba la integridad referencial asegurando que cada 'evento_id' en la colección 'asistente' corresponde a un '_id' en la colección 'evento'. Además, se verifica la unicidad del campo 'email' en 'asistente' para asegurar que no haya duplicados. Finalmente, se cuentan los documentos en cada colección y se imprimen los resultados para su comparación con los datos originales en MySQL.\"\n}"
        }
      ]
    },
    {
      "name": "metashop",
      "request": {
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"The application is an e-commerce platform that allows customers to browse products, place orders, and manage their payments.\\nThe most frequent queries in the system include:\\n\\n- Listing (ID, name, price, stock) of 'Laptop' category products priced under 1500€ and manufactured by 'LG'.\\n\\n```sql\\nSELECT product_id, name, price, stock\\nFROM PRODUCT\\nWHERE category IN (SELECT category_id\\n                   FROM PRODUCT_CATEGORY\\n                   WHERE name = 'Laptop')\\n  AND price < 1500 and manufacturer = 'LG';\\n```\\n\\n- Retrieving orders placed by customer 'U2929' between 2021-11-01 and 2022-08-31.\\n\\n```sql\\nSELECT * \\nFROM CUSTOMER_ORDER\\nWHERE customer = 'U2929'\\n  AND order_date >= '2021-11-01' AND order_date <= '2022-08-31';\\n```\\n\\n- Getting the products purchased by customer 'U2929' in the same date range.\\n\\n```sql\\nSELECT product_id, name, price\\nFROM PRODUCT\\nWHERE product_id IN (SELECT product\\n                     FROM ORDER_ITEM\\n                     WHERE order_id IN (SELECT order_id\\n                                        FROM CUSTOMER_ORDER\\n                                        WHERE customer = 'U2929'\\n                                        AND order_date >= '2021-11-01' \\n                                        AND order_date <= '2022-08-31'));\\n```\\n\\n- Finding the top 10 best-selling products per country.\\n\\n```sql\\nSELECT P.product_id, P.name, S.country, S.total_sales\\nFROM PRODUCT P JOIN (SELECT I.product prod, U.country, SUM(I.quantity) total_sales\\n                     FROM CUSTOMER_ORDER O JOIN CUSTOMER U ON O.customer = U.customer_id\\n                                   JOIN ORDER_ITEM I ON O.order_id = I.order_id\\n                     GROUP BY I.product, U.country) S\\n               ON P.product_id = S.prod\\nORDER BY S.country, S.total_sales DESC\\nLIMIT 10;\\n```\\n\\n- Identifying customers whose direct or indirect referrals have rated the store poorly (1 or 2 stars).\\n\\n```sql\\nSELECT recommendedby \\nFROM CUSTOMER\\nWHERE shop_opinion < 3;\\n```\\n\\n- Listing direct and indirect recommendations of a customer.\\n\\n```sql\\nSELECT customer_id, name, country\\nFROM CUSTOMER\\nWHERE recommendedby = 'U2929';\\n```\\n\\n- Retrieving products similar to those bought in the latest order of a customer.\\n\\n```sql\\nSELECT product2\\nFROM SIMILAR_PRODUCT\\nWHERE product1 IN (SELECT product\\n                   FROM ORDER_ITEM\\n                   WHERE order_id IN (SELECT order_id\\n                                      FROM CUSTOMER_ORDER O1\\n                                      WHERE customer = 'U2929' \\n                                      AND order_date = (SELECT MAX(order_date) \\n                                                        FROM CUSTOMER_ORDER \\n                                                        WHERE O2.customer = O1.customer)));\\n```\\n\",\r\n  \"applicationArchitecture\": \"The application is a monolithic web application with a backend in Java using Spring Boot.\",\r\n  \"underlyingTechnologies\": \"The backend is developed in Java and Spring Boot, with PostgreSQL as the target database.\",\r\n  \"databaseSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\r\n  \"migrationRequirements\": \"Ensure compatibility between MySQL and PostgreSQL data types.\\nConvert `AUTO_INCREMENT` fields to `SERIAL` in PostgreSQL.\\nReplace `DATETIME` with `TIMESTAMP` where needed.\\nModify `BOOLEAN` fields to ensure PostgreSQL compatibility (`TRUE`/`FALSE`).\\nEnsure foreign keys maintain referential integrity.\\nMigrate queries:\\n  - Convert `LIMIT 10` queries into appropriate window functions when necessary.\\n  - Adapt JOIN conditions and subqueries to PostgreSQL-specific syntax.\\n  - Convert the `shop_opinion` field's check constraints to PostgreSQL syntax.\\n  - Ensure that recursive queries (such as recommendations) are handled efficiently.\\nImport data ensuring sequence values match expected IDs to prevent conflicts in SERIAL fields.\"\r\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{migrations_url}}",
          "host": ["{{migrations_url}}"]
        }
      },
      "response": [
        {
          "name": "metashop-response",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"The application is an e-commerce platform that allows customers to browse products, place orders, and manage their payments.\\nThe most frequent queries in the system include:\\n\\n- Listing (ID, name, price, stock) of 'Laptop' category products priced under 1500€ and manufactured by 'LG'.\\n\\n```sql\\nSELECT product_id, name, price, stock\\nFROM PRODUCT\\nWHERE category IN (SELECT category_id\\n                   FROM PRODUCT_CATEGORY\\n                   WHERE name = 'Laptop')\\n  AND price < 1500 and manufacturer = 'LG';\\n```\\n\\n- Retrieving orders placed by customer 'U2929' between 2021-11-01 and 2022-08-31.\\n\\n```sql\\nSELECT * \\nFROM CUSTOMER_ORDER\\nWHERE customer = 'U2929'\\n  AND order_date >= '2021-11-01' AND order_date <= '2022-08-31';\\n```\\n\\n- Getting the products purchased by customer 'U2929' in the same date range.\\n\\n```sql\\nSELECT product_id, name, price\\nFROM PRODUCT\\nWHERE product_id IN (SELECT product\\n                     FROM ORDER_ITEM\\n                     WHERE order_id IN (SELECT order_id\\n                                        FROM CUSTOMER_ORDER\\n                                        WHERE customer = 'U2929'\\n                                        AND order_date >= '2021-11-01' \\n                                        AND order_date <= '2022-08-31'));\\n```\\n\\n- Finding the top 10 best-selling products per country.\\n\\n```sql\\nSELECT P.product_id, P.name, S.country, S.total_sales\\nFROM PRODUCT P JOIN (SELECT I.product prod, U.country, SUM(I.quantity) total_sales\\n                     FROM CUSTOMER_ORDER O JOIN CUSTOMER U ON O.customer = U.customer_id\\n                                   JOIN ORDER_ITEM I ON O.order_id = I.order_id\\n                     GROUP BY I.product, U.country) S\\n               ON P.product_id = S.prod\\nORDER BY S.country, S.total_sales DESC\\nLIMIT 10;\\n```\\n\\n- Identifying customers whose direct or indirect referrals have rated the store poorly (1 or 2 stars).\\n\\n```sql\\nSELECT recommendedby \\nFROM CUSTOMER\\nWHERE shop_opinion < 3;\\n```\\n\\n- Listing direct and indirect recommendations of a customer.\\n\\n```sql\\nSELECT customer_id, name, country\\nFROM CUSTOMER\\nWHERE recommendedby = 'U2929';\\n```\\n\\n- Retrieving products similar to those bought in the latest order of a customer.\\n\\n```sql\\nSELECT product2\\nFROM SIMILAR_PRODUCT\\nWHERE product1 IN (SELECT product\\n                   FROM ORDER_ITEM\\n                   WHERE order_id IN (SELECT order_id\\n                                      FROM CUSTOMER_ORDER O1\\n                                      WHERE customer = 'U2929' \\n                                      AND order_date = (SELECT MAX(order_date) \\n                                                        FROM CUSTOMER_ORDER \\n                                                        WHERE O2.customer = O1.customer)));\\n```\\n\",\r\n  \"applicationArchitecture\": \"The application is a monolithic web application with a backend in Java using Spring Boot.\",\r\n  \"underlyingTechnologies\": \"The backend is developed in Java and Spring Boot, with PostgreSQL as the target database.\",\r\n  \"databaseSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\r\n  \"migrationRequirements\": \"Ensure compatibility between MySQL and PostgreSQL data types.\\nConvert `AUTO_INCREMENT` fields to `SERIAL` in PostgreSQL.\\nReplace `DATETIME` with `TIMESTAMP` where needed.\\nModify `BOOLEAN` fields to ensure PostgreSQL compatibility (`TRUE`/`FALSE`).\\nEnsure foreign keys maintain referential integrity.\\nMigrate queries:\\n  - Convert `LIMIT 10` queries into appropriate window functions when necessary.\\n  - Adapt JOIN conditions and subqueries to PostgreSQL-specific syntax.\\n  - Convert the `shop_opinion` field's check constraints to PostgreSQL syntax.\\n  - Ensure that recursive queries (such as recommendations) are handled efficiently.\\nImport data ensuring sequence values match expected IDs to prevent conflicts in SERIAL fields.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sun, 02 Mar 2025 22:09:56 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea las tablas necesarias en PostgreSQL, adaptando los tipos de datos de MySQL a PostgreSQL según las especificaciones proporcionadas. Los campos que utilizan 'AUTO_INCREMENT' en MySQL se han convertido a 'SERIAL' en PostgreSQL. Las fechas se han ajustado para utilizar 'TIMESTAMP' donde sea necesario. Los campos booleanos se han mantenido en su formato compatible. Las claves foráneas se han definido para mantener la integridad referencial. Se han agregado las restricciones de verificación necesarias para los campos, garantizando que se cumplan las condiciones especificadas. Además, se han preparado las tablas para facilitar la migración de datos, asegurando que las secuencias coincidan con los ID esperados para evitar conflictos en los campos SERIAL.\",\n    \"guidelinesForValidateSchema\": \"A continuación se presentan pautas y recomendaciones detalladas para validar manualmente la transformación del esquema desde MySQL a PostgreSQL y asegurar la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### 1. Verificación de la Transformación del Esquema\\n\\n#### Pasos de Verificación:\\n- **Estructura de Tablas:**\\n  - Asegúrate de que todas las tablas definidas en el script de PostgreSQL han sido creadas correctamente.\\n  - Verifica que los tipos de datos sean compatibles y estén correctamente definidos:\\n    - `CHAR` y `VARCHAR` deben estar correctamente asignados.\\n    - `BOOLEAN` debe estar presente y utilizar `TRUE`/`FALSE`.\\n    - `SERIAL` debe ser utilizado para las columnas que eran `AUTO_INCREMENT` en MySQL.\\n    - `TIMESTAMP` debe ser utilizado en lugar de `DATETIME`.\\n\\n- **Relaciones y Claves Foráneas:**\\n  - Verifica que todas las claves primarias y foráneas estén correctamente definidas.\\n  - Asegúrate de que las relaciones entre las tablas se mantengan y que las claves foráneas referencien correctamente las claves primarias de las tablas correspondientes.\\n\\n- **Restricciones de Integridad:**\\n  - Revisa que todas las restricciones de verificación (`CHECK`) estén presentes y sean correctas.\\n  - Verifica que las restricciones de unicidad estén aplicadas donde sea necesario (por ejemplo, en el campo `email` de la tabla `CUSTOMER`).\\n\\n#### Sugerencias de Pruebas Manuales:\\n- Ejecuta el siguiente comando para listar todas las tablas en la base de datos:\\n  ```sql\\n  \\\\dt\\n  ```\\n- Revisa la estructura de cada tabla utilizando:\\n  ```sql\\n  \\\\d CUSTOMER\\n  \\\\d CUSTOMER_PAYMENT_METHOD\\n  \\\\d PRODUCT_CATEGORY\\n  \\\\d PRODUCT\\n  \\\\d SIMILAR_PRODUCT\\n  \\\\d CUSTOMER_ORDER\\n  \\\\d ORDER_ITEM\\n  \\\\d DISCOUNT\\n  \\\\d ORDER_DISCOUNT\\n  ```\\n- Comprueba que las restricciones y claves foráneas estén presentes usando:\\n  ```sql\\n  SELECT conname, conrelid::regclass AS table_name\\n  FROM pg_constraint\\n  WHERE conrelid IN (SELECT oid FROM pg_class WHERE relname IN ('CUSTOMER', 'CUSTOMER_PAYMENT_METHOD', 'PRODUCT_CATEGORY', 'PRODUCT', 'SIMILAR_PRODUCT', 'CUSTOMER_ORDER', 'ORDER_ITEM', 'DISCOUNT', 'ORDER_DISCOUNT'));\\n  ```\\n\\n### 2. Verificación de la Integridad Referencial\\n\\n#### Pasos de Verificación:\\n- **Validar Claves Foráneas:**\\n  - Realiza consultas para verificar que no existan registros en las tablas que refieran a claves primarias inexistentes.\\n  - Por ejemplo, verifica que todos los `customer_id` en `CUSTOMER_PAYMENT_METHOD` existan en `CUSTOMER`:\\n  ```sql\\n  SELECT DISTINCT customer\\n  FROM CUSTOMER_PAYMENT_METHOD\\n  WHERE customer NOT IN (SELECT customer_id FROM CUSTOMER);\\n  ```\\n\\n- **Validar Datos en Tablas:**\\n  - Comprueba que no existan registros huérfanos en las tablas que dependen de otras. Por ejemplo:\\n  ```sql\\n  SELECT DISTINCT evento_id\\n  FROM ORDER_ITEM\\n  WHERE order_id NOT IN (SELECT order_id FROM CUSTOMER_ORDER);\\n  ```\\n\\n### 3. Optimización del Esquema\\n\\n#### Puntos de Control para la Optimización:\\n- **Indexación:**\\n  - Asegúrate de que los índices estén creados en las columnas que se utilizan con frecuencia en las consultas, especialmente en claves foráneas y en campos que se utilizan en las cláusulas `WHERE`.\\n  ```sql\\n  CREATE INDEX idx_customer_email ON CUSTOMER(email);\\n  CREATE INDEX idx_product_category ON PRODUCT(category);\\n  ```\\n\\n- **Estructura de Tablas:**\\n  - Considera si algunas tablas pueden beneficiarse de la normalización o desnormalización, dependiendo de los patrones de acceso a los datos.\\n  - Verifica si algunas tablas podrían ser combinadas si se utilizan frecuentemente juntas.\\n\\n### 4. Validación de Consultas Comunes\\n\\n#### Pasos de Verificación:\\n- **Pruebas de Consultas:**\\n  - Ejecuta las consultas más comunes que se espera que se realicen en la aplicación y verifica que los resultados sean correctos.\\n  - Por ejemplo, prueba la consulta para listar productos en una categoría específica:\\n  ```sql\\n  SELECT product_id, name, price, stock\\n  FROM PRODUCT\\n  WHERE category = 'Laptop' AND price < 1500;\\n  ```\\n\\n- **Pruebas de Integración:**\\n  - Realiza pruebas de inserción, actualización y eliminación en las tablas y verifica que se mantenga la integridad referencial.\\n  - Asegúrate de que las operaciones en cascada funcionen correctamente para las claves foráneas.\\n\\n### 5. Resumen de Recomendaciones para Pruebas Manuales\\n\\n- Revisa la estructura de cada tabla y verifica que coincida con el esquema esperado.\\n- Realiza consultas para verificar la integridad referencial y que no existan registros huérfanos.\\n- Ejecuta las consultas comunes y verifica que los resultados sean correctos.\\n- Asegúrate de que las optimizaciones, como índices, estén presentes y sean efectivas.\\n- Mantén un registro de cualquier inconsistencia o problema encontrado durante la validación y toma medidas correctivas.\\n\\nSiguiendo estas pautas, podrás validar la migración del esquema de MySQL a PostgreSQL de manera efectiva y asegurar que la base de datos de destino esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"COPY CUSTOMER (customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date) FROM '/path/to/customer_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY CUSTOMER_PAYMENT_METHOD (customer, payment_method) FROM '/path/to/customer_payment_method_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY PRODUCT_CATEGORY (category_id, description) FROM '/path/to/product_category_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY PRODUCT (product_id, name, price, description, imageURL, manufacturer, stock, category) FROM '/path/to/product_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY SIMILAR_PRODUCT (product1, product2) FROM '/path/to/similar_product_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY CUSTOMER_ORDER (order_id, order_date, customer, total) FROM '/path/to/customer_order_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY ORDER_ITEM (order_id, item, product, quantity, subtotal) FROM '/path/to/order_item_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY DISCOUNT (discount_id, description, discount_rate) FROM '/path/to/discount_data.csv' DELIMITER ',' CSV HEADER;\\n\\nCOPY ORDER_DISCOUNT (order_id, discount) FROM '/path/to/order_discount_data.csv' DELIMITER ',' CSV HEADER;\",\n    \"metadataForDataMigration\": \"El script utiliza el comando COPY de PostgreSQL para importar datos desde archivos CSV a las tablas correspondientes. Cada tabla tiene su propia línea de COPY que especifica el nombre de la tabla y los campos que se van a llenar. Se asume que los datos han sido exportados a archivos CSV desde la base de datos MySQL. El delimitador se establece como ',' y se incluye la opción CSV HEADER para indicar que la primera fila del archivo contiene los nombres de las columnas. Es importante que los archivos CSV estén ubicados en la ruta especificada y que los datos sean compatibles con las restricciones y tipos de datos definidos en el esquema de PostgreSQL.\",\n    \"scriptForDataValidation\": \"const eventosMigrados = db.CUSTOMER.find().toArray();\\nconst metodosPagoMigrados = db.CUSTOMER_PAYMENT_METHOD.find().toArray();\\nconst categoriasProductoMigrados = db.PRODUCT_CATEGORY.find().toArray();\\nconst productosMigrados = db.PRODUCT.find().toArray();\\nconst productosSimilaresMigrados = db.SIMILAR_PRODUCT.find().toArray();\\nconst pedidosMigrados = db.CUSTOMER_ORDER.find().toArray();\\nconst itemsPedidoMigrados = db.ORDER_ITEM.find().toArray();\\nconst descuentosMigrados = db.DISCOUNT.find().toArray();\\nconst descuentosPedidoMigrados = db.ORDER_DISCOUNT.find().toArray();\\n\\n// Validación de CUSTOMER\\nconst clientesValidos = eventosMigrados.every(cliente => {\\n  return cliente.customer_id &&\\n         typeof cliente.name === 'string' &&\\n         typeof cliente.email === 'string' &&\\n         typeof cliente.password === 'string' &&\\n         typeof cliente.country === 'string' &&\\n         cliente.register_date instanceof Date &&\\n         (cliente.shop_opinion >= 1 && cliente.shop_opinion <= 5) &&\\n         typeof cliente.ispremium === 'boolean';\\n});\\n\\nif (!clientesValidos) {\\n  print('Error: Uno o más registros en CUSTOMER no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en CUSTOMER son válidos.');\\n}\\n\\n// Validación de CUSTOMER_PAYMENT_METHOD\\nconst metodosPagoValidos = metodosPagoMigrados.every(metodo => {\\n  return metodo.customer &&\\n         ['VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL'].includes(metodo.payment_method);\\n});\\n\\nif (!metodosPagoValidos) {\\n  print('Error: Uno o más registros en CUSTOMER_PAYMENT_METHOD no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en CUSTOMER_PAYMENT_METHOD son válidos.');\\n}\\n\\n// Validación de PRODUCT_CATEGORY\\nconst categoriasValidas = categoriasProductoMigrados.every(categoria => {\\n  return categoria.category_id && typeof categoria.description === 'string';\\n});\\n\\nif (!categoriasValidas) {\\n  print('Error: Uno o más registros en PRODUCT_CATEGORY no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en PRODUCT_CATEGORY son válidos.');\\n}\\n\\n// Validación de PRODUCT\\nconst productosValidos = productosMigrados.every(producto => {\\n  return producto.product_id &&\\n         typeof producto.name === 'string' &&\\n         producto.price > 0 &&\\n         typeof producto.manufacturer === 'string' &&\\n         producto.stock >= 0;\\n});\\n\\nif (!productosValidos) {\\n  print('Error: Uno o más registros en PRODUCT no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en PRODUCT son válidos.');\\n}\\n\\n// Validación de SIMILAR_PRODUCT\\nconst productosSimilaresValidos = productosSimilaresMigrados.every(similar => {\\n  return similar.product1 && similar.product2;\\n});\\n\\nif (!productosSimilaresValidos) {\\n  print('Error: Uno o más registros en SIMILAR_PRODUCT no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en SIMILAR_PRODUCT son válidos.');\\n}\\n\\n// Validación de CUSTOMER_ORDER\\nconst pedidosValidos = pedidosMigrados.every(pedido => {\\n  return pedido.order_id &&\\n         pedido.customer &&\\n         pedido.total >= 0;\\n});\\n\\nif (!pedidosValidos) {\\n  print('Error: Uno o más registros en CUSTOMER_ORDER no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en CUSTOMER_ORDER son válidos.');\\n}\\n\\n// Validación de ORDER_ITEM\\nconst itemsPedidoValidos = itemsPedidoMigrados.every(item => {\\n  return item.order_id &&\\n         item.quantity > 0 &&\\n         item.subtotal >= 0;\\n});\\n\\nif (!itemsPedidoValidos) {\\n  print('Error: Uno o más registros en ORDER_ITEM no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en ORDER_ITEM son válidos.');\\n}\\n\\n// Validación de DISCOUNT\\nconst descuentosValidos = descuentosMigrados.every(descuento => {\\n  return descuento.discount_id &&\\n         descuento.discount_rate > 0;\\n});\\n\\nif (!descuentosValidos) {\\n  print('Error: Uno o más registros en DISCOUNT no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en DISCOUNT son válidos.');\\n}\\n\\n// Validación de ORDER_DISCOUNT\\nconst descuentosPedidoValidos = descuentosPedidoMigrados.every(descuento => {\\n  return descuento.order_id &&\\n         descuento.discount;\\n});\\n\\nif (!descuentosPedidoValidos) {\\n  print('Error: Uno o más registros en ORDER_DISCOUNT no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en ORDER_DISCOUNT son válidos.');\\n}\\n\\n// Contar registros migrados\\nprint('Total de registros migrados:');\\nprint('CUSTOMER: ' + eventosMigrados.length);\\nprint('CUSTOMER_PAYMENT_METHOD: ' + metodosPagoMigrados.length);\\nprint('PRODUCT_CATEGORY: ' + categoriasProductoMigrados.length);\\nprint('PRODUCT: ' + productosMigrados.length);\\nprint('SIMILAR_PRODUCT: ' + productosSimilaresMigrados.length);\\nprint('CUSTOMER_ORDER: ' + pedidosMigrados.length);\\nprint('ORDER_ITEM: ' + itemsPedidoMigrados.length);\\nprint('DISCOUNT: ' + descuentosMigrados.length);\\nprint('ORDER_DISCOUNT: ' + descuentosPedidoMigrados.length);\",\n    \"metadataForDataValidation\": \"El script comienza recuperando todos los documentos de las colecciones en PostgreSQL. Luego, valida que cada colección cumpla con los requisitos del esquema esperado, verificando que los campos requeridos estén presentes y que sus tipos de datos sean correctos. Se realizan verificaciones específicas para asegurar que las restricciones y condiciones (como las restricciones de unicidad y los valores permitidos) se cumplan. Si se encuentra algún error, se imprime un mensaje de error; de lo contrario, se confirma que todos los registros son válidos. Finalmente, se imprime el total de registros migrados para cada colección.\"\n}"
        },
        {
          "name": "metashop-2",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"The application is an e-commerce platform that allows customers to browse products, place orders, and manage their payments.\\nThe most frequent queries in the system include:\\n\\n- Listing (ID, name, price, stock) of 'Laptop' category products priced under 1500€ and manufactured by 'LG'.\\n\\n```sql\\nSELECT product_id, name, price, stock\\nFROM PRODUCT\\nWHERE category IN (SELECT category_id\\n                   FROM PRODUCT_CATEGORY\\n                   WHERE name = 'Laptop')\\n  AND price < 1500 and manufacturer = 'LG';\\n```\\n\\n- Retrieving orders placed by customer 'U2929' between 2021-11-01 and 2022-08-31.\\n\\n```sql\\nSELECT * \\nFROM CUSTOMER_ORDER\\nWHERE customer = 'U2929'\\n  AND order_date >= '2021-11-01' AND order_date <= '2022-08-31';\\n```\\n\\n- Getting the products purchased by customer 'U2929' in the same date range.\\n\\n```sql\\nSELECT product_id, name, price\\nFROM PRODUCT\\nWHERE product_id IN (SELECT product\\n                     FROM ORDER_ITEM\\n                     WHERE order_id IN (SELECT order_id\\n                                        FROM CUSTOMER_ORDER\\n                                        WHERE customer = 'U2929'\\n                                        AND order_date >= '2021-11-01' \\n                                        AND order_date <= '2022-08-31'));\\n```\\n\\n- Finding the top 10 best-selling products per country.\\n\\n```sql\\nSELECT P.product_id, P.name, S.country, S.total_sales\\nFROM PRODUCT P JOIN (SELECT I.product prod, U.country, SUM(I.quantity) total_sales\\n                     FROM CUSTOMER_ORDER O JOIN CUSTOMER U ON O.customer = U.customer_id\\n                                   JOIN ORDER_ITEM I ON O.order_id = I.order_id\\n                     GROUP BY I.product, U.country) S\\n               ON P.product_id = S.prod\\nORDER BY S.country, S.total_sales DESC\\nLIMIT 10;\\n```\\n\\n- Identifying customers whose direct or indirect referrals have rated the store poorly (1 or 2 stars).\\n\\n```sql\\nSELECT recommendedby \\nFROM CUSTOMER\\nWHERE shop_opinion < 3;\\n```\\n\\n- Listing direct and indirect recommendations of a customer.\\n\\n```sql\\nSELECT customer_id, name, country\\nFROM CUSTOMER\\nWHERE recommendedby = 'U2929';\\n```\\n\\n- Retrieving products similar to those bought in the latest order of a customer.\\n\\n```sql\\nSELECT product2\\nFROM SIMILAR_PRODUCT\\nWHERE product1 IN (SELECT product\\n                   FROM ORDER_ITEM\\n                   WHERE order_id IN (SELECT order_id\\n                                      FROM CUSTOMER_ORDER O1\\n                                      WHERE customer = 'U2929' \\n                                      AND order_date = (SELECT MAX(order_date) \\n                                                        FROM CUSTOMER_ORDER \\n                                                        WHERE O2.customer = O1.customer)));\\n```\\n\",\r\n  \"applicationArchitecture\": \"The application is a monolithic web application with a backend in Java using Spring Boot.\",\r\n  \"underlyingTechnologies\": \"The backend is developed in Java and Spring Boot, with PostgreSQL as the target database.\",\r\n  \"databaseSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\r\n  \"migrationRequirements\": \"Ensure compatibility between MySQL and PostgreSQL data types.\\nConvert `AUTO_INCREMENT` fields to `SERIAL` in PostgreSQL.\\nReplace `DATETIME` with `TIMESTAMP` where needed.\\nModify `BOOLEAN` fields to ensure PostgreSQL compatibility (`TRUE`/`FALSE`).\\nEnsure foreign keys maintain referential integrity.\\nMigrate queries:\\n  - Convert `LIMIT 10` queries into appropriate window functions when necessary.\\n  - Adapt JOIN conditions and subqueries to PostgreSQL-specific syntax.\\n  - Convert the `shop_opinion` field's check constraints to PostgreSQL syntax.\\n  - Ensure that recursive queries (such as recommendations) are handled efficiently.\\nImport data ensuring sequence values match expected IDs to prevent conflicts in SERIAL fields.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:28:49 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea las tablas necesarias en PostgreSQL a partir del esquema de MySQL, realizando las adaptaciones requeridas para asegurar la compatibilidad. Se mantienen las restricciones de claves primarias y foráneas, se utilizan tipos de datos apropiados como SERIAL para campos de auto-incremento y TIMESTAMP para fechas. Las restricciones de CHECK se implementan de manera que respeten la sintaxis de PostgreSQL. Se asegura que los campos booleanos se manejen correctamente y se definen las relaciones necesarias entre las tablas para mantener la integridad referencial.\",\n    \"guidelinesForValidateSchema\": \"Aquí tienes un conjunto de pautas y recomendaciones detalladas para validar manualmente la migración del esquema desde MySQL a PostgreSQL, así como la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### Pautas para la Verificación de la Migración del Esquema\\n\\n#### 1. Verificación de la Estructura de las Tablas\\n\\n- **Paso 1:** Conéctate a la base de datos PostgreSQL utilizando una herramienta como pgAdmin, DBeaver o la línea de comandos de PostgreSQL.\\n\\n- **Paso 2:** Verifica que todas las tablas han sido creadas correctamente.\\n  ```sql\\n  \\\\dt\\n  ```\\n\\n- **Paso 3:** Inspecciona la estructura de cada tabla utilizando:\\n  ```sql\\n  \\\\d CUSTOMER\\n  \\\\d CUSTOMER_PAYMENT_METHOD\\n  \\\\d PRODUCT_CATEGORY\\n  \\\\d PRODUCT\\n  \\\\d SIMILAR_PRODUCT\\n  \\\\d CUSTOMER_ORDER\\n  \\\\d ORDER_ITEM\\n  \\\\d DISCOUNT\\n  \\\\d ORDER_DISCOUNT\\n  ```\\n\\n  - **Punto de Control:** Asegúrate de que cada tabla contenga los campos correctos, tipos de datos apropiados y restricciones definidas.\\n\\n#### 2. Verificación de las Restricciones\\n\\n- **Paso 4:** Verifica que las claves primarias y foráneas están definidas correctamente.\\n  - Para claves primarias:\\n    ```sql\\n    SELECT * FROM information_schema.table_constraints \\n    WHERE table_name = 'CUSTOMER' AND constraint_type = 'PRIMARY KEY';\\n    ```\\n\\n  - Para claves foráneas:\\n    ```sql\\n    SELECT * FROM information_schema.table_constraints \\n    WHERE table_name = 'CUSTOMER_PAYMENT_METHOD' AND constraint_type = 'FOREIGN KEY';\\n    ```\\n\\n  - **Punto de Control:** Asegúrate de que todas las relaciones de claves foráneas están correctamente establecidas y apuntan a las tablas correspondientes.\\n\\n#### 3. Validación de los Tipos de Datos\\n\\n- **Paso 5:** Asegúrate de que los tipos de datos utilizados en PostgreSQL son compatibles con los de MySQL y que se han convertido correctamente.\\n  - Verifica que los campos de tipo `BOOLEAN` sean representados como `TRUE`/`FALSE`.\\n  - Verifica que los campos `SERIAL` estén definidos correctamente para los IDs autoincrementales.\\n\\n#### 4. Pruebas de Consultas\\n\\n- **Paso 6:** Ejecuta algunas consultas comunes que se usarán en la aplicación para asegurarte de que el esquema se comporta como se espera. Por ejemplo:\\n  \\n  - Listar todos los clientes:\\n    ```sql\\n    SELECT * FROM CUSTOMER;\\n    ```\\n\\n  - Obtener el total de órdenes por cliente:\\n    ```sql\\n    SELECT customer, COUNT(*) as total_orders \\n    FROM CUSTOMER_ORDER \\n    GROUP BY customer;\\n    ```\\n\\n  - Comprobar los productos en una categoría específica:\\n    ```sql\\n    SELECT * FROM PRODUCT WHERE category = 'some_category';\\n    ```\\n\\n  - **Punto de Control:** Asegúrate de que las consultas devuelven los resultados esperados.\\n\\n#### 5. Optimización del Esquema\\n\\n- **Paso 7:** Revisa el uso de índices. Asegúrate de que se han creado índices en los campos que se utilizan frecuentemente en consultas, especialmente en claves foráneas.\\n\\n  - Crear un índice en `customer_id` en la tabla `CUSTOMER_PAYMENT_METHOD` si no existe:\\n    ```sql\\n    CREATE INDEX idx_customer_id ON CUSTOMER_PAYMENT_METHOD(customer);\\n    ```\\n\\n- **Paso 8:** Revisa las restricciones de `CHECK` y asegúrate de que se aplican correctamente. Por ejemplo, verifica que las restricciones de `shop_opinion` y `price` están funcionando.\\n\\n#### 6. Mantenimiento de la Integridad Referencial\\n\\n- **Paso 9:** Realiza pruebas manuales para asegurarte de que las restricciones de integridad referencial funcionan como se espera. Por ejemplo, intenta insertar un registro en `CUSTOMER_PAYMENT_METHOD` con un `customer_id` que no existe en `CUSTOMER` y verifica que se produce un error.\\n\\n### Conclusión\\n\\nSiguiendo estas pautas, podrás validar que la migración del esquema desde MySQL a PostgreSQL se ha realizado correctamente y que el nuevo esquema está optimizado para las consultas y el rendimiento. Recuerda documentar cualquier inconsistencia o error encontrado durante el proceso para su posterior corrección.\",\n    \"scriptForDataMigration\": \"import mysql.connector\\nfrom psycopg2 import connect, sql\\n\\n# Conexiones a las bases de datos\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_mysql_user',\\n    password='your_mysql_password',\\n    database='eventos_db'\\n)\\n\\npg_conn = connect(\\n    dbname='your_pg_database',\\n    user='your_pg_user',\\n    password='your_pg_password',\\n    host='localhost'\\n)\\n\\nmysql_cursor = mysql_conn.cursor(dictionary=True)\\npg_cursor = pg_conn.cursor()\\n\\n# Migrar datos de CUSTOMER\\nmysql_cursor.execute('SELECT * FROM CUSTOMER')\\ncustomers = mysql_cursor.fetchall()\\n\\nfor customer in customers:\\n    pg_cursor.execute(sql.SQL('INSERT INTO CUSTOMER (customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'),\\n                     (customer['customer_id'], customer['name'], customer['email'], customer['password'], customer['shipping_addr'], customer['country'], customer['register_date'], customer['recommendedby'], customer['shop_opinion'], customer['ispremium'], customer['premium_fee'], customer['premium_date']))\\n\\n# Migrar datos de CUSTOMER_PAYMENT_METHOD\\nmysql_cursor.execute('SELECT * FROM CUSTOMER_PAYMENT_METHOD')\\npayment_methods = mysql_cursor.fetchall()\\n\\nfor payment in payment_methods:\\n    pg_cursor.execute(sql.SQL('INSERT INTO CUSTOMER_PAYMENT_METHOD (customer, payment_method) VALUES (%s, %s)'),\\n                     (payment['customer'], payment['payment_method']))\\n\\n# Migrar datos de PRODUCT_CATEGORY\\nmysql_cursor.execute('SELECT * FROM PRODUCT_CATEGORY')\\nproduct_categories = mysql_cursor.fetchall()\\n\\nfor category in product_categories:\\n    pg_cursor.execute(sql.SQL('INSERT INTO PRODUCT_CATEGORY (category_id, description) VALUES (%s, %s)'),\\n                     (category['category_id'], category['description']))\\n\\n# Migrar datos de PRODUCT\\nmysql_cursor.execute('SELECT * FROM PRODUCT')\\nproducts = mysql_cursor.fetchall()\\n\\nfor product in products:\\n    pg_cursor.execute(sql.SQL('INSERT INTO PRODUCT (product_id, name, price, description, imageURL, manufacturer, stock, category) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)'),\\n                     (product['product_id'], product['name'], product['price'], product['description'], product['imageURL'], product['manufacturer'], product['stock'], product['category']))\\n\\n# Migrar datos de SIMILAR_PRODUCT\\nmysql_cursor.execute('SELECT * FROM SIMILAR_PRODUCT')\\nsimilar_products = mysql_cursor.fetchall()\\n\\nfor similar in similar_products:\\n    pg_cursor.execute(sql.SQL('INSERT INTO SIMILAR_PRODUCT (product1, product2) VALUES (%s, %s)'),\\n                     (similar['product1'], similar['product2']))\\n\\n# Migrar datos de CUSTOMER_ORDER\\nmysql_cursor.execute('SELECT * FROM CUSTOMER_ORDER')\\norders = mysql_cursor.fetchall()\\n\\nfor order in orders:\\n    pg_cursor.execute(sql.SQL('INSERT INTO CUSTOMER_ORDER (order_id, order_date, customer, total) VALUES (DEFAULT, %s, %s, %s)'),\\n                     (order['order_date'], order['customer'], order['total']))\\n\\n# Migrar datos de ORDER_ITEM\\nmysql_cursor.execute('SELECT * FROM ORDER_ITEM')\\norder_items = mysql_cursor.fetchall()\\n\\nfor item in order_items:\\n    pg_cursor.execute(sql.SQL('INSERT INTO ORDER_ITEM (order_id, item, product, quantity, subtotal) VALUES (%s, %s, %s, %s, %s)'),\\n                     (item['order_id'], item['item'], item['product'], item['quantity'], item['subtotal']))\\n\\n# Migrar datos de DISCOUNT\\nmysql_cursor.execute('SELECT * FROM DISCOUNT')\\ndiscounts = mysql_cursor.fetchall()\\n\\nfor discount in discounts:\\n    pg_cursor.execute(sql.SQL('INSERT INTO DISCOUNT (discount_id, description, discount_rate) VALUES (DEFAULT, %s, %s)'),\\n                     (discount['description'], discount['discount_rate']))\\n\\n# Migrar datos de ORDER_DISCOUNT\\nmysql_cursor.execute('SELECT * FROM ORDER_DISCOUNT')\\norder_discounts = mysql_cursor.fetchall()\\n\\nfor order_discount in order_discounts:\\n    pg_cursor.execute(sql.SQL('INSERT INTO ORDER_DISCOUNT (order_id, discount) VALUES (%s, %s)'),\\n                     (order_discount['order_id'], order_discount['discount']))\\n\\n# Confirmar cambios y cerrar conexiones\\npg_conn.commit()\\nmysql_cursor.close()\\npg_cursor.close()\\nmysql_conn.close()\\npg_conn.close()\",\n    \"metadataForDataMigration\": \"El script establece conexiones a las bases de datos MySQL y PostgreSQL. Luego, se migran los datos de cada tabla de MySQL a PostgreSQL, asegurando que se mantenga la integridad de los datos y se respeten las relaciones de clave foránea. Para las tablas que utilizan campos SERIAL en PostgreSQL, se utiliza 'DEFAULT' al insertar para que PostgreSQL maneje automáticamente la generación de IDs. Finalmente, se confirman los cambios y se cierran las conexiones a ambas bases de datos.\",\n    \"scriptForDataValidation\": \"import mysql.connector\\nfrom psycopg2 import connect\\n\\n# Conexiones a las bases de datos\\nmysql_conn = mysql.connector.connect(\\n    host='localhost',\\n    user='your_mysql_user',\\n    password='your_mysql_password',\\n    database='eventos_db'\\n)\\n\\npg_conn = connect(\\n    dbname='your_pg_database',\\n    user='your_pg_user',\\n    password='your_pg_password',\\n    host='localhost'\\n)\\n\\nmysql_cursor = mysql_conn.cursor(dictionary=True)\\npg_cursor = pg_conn.cursor()\\n\\n# Validar datos de CUSTOMER\\nmysql_cursor.execute('SELECT * FROM CUSTOMER')\\nmysql_customers = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM CUSTOMER')\\npg_customers = pg_cursor.fetchall()\\n\\n# Verificar conteo de clientes\\nif len(mysql_customers) != len(pg_customers):\\n    print(f'Error: Número de clientes no coincide. MySQL: {len(mysql_customers)}, PostgreSQL: {len(pg_customers)}')\\nelse:\\n    print('Número de clientes coincide.')\\n\\n# Verificar contenido de clientes\\nfor customer in mysql_customers:\\n    pg_customer = next((c for c in pg_customers if c['customer_id'] == customer['customer_id']), None)\\n    if pg_customer:\\n        if pg_customer['name'] != customer['name']:\\n            print(f'Error: Nombre no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['email'] != customer['email']:\\n            print(f'Error: Email no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['shipping_addr'] != customer['shipping_addr']:\\n            print(f'Error: Dirección de envío no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['country'] != customer['country']:\\n            print(f'Error: País no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['register_date'] != customer['register_date']:\\n            print(f'Error: Fecha de registro no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['recommendedby'] != customer['recommendedby']:\\n            print(f'Error: Recomendado por no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['shop_opinion'] != customer['shop_opinion']:\\n            print(f'Error: Opinión de tienda no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['ispremium'] != customer['ispremium']:\\n            print(f'Error: Estado premium no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['premium_fee'] != customer['premium_fee']:\\n            print(f'Error: Cuota premium no coincide para el cliente {customer['customer_id']}.')\\n        if pg_customer['premium_date'] != customer['premium_date']:\\n            print(f'Error: Fecha premium no coincide para el cliente {customer['customer_id']}.')\\n    else:\\n        print(f'Error: Cliente {customer['customer_id']} no encontrado en PostgreSQL.')\\n\\n# Validar datos de CUSTOMER_PAYMENT_METHOD\\nmysql_cursor.execute('SELECT * FROM CUSTOMER_PAYMENT_METHOD')\\nmysql_payment_methods = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM CUSTOMER_PAYMENT_METHOD')\\npg_payment_methods = pg_cursor.fetchall()\\n\\n# Verificar conteo de métodos de pago\\nif len(mysql_payment_methods) != len(pg_payment_methods):\\n    print(f'Error: Número de métodos de pago no coincide. MySQL: {len(mysql_payment_methods)}, PostgreSQL: {len(pg_payment_methods)}')\\nelse:\\n    print('Número de métodos de pago coincide.')\\n\\n# Verificar contenido de métodos de pago\\nfor payment in mysql_payment_methods:\\n    pg_payment = next((p for p in pg_payment_methods if p['customer'] == payment['customer'] and p['payment_method'] == payment['payment_method']), None)\\n    if not pg_payment:\\n        print(f'Error: Método de pago para el cliente {payment['customer']} no encontrado en PostgreSQL.')\\n\\n# Validar datos de PRODUCT_CATEGORY\\nmysql_cursor.execute('SELECT * FROM PRODUCT_CATEGORY')\\nmysql_categories = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM PRODUCT_CATEGORY')\\npg_categories = pg_cursor.fetchall()\\n\\n# Verificar conteo de categorías de productos\\nif len(mysql_categories) != len(pg_categories):\\n    print(f'Error: Número de categorías de productos no coincide. MySQL: {len(mysql_categories)}, PostgreSQL: {len(pg_categories)}')\\nelse:\\n    print('Número de categorías de productos coincide.')\\n\\n# Validar datos de PRODUCT\\nmysql_cursor.execute('SELECT * FROM PRODUCT')\\nmysql_products = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM PRODUCT')\\npg_products = pg_cursor.fetchall()\\n\\n# Verificar conteo de productos\\nif len(mysql_products) != len(pg_products):\\n    print(f'Error: Número de productos no coincide. MySQL: {len(mysql_products)}, PostgreSQL: {len(pg_products)}')\\nelse:\\n    print('Número de productos coincide.')\\n\\n# Validar datos de CUSTOMER_ORDER\\nmysql_cursor.execute('SELECT * FROM CUSTOMER_ORDER')\\nmysql_orders = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM CUSTOMER_ORDER')\\npg_orders = pg_cursor.fetchall()\\n\\n# Verificar conteo de órdenes\\nif len(mysql_orders) != len(pg_orders):\\n    print(f'Error: Número de órdenes no coincide. MySQL: {len(mysql_orders)}, PostgreSQL: {len(pg_orders)}')\\nelse:\\n    print('Número de órdenes coincide.')\\n\\n# Validar datos de ORDER_ITEM\\nmysql_cursor.execute('SELECT * FROM ORDER_ITEM')\\nmysql_order_items = mysql_cursor.fetchall()\\npg_cursor.execute('SELECT * FROM ORDER_ITEM')\\npg_order_items = pg_cursor.fetchall()\\n\\n# Verificar conteo de items de orden\\nif len(mysql_order_items) != len(pg_order_items):\\n    print(f'Error: Número de items de orden no coincide. MySQL: {len(mysql_order_items)}, PostgreSQL: {len(pg_order_items)}')\\nelse:\\n    print('Número de items de orden coincide.')\\n\\n# Cerrar conexiones\\nmysql_cursor.close()\\npg_cursor.close()\\nmysql_conn.close()\\npg_conn.close()\",\n    \"metadataForDataValidation\": \"El script establece conexiones a las bases de datos MySQL y PostgreSQL. Luego, valida los datos migrados de cada tabla comparando el conteo y el contenido entre ambas bases de datos. Para cada tabla, se verifica que el número de registros coincida y se comparan los valores de cada campo relevante. Se imprimen errores si hay discrepancias encontradas. Finalmente, se cierran las conexiones a ambas bases de datos.\"\n}"
        },
        {
          "name": "metashop-3",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"The application is an e-commerce platform that allows customers to browse products, place orders, and manage their payments.\\nThe most frequent queries in the system include:\\n\\n- Listing (ID, name, price, stock) of 'Laptop' category products priced under 1500€ and manufactured by 'LG'.\\n\\n```sql\\nSELECT product_id, name, price, stock\\nFROM PRODUCT\\nWHERE category IN (SELECT category_id\\n                   FROM PRODUCT_CATEGORY\\n                   WHERE name = 'Laptop')\\n  AND price < 1500 and manufacturer = 'LG';\\n```\\n\\n- Retrieving orders placed by customer 'U2929' between 2021-11-01 and 2022-08-31.\\n\\n```sql\\nSELECT * \\nFROM CUSTOMER_ORDER\\nWHERE customer = 'U2929'\\n  AND order_date >= '2021-11-01' AND order_date <= '2022-08-31';\\n```\\n\\n- Getting the products purchased by customer 'U2929' in the same date range.\\n\\n```sql\\nSELECT product_id, name, price\\nFROM PRODUCT\\nWHERE product_id IN (SELECT product\\n                     FROM ORDER_ITEM\\n                     WHERE order_id IN (SELECT order_id\\n                                        FROM CUSTOMER_ORDER\\n                                        WHERE customer = 'U2929'\\n                                        AND order_date >= '2021-11-01' \\n                                        AND order_date <= '2022-08-31'));\\n```\\n\\n- Finding the top 10 best-selling products per country.\\n\\n```sql\\nSELECT P.product_id, P.name, S.country, S.total_sales\\nFROM PRODUCT P JOIN (SELECT I.product prod, U.country, SUM(I.quantity) total_sales\\n                     FROM CUSTOMER_ORDER O JOIN CUSTOMER U ON O.customer = U.customer_id\\n                                   JOIN ORDER_ITEM I ON O.order_id = I.order_id\\n                     GROUP BY I.product, U.country) S\\n               ON P.product_id = S.prod\\nORDER BY S.country, S.total_sales DESC\\nLIMIT 10;\\n```\\n\\n- Identifying customers whose direct or indirect referrals have rated the store poorly (1 or 2 stars).\\n\\n```sql\\nSELECT recommendedby \\nFROM CUSTOMER\\nWHERE shop_opinion < 3;\\n```\\n\\n- Listing direct and indirect recommendations of a customer.\\n\\n```sql\\nSELECT customer_id, name, country\\nFROM CUSTOMER\\nWHERE recommendedby = 'U2929';\\n```\\n\\n- Retrieving products similar to those bought in the latest order of a customer.\\n\\n```sql\\nSELECT product2\\nFROM SIMILAR_PRODUCT\\nWHERE product1 IN (SELECT product\\n                   FROM ORDER_ITEM\\n                   WHERE order_id IN (SELECT order_id\\n                                      FROM CUSTOMER_ORDER O1\\n                                      WHERE customer = 'U2929' \\n                                      AND order_date = (SELECT MAX(order_date) \\n                                                        FROM CUSTOMER_ORDER \\n                                                        WHERE O2.customer = O1.customer)));\\n```\\n\",\r\n  \"applicationArchitecture\": \"The application is a monolithic web application with a backend in Java using Spring Boot.\",\r\n  \"underlyingTechnologies\": \"The backend is developed in Java and Spring Boot, with PostgreSQL as the target database.\",\r\n  \"databaseSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\r\n  \"migrationRequirements\": \"Ensure compatibility between MySQL and PostgreSQL data types.\\nConvert `AUTO_INCREMENT` fields to `SERIAL` in PostgreSQL.\\nReplace `DATETIME` with `TIMESTAMP` where needed.\\nModify `BOOLEAN` fields to ensure PostgreSQL compatibility (`TRUE`/`FALSE`).\\nEnsure foreign keys maintain referential integrity.\\nMigrate queries:\\n  - Convert `LIMIT 10` queries into appropriate window functions when necessary.\\n  - Adapt JOIN conditions and subqueries to PostgreSQL-specific syntax.\\n  - Convert the `shop_opinion` field's check constraints to PostgreSQL syntax.\\n  - Ensure that recursive queries (such as recommendations) are handled efficiently.\\nImport data ensuring sequence values match expected IDs to prevent conflicts in SERIAL fields.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:55:19 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema de base de datos en PostgreSQL migrando las tablas desde MySQL, asegurando la compatibilidad de tipos de datos y restricciones. Se han mantenido los tipos de datos de PostgreSQL, como SERIAL para campos autoincrementales y TIMESTAMP para fechas y horas. Las restricciones de clave foránea se han mantenido para asegurar la integridad referencial. Las restricciones CHECK han sido adaptadas a la sintaxis de PostgreSQL. Además, se han mantenido las restricciones de unicidad y no nulidad según lo especificado en el esquema original de MySQL.\",\n    \"guidelinesForValidateSchema\": \"### Pautas y Recomendaciones para la Validación de la Migración de Esquema de MySQL a PostgreSQL\\n\\nA continuación, se presentan pasos detallados que el usuario puede seguir para validar manualmente la transformación del esquema desde MySQL a PostgreSQL y asegurar que el nuevo esquema esté correctamente implementado y optimizado.\\n\\n#### 1. Verificación de la Estructura del Esquema\\n\\n**Paso 1: Comparar la Estructura de las Tablas**\\n- Utilizar herramientas de administración de bases de datos como `pgAdmin` o `DBeaver` para visualizar la estructura de las tablas en la base de datos PostgreSQL.\\n- Comparar cada tabla del esquema original de MySQL con el esquema de PostgreSQL:\\n  - **Nombres de Tablas y Columnas**: Asegurarse de que los nombres sean idénticos.\\n  - **Tipos de Datos**: Verificar que los tipos de datos sean compatibles y correctos (ej. `CHAR`, `VARCHAR`, `DECIMAL`, `BOOLEAN`, `TIMESTAMP`).\\n  - **Restricciones**: Comprobar que las restricciones como `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, y `CHECK` estén presentes y correctamente definidas.\\n\\n**Paso 2: Validar las Claves Foráneas**\\n- Realizar consultas en la base de datos PostgreSQL para asegurarse de que las claves foráneas están establecidas correctamente. Por ejemplo:\\n  ```sql\\n  SELECT conname, confdeltype, confupdtype\\n  FROM pg_constraint\\n  WHERE conrelid = 'CUSTOMER'::regclass AND contype = 'f';\\n  ```\\n- Comprobar que las relaciones de referencia entre las tablas sean correctas y que no existan violaciones de integridad referencial.\\n\\n#### 2. Verificación de Datos\\n\\n**Paso 3: Validar la Migración de Datos**\\n- Si es posible, realizar una comparación de conteos de filas entre las tablas de origen y destino:\\n  ```sql\\n  SELECT COUNT(*) FROM CUSTOMER; -- Para MySQL\\n  SELECT COUNT(*) FROM CUSTOMER; -- Para PostgreSQL\\n  ```\\n- Verificar algunos registros aleatorios de cada tabla para asegurarse de que los datos se han migrado correctamente.\\n- Comprobar que los valores de las columnas que tienen restricciones (ej. `CHECK`, `UNIQUE`) no violen estas restricciones.\\n\\n#### 3. Optimización del Esquema\\n\\n**Paso 4: Evaluar Índices y Rendimiento**\\n- Revisar los índices en las tablas de PostgreSQL y asegurarse de que se han creado índices adecuados para mejorar el rendimiento de las consultas.\\n- Realizar análisis de rendimiento utilizando `EXPLAIN` para consultas comunes para identificar posibles cuellos de botella.\\n\\n**Paso 5: Pruebas de Consultas Frecuentes**\\n- Ejecutar las consultas más comunes en el nuevo esquema para asegurarse de que se comportan como se espera. Las consultas incluyen:\\n  - Listar productos de una categoría específica.\\n  - Recuperar pedidos de un cliente en un rango de fechas.\\n  - Obtener productos comprados por un cliente.\\n  - Identificar clientes con opiniones bajas.\\n- Comparar los tiempos de ejecución de las consultas entre MySQL y PostgreSQL para detectar diferencias significativas.\\n\\n#### 4. Pruebas de Funcionalidad\\n\\n**Paso 6: Probar Funcionalidades de la Aplicación**\\n- Si hay una aplicación que interactúa con la base de datos, realizar pruebas funcionales para garantizar que todas las características y funcionalidades funcionan como se espera.\\n- Asegurarse de que las operaciones de inserción, actualización y eliminación funcionan correctamente y que las restricciones se aplican.\\n\\n#### 5. Verificación de Secuencias y AUTO_INCREMENT\\n\\n**Paso 7: Comprobar Secuencias para SERIAL**\\n- Verificar que las secuencias para las columnas `SERIAL` se hayan creado correctamente y que estén en la configuración adecuada.\\n- Asegurarse de que los valores de las secuencias no causen conflictos con los ID existentes.\\n- Comprobar el valor de la secuencia:\\n  ```sql\\n  SELECT last_value FROM your_sequence_name;\\n  ```\\n\\n#### 6. Documentación y Reportes\\n\\n**Paso 8: Documentar Resultados**\\n- Documentar todos los resultados de las pruebas de validación, incluyendo cualquier discrepancia encontrada y cómo se resolvió.\\n- Mantener un registro de las consultas de rendimiento y cualquier ajuste realizado en el esquema.\\n\\n### Conclusión\\nSiguiendo estos pasos y recomendaciones, el usuario podrá validar de manera efectiva la migración del esquema de MySQL a PostgreSQL, asegurando que la nueva base de datos esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"-- Migración de datos desde MySQL a PostgreSQL\\n\\n-- 1. Insertar datos en la tabla CUSTOMER\\nINSERT INTO CUSTOMER (customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date)\\nSELECT customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date\\nFROM mysql_database.CUSTOMER;\\n\\n-- 2. Insertar datos en la tabla CUSTOMER_PAYMENT_METHOD\\nINSERT INTO CUSTOMER_PAYMENT_METHOD (customer, payment_method)\\nSELECT customer, payment_method\\nFROM mysql_database.CUSTOMER_PAYMENT_METHOD;\\n\\n-- 3. Insertar datos en la tabla PRODUCT_CATEGORY\\nINSERT INTO PRODUCT_CATEGORY (category_id, description)\\nSELECT category_id, description\\nFROM mysql_database.PRODUCT_CATEGORY;\\n\\n-- 4. Insertar datos en la tabla PRODUCT\\nINSERT INTO PRODUCT (product_id, name, price, description, imageURL, manufacturer, stock, category)\\nSELECT product_id, name, price, description, imageURL, manufacturer, stock, category\\nFROM mysql_database.PRODUCT;\\n\\n-- 5. Insertar datos en la tabla SIMILAR_PRODUCT\\nINSERT INTO SIMILAR_PRODUCT (product1, product2)\\nSELECT product1, product2\\nFROM mysql_database.SIMILAR_PRODUCT;\\n\\n-- 6. Insertar datos en la tabla CUSTOMER_ORDER\\nINSERT INTO CUSTOMER_ORDER (order_id, order_date, customer, total)\\nSELECT DEFAULT, order_date, customer, total\\nFROM mysql_database.CUSTOMER_ORDER;\\n\\n-- 7. Insertar datos en la tabla ORDER_ITEM\\nINSERT INTO ORDER_ITEM (order_id, item, product, quantity, subtotal)\\nSELECT order_id, item, product, quantity, subtotal\\nFROM mysql_database.ORDER_ITEM;\\n\\n-- 8. Insertar datos en la tabla DISCOUNT\\nINSERT INTO DISCOUNT (discount_id, description, discount_rate)\\nSELECT DEFAULT, description, discount_rate\\nFROM mysql_database.DISCOUNT;\\n\\n-- 9. Insertar datos en la tabla ORDER_DISCOUNT\\nINSERT INTO ORDER_DISCOUNT (order_id, discount)\\nSELECT order_id, discount\\nFROM mysql_database.ORDER_DISCOUNT;\",\n    \"metadataForDataMigration\": \"El script de migración de datos está diseñado para transferir datos desde una base de datos MySQL a PostgreSQL. Cada sección del script realiza una inserción de datos desde las tablas de MySQL a las tablas correspondientes en PostgreSQL. Se asegura de que los campos que son SERIAL en PostgreSQL se manejen correctamente al usar DEFAULT para el campo 'order_id' y 'discount_id', lo que permite que PostgreSQL genere automáticamente los valores. Este enfoque mantiene la integridad referencial y asegura que los datos se transfieran de manera eficiente y precisa, respetando las restricciones de cada tabla.\",\n    \"scriptForDataValidation\": \"-- Validación de la migración de datos y esquema de MySQL a PostgreSQL\\n\\n-- 1. Verificar la existencia de tablas en PostgreSQL\\nSELECT table_name \\nFROM information_schema.tables \\nWHERE table_schema = 'public';\\n\\n-- 2. Comparar la estructura de las tablas\\n-- Para cada tabla, verificar columnas y tipos de datos\\n\\n-- Tabla CUSTOMER\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'customer';\\n\\n-- Tabla CUSTOMER_PAYMENT_METHOD\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'customer_payment_method';\\n\\n-- Tabla PRODUCT_CATEGORY\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'product_category';\\n\\n-- Tabla PRODUCT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'product';\\n\\n-- Tabla SIMILAR_PRODUCT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'similar_product';\\n\\n-- Tabla CUSTOMER_ORDER\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'customer_order';\\n\\n-- Tabla ORDER_ITEM\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'order_item';\\n\\n-- Tabla DISCOUNT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'discount';\\n\\n-- Tabla ORDER_DISCOUNT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'order_discount';\\n\\n-- 3. Verificar las restricciones de las tablas\\n-- Comprobar las claves primarias y foráneas\\nSELECT conname, contype, conrelid::regclass AS table_name \\nFROM pg_constraint \\nWHERE contype IN ('p', 'f');\\n\\n-- 4. Validar la migración de datos\\n-- Comparar conteo de filas entre MySQL y PostgreSQL\\nSELECT COUNT(*) FROM customer;\\nSELECT COUNT(*) FROM customer_payment_method;\\nSELECT COUNT(*) FROM product_category;\\nSELECT COUNT(*) FROM product;\\nSELECT COUNT(*) FROM similar_product;\\nSELECT COUNT(*) FROM customer_order;\\nSELECT COUNT(*) FROM order_item;\\nSELECT COUNT(*) FROM discount;\\nSELECT COUNT(*) FROM order_discount;\\n\\n-- 5. Verificar datos específicos\\n-- Comprobar algunos registros aleatorios\\nSELECT * FROM customer LIMIT 10;\\nSELECT * FROM customer_payment_method LIMIT 10;\\nSELECT * FROM product_category LIMIT 10;\\nSELECT * FROM product LIMIT 10;\\nSELECT * FROM similar_product LIMIT 10;\\nSELECT * FROM customer_order LIMIT 10;\\nSELECT * FROM order_item LIMIT 10;\\nSELECT * FROM discount LIMIT 10;\\nSELECT * FROM order_discount LIMIT 10;\\n\\n-- 6. Verificar integridad referencial\\n-- Probar consultas que involucren claves foráneas\\nSELECT * FROM customer_order o \\nJOIN customer c ON o.customer = c.customer_id;\\n\\nSELECT * FROM order_item i \\nJOIN customer_order o ON i.order_id = o.order_id;\\n\\n-- 7. Verificar restricciones CHECK\\n-- Probar las restricciones de las tablas\\nSELECT * FROM customer WHERE shop_opinion NOT BETWEEN 1 AND 5;\\nSELECT * FROM customer_payment_method WHERE payment_method NOT IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL');\\nSELECT * FROM product WHERE price <= 0;\\nSELECT * FROM customer_order WHERE total < 0;\\nSELECT * FROM order_item WHERE quantity <= 0;\\nSELECT * FROM discount WHERE discount_rate <= 0;\",\n    \"metadataForDataValidation\": \"El script de validación está diseñado para asegurar que la migración de datos y esquema desde MySQL a PostgreSQL se haya realizado correctamente. Incluye pasos para verificar la existencia de tablas, comparar la estructura de las tablas en términos de columnas y tipos de datos, validar la migración de datos mediante conteos de filas y comprobaciones de registros específicos, y verificar la integridad referencial a través de consultas que involucren claves foráneas. Además, se comprueban las restricciones CHECK para garantizar que los datos migrados cumplen con las mismas reglas que se aplicaban en MySQL.\"\n}"
        },
        {
          "name": "metashop-4",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MySQL\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"The application is an e-commerce platform that allows customers to browse products, place orders, and manage their payments.\\nThe most frequent queries in the system include:\\n\\n- Listing (ID, name, price, stock) of 'Laptop' category products priced under 1500€ and manufactured by 'LG'.\\n\\n```sql\\nSELECT product_id, name, price, stock\\nFROM PRODUCT\\nWHERE category IN (SELECT category_id\\n                   FROM PRODUCT_CATEGORY\\n                   WHERE name = 'Laptop')\\n  AND price < 1500 and manufacturer = 'LG';\\n```\\n\\n- Retrieving orders placed by customer 'U2929' between 2021-11-01 and 2022-08-31.\\n\\n```sql\\nSELECT * \\nFROM CUSTOMER_ORDER\\nWHERE customer = 'U2929'\\n  AND order_date >= '2021-11-01' AND order_date <= '2022-08-31';\\n```\\n\\n- Getting the products purchased by customer 'U2929' in the same date range.\\n\\n```sql\\nSELECT product_id, name, price\\nFROM PRODUCT\\nWHERE product_id IN (SELECT product\\n                     FROM ORDER_ITEM\\n                     WHERE order_id IN (SELECT order_id\\n                                        FROM CUSTOMER_ORDER\\n                                        WHERE customer = 'U2929'\\n                                        AND order_date >= '2021-11-01' \\n                                        AND order_date <= '2022-08-31'));\\n```\\n\\n- Finding the top 10 best-selling products per country.\\n\\n```sql\\nSELECT P.product_id, P.name, S.country, S.total_sales\\nFROM PRODUCT P JOIN (SELECT I.product prod, U.country, SUM(I.quantity) total_sales\\n                     FROM CUSTOMER_ORDER O JOIN CUSTOMER U ON O.customer = U.customer_id\\n                                   JOIN ORDER_ITEM I ON O.order_id = I.order_id\\n                     GROUP BY I.product, U.country) S\\n               ON P.product_id = S.prod\\nORDER BY S.country, S.total_sales DESC\\nLIMIT 10;\\n```\\n\\n- Identifying customers whose direct or indirect referrals have rated the store poorly (1 or 2 stars).\\n\\n```sql\\nSELECT recommendedby \\nFROM CUSTOMER\\nWHERE shop_opinion < 3;\\n```\\n\\n- Listing direct and indirect recommendations of a customer.\\n\\n```sql\\nSELECT customer_id, name, country\\nFROM CUSTOMER\\nWHERE recommendedby = 'U2929';\\n```\\n\\n- Retrieving products similar to those bought in the latest order of a customer.\\n\\n```sql\\nSELECT product2\\nFROM SIMILAR_PRODUCT\\nWHERE product1 IN (SELECT product\\n                   FROM ORDER_ITEM\\n                   WHERE order_id IN (SELECT order_id\\n                                      FROM CUSTOMER_ORDER O1\\n                                      WHERE customer = 'U2929' \\n                                      AND order_date = (SELECT MAX(order_date) \\n                                                        FROM CUSTOMER_ORDER \\n                                                        WHERE O2.customer = O1.customer)));\\n```\\n\",\r\n  \"applicationArchitecture\": \"The application is a monolithic web application with a backend in Java using Spring Boot.\",\r\n  \"underlyingTechnologies\": \"The backend is developed in Java and Spring Boot, with PostgreSQL as the target database.\",\r\n  \"databaseSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\r\n  \"migrationRequirements\": \"Ensure compatibility between MySQL and PostgreSQL data types.\\nConvert `AUTO_INCREMENT` fields to `SERIAL` in PostgreSQL.\\nReplace `DATETIME` with `TIMESTAMP` where needed.\\nModify `BOOLEAN` fields to ensure PostgreSQL compatibility (`TRUE`/`FALSE`).\\nEnsure foreign keys maintain referential integrity.\\nMigrate queries:\\n  - Convert `LIMIT 10` queries into appropriate window functions when necessary.\\n  - Adapt JOIN conditions and subqueries to PostgreSQL-specific syntax.\\n  - Convert the `shop_opinion` field's check constraints to PostgreSQL syntax.\\n  - Ensure that recursive queries (such as recommendations) are handled efficiently.\\nImport data ensuring sequence values match expected IDs to prevent conflicts in SERIAL fields.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:59:19 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE CUSTOMER (\\n    customer_id CHAR(4) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    email VARCHAR(40) UNIQUE NOT NULL,\\n    password VARCHAR(20) NOT NULL,\\n    shipping_addr VARCHAR(60),\\n    country VARCHAR(30) NOT NULL,\\n    register_date DATE NOT NULL,\\n    recommendedby CHAR(4) REFERENCES CUSTOMER(customer_id),\\n    shop_opinion INTEGER CHECK (shop_opinion BETWEEN 1 AND 5) DEFAULT 3,\\n    ispremium BOOLEAN NOT NULL DEFAULT FALSE,\\n    premium_fee DECIMAL(6,2),\\n    premium_date DATE\\n);\\n\\nCREATE TABLE CUSTOMER_PAYMENT_METHOD (\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL')),\\n    PRIMARY KEY (customer, payment_method)\\n);\\n\\nCREATE TABLE PRODUCT_CATEGORY (\\n    category_id CHAR(10) PRIMARY KEY,\\n    description VARCHAR(60)\\n);\\n\\nCREATE TABLE PRODUCT (\\n    product_id CHAR(10) PRIMARY KEY,\\n    name VARCHAR(30) NOT NULL,\\n    price DECIMAL(6,2) NOT NULL CHECK (price > 0),\\n    description VARCHAR(60),\\n    imageURL VARCHAR(60),\\n    manufacturer VARCHAR(30) NOT NULL,\\n    stock INTEGER NOT NULL CHECK (stock >= 0),\\n    category CHAR(10) NOT NULL REFERENCES PRODUCT_CATEGORY(category_id)\\n);\\n\\nCREATE TABLE SIMILAR_PRODUCT (\\n    product1 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    product2 CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    PRIMARY KEY (product1, product2)\\n);\\n\\nCREATE TABLE CUSTOMER_ORDER (\\n    order_id SERIAL PRIMARY KEY,\\n    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\\n    customer CHAR(4) NOT NULL REFERENCES CUSTOMER(customer_id),\\n    total DECIMAL(7,2) NOT NULL CHECK (total >= 0)\\n);\\n\\nCREATE TABLE ORDER_ITEM (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    item INTEGER NOT NULL,\\n    product CHAR(10) NOT NULL REFERENCES PRODUCT(product_id),\\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\\n    subtotal DECIMAL(6,2) NOT NULL CHECK (subtotal >= 0),\\n    PRIMARY KEY (order_id, item)\\n);\\n\\nCREATE TABLE DISCOUNT (\\n    discount_id SERIAL PRIMARY KEY,\\n    description VARCHAR(60) NOT NULL,\\n    discount_rate DECIMAL(4,2) NOT NULL CHECK (discount_rate > 0)\\n);\\n\\nCREATE TABLE ORDER_DISCOUNT (\\n    order_id INTEGER NOT NULL REFERENCES CUSTOMER_ORDER(order_id),\\n    discount INTEGER NOT NULL REFERENCES DISCOUNT(discount_id),\\n    PRIMARY KEY (order_id, discount)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema de base de datos en PostgreSQL que refleja la estructura de la base de datos original de MySQL. Se han mantenido los tipos de datos de PostgreSQL, como SERIAL para campos autoincrementales y TIMESTAMP para fechas y horas. Las restricciones de clave foránea se han mantenido para asegurar la integridad referencial. Las restricciones CHECK han sido adaptadas a la sintaxis de PostgreSQL. Además, se han mantenido las restricciones de unicidad y no nulidad según lo especificado en el esquema original de MySQL.\",\n    \"guidelinesForValidateSchema\": \"### Pautas y Recomendaciones para la Validación de la Migración de Esquema de MySQL a PostgreSQL\\n\\nA continuación se presentan pasos detallados que el usuario puede seguir para validar manualmente la transformación del esquema desde MySQL a PostgreSQL y asegurar que el nuevo esquema esté correctamente implementado y optimizado.\\n\\n#### 1. Verificación de la Estructura del Esquema\\n\\n**Paso 1: Comparar la Estructura de las Tablas**\\n- Utilizar herramientas de administración de bases de datos como `pgAdmin`, `DBeaver` o `psql` para visualizar la estructura de las tablas en la base de datos PostgreSQL.\\n- Comparar cada tabla del esquema original de MySQL con el esquema de PostgreSQL:\\n  - **Nombres de Tablas y Columnas**: Asegurarse de que los nombres sean idénticos y que no haya errores tipográficos.\\n  - **Tipos de Datos**: Verificar que los tipos de datos sean compatibles y correctos:\\n    - `CHAR` y `VARCHAR` deben ser revisados para su longitud.\\n    - `DECIMAL` debe tener la precisión y escala correctas.\\n    - `TIMESTAMP` debe ser usado en lugar de `DATETIME`.\\n    - `BOOLEAN` debe ser revisado para asegurar que se almacena como `TRUE`/`FALSE`.\\n  - **Restricciones**: Comprobar que las restricciones como `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, y `CHECK` estén presentes y correctamente definidas.\\n\\n**Paso 2: Validar las Claves Foráneas**\\n- Ejecutar consultas en PostgreSQL para asegurarse de que las claves foráneas están establecidas correctamente. Por ejemplo:\\n  ```sql\\n  SELECT conname, confdeltype, confupdtype\\n  FROM pg_constraint\\n  WHERE conrelid = 'CUSTOMER'::regclass AND contype = 'f';\\n  ```\\n- Comprobar que las relaciones de referencia entre las tablas sean correctas y que no existan violaciones de integridad referencial.\\n\\n#### 2. Verificación de Datos\\n\\n**Paso 3: Validar la Migración de Datos**\\n- Si es posible, realizar una comparación de conteos de filas entre las tablas de origen y destino:\\n  ```sql\\n  SELECT COUNT(*) FROM CUSTOMER; -- Para MySQL\\n  SELECT COUNT(*) FROM CUSTOMER; -- Para PostgreSQL\\n  ```\\n- Verificar algunos registros aleatorios de cada tabla para asegurarse de que los datos se han migrado correctamente.\\n- Comprobar que los valores de las columnas que tienen restricciones (ej. `CHECK`, `UNIQUE`) no violen estas restricciones.\\n\\n#### 3. Optimización del Esquema\\n\\n**Paso 4: Evaluar Índices y Rendimiento**\\n- Revisar los índices en las tablas de PostgreSQL y asegurarse de que se han creado índices adecuados para mejorar el rendimiento de las consultas.\\n- Realizar análisis de rendimiento utilizando `EXPLAIN` para consultas comunes para identificar posibles cuellos de botella.\\n\\n**Paso 5: Pruebas de Consultas Frecuentes**\\n- Ejecutar las consultas más comunes en el nuevo esquema para asegurarse de que se comportan como se espera. Las consultas incluyen:\\n  - Listar productos de una categoría específica.\\n  - Recuperar pedidos de un cliente en un rango de fechas.\\n  - Obtener productos comprados por un cliente.\\n  - Identificar clientes con opiniones bajas.\\n- Comparar los tiempos de ejecución de las consultas entre MySQL y PostgreSQL para detectar diferencias significativas.\\n\\n#### 4. Pruebas de Funcionalidad\\n\\n**Paso 6: Probar Funcionalidades de la Aplicación**\\n- Si hay una aplicación que interactúa con la base de datos, realizar pruebas funcionales para garantizar que todas las características y funcionalidades funcionan como se espera.\\n- Asegurarse de que las operaciones de inserción, actualización y eliminación funcionan correctamente y que las restricciones se aplican.\\n\\n#### 5. Documentación y Reportes\\n\\n**Paso 7: Documentar Resultados**\\n- Documentar todos los resultados de las pruebas de validación, incluyendo cualquier discrepancia encontrada y cómo se resolvió.\\n- Mantener un registro de las consultas de rendimiento y cualquier ajuste realizado en el esquema.\\n\\n### Conclusión\\nSiguiendo estos pasos y recomendaciones, el usuario podrá validar de manera efectiva la migración del esquema de MySQL a PostgreSQL, asegurando que la nueva base de datos esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"-- Migración de datos desde MySQL a PostgreSQL\\n\\n-- 1. Insertar datos en la tabla CUSTOMER\\nINSERT INTO CUSTOMER (customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date)\\nSELECT customer_id, name, email, password, shipping_addr, country, register_date, recommendedby, shop_opinion, ispremium, premium_fee, premium_date\\nFROM mysql_database.CUSTOMER;\\n\\n-- 2. Insertar datos en la tabla CUSTOMER_PAYMENT_METHOD\\nINSERT INTO CUSTOMER_PAYMENT_METHOD (customer, payment_method)\\nSELECT customer, payment_method\\nFROM mysql_database.CUSTOMER_PAYMENT_METHOD;\\n\\n-- 3. Insertar datos en la tabla PRODUCT_CATEGORY\\nINSERT INTO PRODUCT_CATEGORY (category_id, description)\\nSELECT category_id, description\\nFROM mysql_database.PRODUCT_CATEGORY;\\n\\n-- 4. Insertar datos en la tabla PRODUCT\\nINSERT INTO PRODUCT (product_id, name, price, description, imageURL, manufacturer, stock, category)\\nSELECT product_id, name, price, description, imageURL, manufacturer, stock, category\\nFROM mysql_database.PRODUCT;\\n\\n-- 5. Insertar datos en la tabla SIMILAR_PRODUCT\\nINSERT INTO SIMILAR_PRODUCT (product1, product2)\\nSELECT product1, product2\\nFROM mysql_database.SIMILAR_PRODUCT;\\n\\n-- 6. Insertar datos en la tabla CUSTOMER_ORDER\\nINSERT INTO CUSTOMER_ORDER (order_id, order_date, customer, total)\\nSELECT DEFAULT, order_date, customer, total\\nFROM mysql_database.CUSTOMER_ORDER;\\n\\n-- 7. Insertar datos en la tabla ORDER_ITEM\\nINSERT INTO ORDER_ITEM (order_id, item, product, quantity, subtotal)\\nSELECT order_id, item, product, quantity, subtotal\\nFROM mysql_database.ORDER_ITEM;\\n\\n-- 8. Insertar datos en la tabla DISCOUNT\\nINSERT INTO DISCOUNT (discount_id, description, discount_rate)\\nSELECT DEFAULT, description, discount_rate\\nFROM mysql_database.DISCOUNT;\\n\\n-- 9. Insertar datos en la tabla ORDER_DISCOUNT\\nINSERT INTO ORDER_DISCOUNT (order_id, discount)\\nSELECT order_id, discount\\nFROM mysql_database.ORDER_DISCOUNT;\",\n    \"metadataForDataMigration\": \"El script de migración de datos está diseñado para transferir datos desde una base de datos MySQL a PostgreSQL. Cada sección del script realiza una inserción de datos desde las tablas de MySQL a las tablas correspondientes en PostgreSQL. Se asegura de que los campos que son SERIAL en PostgreSQL se manejen correctamente al usar DEFAULT para el campo 'order_id' y 'discount_id', lo que permite que PostgreSQL genere automáticamente los valores. Este enfoque mantiene la integridad referencial y asegura que los datos se transfieran de manera eficiente y precisa, respetando las restricciones de cada tabla. Las tablas intermedias se manejan adecuadamente para asegurar que las relaciones se mantengan.\",\n    \"scriptForDataValidation\": \"-- Validación de la migración de datos y esquema de MySQL a PostgreSQL\\n\\n-- 1. Verificar la existencia de tablas en PostgreSQL\\nSELECT table_name \\nFROM information_schema.tables \\nWHERE table_schema = 'public';\\n\\n-- 2. Comparar la estructura de las tablas\\n-- Para cada tabla, verificar columnas y tipos de datos\\n\\n-- Tabla CUSTOMER\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'CUSTOMER';\\n\\n-- Tabla CUSTOMER_PAYMENT_METHOD\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'CUSTOMER_PAYMENT_METHOD';\\n\\n-- Tabla PRODUCT_CATEGORY\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'PRODUCT_CATEGORY';\\n\\n-- Tabla PRODUCT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'PRODUCT';\\n\\n-- Tabla SIMILAR_PRODUCT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'SIMILAR_PRODUCT';\\n\\n-- Tabla CUSTOMER_ORDER\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'CUSTOMER_ORDER';\\n\\n-- Tabla ORDER_ITEM\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ORDER_ITEM';\\n\\n-- Tabla DISCOUNT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'DISCOUNT';\\n\\n-- Tabla ORDER_DISCOUNT\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ORDER_DISCOUNT';\\n\\n-- 3. Verificar las restricciones de las tablas\\n-- Comprobar las claves primarias y foráneas\\nSELECT conname, contype, conrelid::regclass AS table_name \\nFROM pg_constraint \\nWHERE contype IN ('p', 'f');\\n\\n-- 4. Validar la migración de datos\\n-- Comparar conteo de filas entre MySQL y PostgreSQL\\nSELECT COUNT(*) FROM CUSTOMER;\\nSELECT COUNT(*) FROM CUSTOMER_PAYMENT_METHOD;\\nSELECT COUNT(*) FROM PRODUCT_CATEGORY;\\nSELECT COUNT(*) FROM PRODUCT;\\nSELECT COUNT(*) FROM SIMILAR_PRODUCT;\\nSELECT COUNT(*) FROM CUSTOMER_ORDER;\\nSELECT COUNT(*) FROM ORDER_ITEM;\\nSELECT COUNT(*) FROM DISCOUNT;\\nSELECT COUNT(*) FROM ORDER_DISCOUNT;\\n\\n-- 5. Verificar datos específicos\\n-- Comprobar algunos registros aleatorios\\nSELECT * FROM CUSTOMER LIMIT 10;\\nSELECT * FROM CUSTOMER_PAYMENT_METHOD LIMIT 10;\\nSELECT * FROM PRODUCT_CATEGORY LIMIT 10;\\nSELECT * FROM PRODUCT LIMIT 10;\\nSELECT * FROM SIMILAR_PRODUCT LIMIT 10;\\nSELECT * FROM CUSTOMER_ORDER LIMIT 10;\\nSELECT * FROM ORDER_ITEM LIMIT 10;\\nSELECT * FROM DISCOUNT LIMIT 10;\\nSELECT * FROM ORDER_DISCOUNT LIMIT 10;\\n\\n-- 6. Verificar integridad referencial\\n-- Probar consultas que involucren claves foráneas\\nSELECT * FROM CUSTOMER_ORDER o \\nJOIN CUSTOMER c ON o.customer = c.customer_id;\\n\\nSELECT * FROM ORDER_ITEM i \\nJOIN CUSTOMER_ORDER o ON i.order_id = o.order_id;\\n\\n-- 7. Verificar restricciones CHECK\\n-- Probar las restricciones de las tablas\\nSELECT * FROM CUSTOMER WHERE shop_opinion NOT BETWEEN 1 AND 5;\\nSELECT * FROM CUSTOMER_PAYMENT_METHOD WHERE payment_method NOT IN ('VISA', 'MASTERCARD', '4B', 'EURO6000', 'PAYPAL');\\nSELECT * FROM PRODUCT WHERE price <= 0;\\nSELECT * FROM CUSTOMER_ORDER WHERE total < 0;\\nSELECT * FROM ORDER_ITEM WHERE quantity <= 0;\\nSELECT * FROM DISCOUNT WHERE discount_rate <= 0;\",\n    \"metadataForDataValidation\": \"El script de validación está diseñado para asegurar que la migración de datos y esquema desde MySQL a PostgreSQL se haya realizado correctamente. Incluye pasos para verificar la existencia de tablas, comparar la estructura de las tablas en términos de columnas y tipos de datos, validar la migración de datos mediante conteos de filas y comprobaciones de registros específicos, y verificar la integridad referencial a través de consultas que involucren claves foráneas. Además, se comprueban las restricciones CHECK para garantizar que los datos migrados cumplen con las mismas reglas que se aplicaban en MySQL.\"\n}"
        }
      ]
    },
    {
      "name": "mongoose-example",
      "request": {
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{migrations_url}}",
          "host": ["{{migrations_url}}"]
        }
      },
      "response": [
        {
          "name": "mongoose-example-gpt4o-mini",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sun, 02 Mar 2025 22:15:35 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    precio DECIMAL(10, 2) NOT NULL,\\n    descripcion TEXT,\\n    imagenURL VARCHAR(255),\\n    fabricante VARCHAR(255) NOT NULL,\\n    stock INTEGER NOT NULL,\\n    categoria_id INTEGER NOT NULL REFERENCES Categoria(id)\\n);\\n\\nCREATE TABLE ProductoRelacionado (\\n    id SERIAL PRIMARY KEY,\\n    id_producto_relacionado BIGINT NOT NULL REFERENCES Producto(id)\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id SERIAL PRIMARY KEY,\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    nombreItem VARCHAR(255) NOT NULL,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE Descuento (\\n    id BIGSERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL,\\n    ratioDescuento DECIMAL(5, 2) NOT NULL\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id SERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR(255) NOT NULL,\\n    infoMetodo VARCHAR(255) NOT NULL\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password VARCHAR(255) NOT NULL,\\n    direccion VARCHAR(255),\\n    pais VARCHAR(255) NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    usuario_recomendadoPor BIGINT REFERENCES Usuario(id),\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL(10, 2)\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    usuario_id BIGINT NOT NULL REFERENCES Usuario(id),\\n    metodo_pago_id INTEGER NOT NULL REFERENCES MetodoPago(id),\\n    PRIMARY KEY (usuario_id, metodo_pago_id)\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    pedido_id BIGINT NOT NULL REFERENCES Pedido(id),\\n    descuento_id BIGINT NOT NULL REFERENCES Descuento(id),\\n    PRIMARY KEY (pedido_id, descuento_id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    producto_relacionado_id BIGINT NOT NULL REFERENCES Producto(id),\\n    PRIMARY KEY (producto_id, producto_relacionado_id)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea las tablas necesarias en PostgreSQL, adaptando las estructuras anidadas de MongoDB a tablas separadas con claves foráneas. Se han utilizado tipos de datos adecuados para cada campo: 'SERIAL' y 'BIGSERIAL' para los identificadores, 'VARCHAR' y 'TEXT' para cadenas, 'DECIMAL' para precios, 'INTEGER' para cantidades y 'TIMESTAMP' para fechas. Las tablas intermedias se han creado para reemplazar los arrays embebidos, manteniendo la integridad referencial a través de claves foráneas. Se asegura que el campo 'email' en la tabla 'Usuario' sea único y se han añadido índices en campos clave para mejorar el rendimiento de las consultas.\",\n    \"guidelinesForValidateSchema\": \"A continuación se presentan pautas y recomendaciones detalladas para validar manualmente la transformación del esquema desde MongoDB a PostgreSQL y asegurar la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### 1. Verificación de la Transformación del Esquema\\n\\n#### Pasos de Verificación:\\n- **Estructura de Tablas:**\\n  - Asegúrate de que todas las tablas definidas en el script de PostgreSQL han sido creadas correctamente.\\n  - Verifica que los tipos de datos sean compatibles y estén correctamente definidos:\\n    - `SERIAL` y `BIGSERIAL` deben estar asignados correctamente para los identificadores.\\n    - `VARCHAR` y `TEXT` deben estar correctamente especificados para cadenas de texto.\\n    - `DECIMAL` debe ser utilizado para los precios y las tasas de descuento.\\n    - `TIMESTAMP` debe ser utilizado para las fechas.\\n\\n- **Relaciones y Claves Foráneas:**\\n  - Verifica que todas las claves primarias y foráneas estén correctamente definidas.\\n  - Asegúrate de que las relaciones entre las tablas se mantengan y que las claves foráneas referencien correctamente las claves primarias de las tablas correspondientes.\\n\\n- **Restricciones de Integridad:**\\n  - Revisa que todas las restricciones de unicidad y verificación (`CHECK`) estén presentes y sean correctas.\\n\\n#### Sugerencias de Pruebas Manuales:\\n- Ejecuta el siguiente comando para listar todas las tablas en la base de datos:\\n  ```sql\\n  \\\\dt\\n  ```\\n- Revisa la estructura de cada tabla utilizando:\\n  ```sql\\n  \\\\d Categoria\\n  \\\\d Producto\\n  \\\\d ProductoRelacionado\\n  \\\\d ItemPedido\\n  \\\\d Descuento\\n  \\\\d Pedido\\n  \\\\d MetodoPago\\n  \\\\d Usuario\\n  \\\\d UsuariosMetodosPago\\n  \\\\d PedidosDescuentos\\n  \\\\d ProductosRelacionados\\n  ```\\n- Comprueba que las restricciones y claves foráneas estén presentes usando:\\n  ```sql\\n  SELECT conname, conrelid::regclass AS table_name\\n  FROM pg_constraint\\n  WHERE conrelid IN (SELECT oid FROM pg_class WHERE relname IN ('Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario', 'UsuariosMetodosPago', 'PedidosDescuentos', 'ProductosRelacionados'));\\n  ```\\n\\n### 2. Verificación de la Integridad Referencial\\n\\n#### Pasos de Verificación:\\n- **Validar Claves Foráneas:**\\n  - Realiza consultas para verificar que no existan registros en las tablas que refieran a claves primarias inexistentes.\\n  - Por ejemplo, verifica que todos los `categoria_id` en `Producto` existan en `Categoria`:\\n  ```sql\\n  SELECT DISTINCT categoria_id\\n  FROM Producto\\n  WHERE categoria_id NOT IN (SELECT id FROM Categoria);\\n  ```\\n\\n- **Validar Datos en Tablas:**\\n  - Comprueba que no existan registros huérfanos en las tablas que dependen de otras. Por ejemplo:\\n  ```sql\\n  SELECT DISTINCT producto_id\\n  FROM ProductoRelacionado\\n  WHERE id_producto_relacionado NOT IN (SELECT id FROM Producto);\\n  ```\\n\\n### 3. Optimización del Esquema\\n\\n#### Puntos de Control para la Optimización:\\n- **Indexación:**\\n  - Asegúrate de que los índices estén creados en las columnas que se utilizan con frecuencia en las consultas, especialmente en claves foráneas y en campos que se utilizan en las cláusulas `WHERE`.\\n  ```sql\\n  CREATE INDEX idx_usuario_email ON Usuario(email);\\n  CREATE INDEX idx_producto_nombre ON Producto(nombre);\\n  ```\\n\\n- **Estructura de Tablas:**\\n  - Considera si algunas tablas pueden beneficiarse de la normalización o desnormalización, dependiendo de los patrones de acceso a los datos.\\n  - Verifica si algunas tablas podrían ser combinadas si se utilizan frecuentemente juntas.\\n\\n### 4. Validación de Consultas Comunes\\n\\n#### Pasos de Verificación:\\n- **Pruebas de Consultas:**\\n  - Ejecuta las consultas más comunes que se espera que se realicen en la aplicación y verifica que los resultados sean correctos.\\n  - Por ejemplo, prueba la consulta para listar productos en una categoría específica:\\n  ```sql\\n  SELECT id, nombre, precio, stock\\n  FROM Producto\\n  WHERE categoria_id = (SELECT id FROM Categoria WHERE descripcion = 'Electronics');\\n  ```\\n\\n- **Pruebas de Integración:**\\n  - Realiza pruebas de inserción, actualización y eliminación en las tablas y verifica que se mantenga la integridad referencial.\\n  - Asegúrate de que las operaciones en cascada funcionen correctamente para las claves foráneas.\\n\\n### 5. Resumen de Recomendaciones para Pruebas Manuales\\n\\n- Revisa la estructura de cada tabla y verifica que coincida con el esquema esperado.\\n- Realiza consultas para verificar la integridad referencial y que no existan registros huérfanos.\\n- Ejecuta las consultas comunes y verifica que los resultados sean correctos.\\n- Asegúrate de que las optimizaciones, como índices, estén presentes y sean efectivas.\\n- Mantén un registro de cualquier inconsistencia o problema encontrado durante la validación y toma medidas correctivas.\\n\\nSiguiendo estas pautas, podrás validar la migración del esquema de MongoDB a PostgreSQL de manera efectiva y asegurar que la base de datos de destino esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"INSERT INTO Categoria (descripcion) VALUES\\n    ('Electronics'),\\n    ('Clothing'),\\n    ('Home Appliances');\\n\\nINSERT INTO Producto (id, nombre, precio, descripcion, imagenURL, fabricante, stock, categoria_id) VALUES\\n    (1, 'Smartphone', 699.99, 'Latest model smartphone', 'http://example.com/smartphone.jpg', 'Brand A', 50, 1),\\n    (2, 'T-Shirt', 19.99, 'Comfortable cotton T-shirt', 'http://example.com/tshirt.jpg', 'Brand B', 100, 2),\\n    (3, 'Washing Machine', 499.99, 'High-efficiency washing machine', 'http://example.com/washingmachine.jpg', 'Brand C', 30, 3);\\n\\nINSERT INTO ProductoRelacionado (id_producto_relacionado) VALUES\\n    (1),\\n    (2);\\n\\nINSERT INTO ItemPedido (producto_id, nombreItem, cantidad, subtotal) VALUES\\n    (1, 'Smartphone', 1, 699.99),\\n    (2, 'T-Shirt', 2, 39.98);\\n\\nINSERT INTO Descuento (id, descripcion, ratioDescuento) VALUES\\n    (1, 'Spring Sale', 0.10),\\n    (2, 'Clearance', 0.20);\\n\\nINSERT INTO Pedido (id, fechaPedido, precioTotal) VALUES\\n    (1, '2023-10-01 10:00:00', 739.97);\\n\\nINSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES\\n    ('Credit Card', 'Visa **** **** **** 1234'),\\n    ('PayPal', 'user@example.com');\\n\\nINSERT INTO Usuario (id, nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES\\n    (1, 'John Doe', 'john@example.com', 'password123', '123 Main St', 'USA', '2023-10-01 10:00:00', NULL, 5, FALSE, NULL, NULL);\\n\\nINSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id) VALUES\\n    (1, 1);\\n\\nINSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES\\n    (1, 1);\\n\\nINSERT INTO ProductosRelacionados (producto_id, producto_relacionado_id) VALUES\\n    (1, 2);\",\n    \"metadataForDataMigration\": \"El script inserta datos en las tablas correspondientes de PostgreSQL, asegurando que las estructuras anidadas de MongoDB se conviertan en tablas separadas con claves foráneas. Se insertan ejemplos de datos en las tablas 'Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario', y se crean las tablas intermedias 'UsuariosMetodosPago', 'PedidosDescuentos', y 'ProductosRelacionados'. Cada inserción respeta los tipos de datos definidos en el esquema y se asegura que las relaciones entre las tablas se mantengan a través de las claves foráneas.\",\n    \"scriptForDataValidation\": \"const categoriasMigradas = db.Categoria.find().toArray();\\nconst productosMigrados = db.Producto.find().toArray();\\nconst productosRelacionadosMigrados = db.ProductoRelacionado.find().toArray();\\nconst itemPedidosMigrados = db.ItemPedido.find().toArray();\\nconst descuentosMigrados = db.Descuento.find().toArray();\\nconst pedidosMigrados = db.Pedido.find().toArray();\\nconst metodosPagoMigrados = db.MetodoPago.find().toArray();\\nconst usuariosMigrados = db.Usuario.find().toArray();\\nconst usuariosMetodosPagoMigrados = db.UsuariosMetodosPago.find().toArray();\\nconst pedidosDescuentosMigrados = db.PedidosDescuentos.find().toArray();\\nconst productosRelacionadosMigrados = db.ProductosRelacionados.find().toArray();\\n\\n// Validar Categorias\\nconst categoriasValidas = categoriasMigradas.every(categoria => {\\n  return categoria.id && typeof categoria.descripcion === 'string';\\n});\\nif (!categoriasValidas) {\\n  print('Error: Una o más categorias no cumplen con el esquema esperado.');\\n} else {\\n  print('Todas las categorias son válidas.');\\n}\\n\\n// Validar Productos\\nconst productosValidos = productosMigrados.every(producto => {\\n  return producto.id &&\\n         typeof producto.nombre === 'string' &&\\n         typeof producto.precio === 'number' &&\\n         typeof producto.fabricante === 'string' &&\\n         typeof producto.stock === 'number' &&\\n         producto.categoria_id;\\n});\\nif (!productosValidos) {\\n  print('Error: Uno o más productos no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los productos son válidos.');\\n}\\n\\n// Validar Productos Relacionados\\nconst productosRelacionadosValidos = productosRelacionadosMigrados.every(relacion => {\\n  return relacion.id_producto_relacionado &&\\n         productosMigrados.some(p => p.id === relacion.id_producto_relacionado);\\n});\\nif (!productosRelacionadosValidos) {\\n  print('Error: Uno o más productos relacionados no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los productos relacionados son válidos.');\\n}\\n\\n// Validar ItemPedidos\\nconst itemsPedidosValidos = itemPedidosMigrados.every(item => {\\n  return item.producto_id &&\\n         typeof item.nombreItem === 'string' &&\\n         typeof item.cantidad === 'number' &&\\n         typeof item.subtotal === 'number';\\n});\\nif (!itemsPedidosValidos) {\\n  print('Error: Uno o más items de pedido no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los items de pedido son válidos.');\\n}\\n\\n// Validar Descuentos\\nconst descuentosValidos = descuentosMigrados.every(descuento => {\\n  return descuento.id &&\\n         typeof descuento.descripcion === 'string' &&\\n         typeof descuento.ratioDescuento === 'number';\\n});\\nif (!descuentosValidos) {\\n  print('Error: Uno o más descuentos no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los descuentos son válidos.');\\n}\\n\\n// Validar Pedidos\\nconst pedidosValidos = pedidosMigrados.every(pedido => {\\n  return pedido.id &&\\n         pedido.fechaPedido instanceof Date &&\\n         typeof pedido.precioTotal === 'number';\\n});\\nif (!pedidosValidos) {\\n  print('Error: Uno o más pedidos no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los pedidos son válidos.');\\n}\\n\\n// Validar Metodos de Pago\\nconst metodosPagoValidos = metodosPagoMigrados.every(metodo => {\\n  return metodo.id &&\\n         typeof metodo.nombreMetodo === 'string' &&\\n         typeof metodo.infoMetodo === 'string';\\n});\\nif (!metodosPagoValidos) {\\n  print('Error: Uno o más métodos de pago no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los métodos de pago son válidos.');\\n}\\n\\n// Validar Usuarios\\nconst usuariosValidos = usuariosMigrados.every(usuario => {\\n  return usuario.id &&\\n         typeof usuario.nombre === 'string' &&\\n         typeof usuario.email === 'string' &&\\n         typeof usuario.password === 'string' &&\\n         usuario.fechaRegistro instanceof Date &&\\n         typeof usuario.valoracionTienda === 'number' &&\\n         typeof usuario.premium === 'boolean';\\n});\\nif (!usuariosValidos) {\\n  print('Error: Uno o más usuarios no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los usuarios son válidos.');\\n}\\n\\n// Validar Usuarios Metodos de Pago\\nconst usuariosMetodosPagoValidos = usuariosMetodosPagoMigrados.every(ump => {\\n  return usuariosMigrados.some(u => u.id === ump.usuario_id) &&\\n         metodosPagoMigrados.some(m => m.id === ump.metodo_pago_id);\\n});\\nif (!usuariosMetodosPagoValidos) {\\n  print('Error: Uno o más registros en UsuariosMetodosPago no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en UsuariosMetodosPago son válidos.');\\n}\\n\\n// Validar Pedidos Descuentos\\nconst pedidosDescuentosValidos = pedidosDescuentosMigrados.every(pd => {\\n  return pedidosMigrados.some(p => p.id === pd.pedido_id) &&\\n         descuentosMigrados.some(d => d.id === pd.descuento_id);\\n});\\nif (!pedidosDescuentosValidos) {\\n  print('Error: Uno o más registros en PedidosDescuentos no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en PedidosDescuentos son válidos.');\\n}\\n\\n// Validar Productos Relacionados\\nconst productosRelacionadosValidos = productosRelacionadosMigrados.every(pr => {\\n  return productosMigrados.some(p => p.id === pr.producto_id) &&\\n         productosMigrados.some(p => p.id === pr.producto_relacionado_id);\\n});\\nif (!productosRelacionadosValidos) {\\n  print('Error: Uno o más registros en ProductosRelacionados no cumplen con el esquema esperado.');\\n} else {\\n  print('Todos los registros en ProductosRelacionados son válidos.');\\n}\\n\\n// Contar registros migrados\\nprint('Total de registros migrados:');\\nprint('Categorias: ' + categoriasMigradas.length);\\nprint('Productos: ' + productosMigrados.length);\\nprint('Productos Relacionados: ' + productosRelacionadosMigrados.length);\\nprint('Items de Pedido: ' + itemPedidosMigrados.length);\\nprint('Descuentos: ' + descuentosMigrados.length);\\nprint('Pedidos: ' + pedidosMigrados.length);\\nprint('Metodos de Pago: ' + metodosPagoMigrados.length);\\nprint('Usuarios: ' + usuariosMigrados.length);\\nprint('Usuarios Metodos de Pago: ' + usuariosMetodosPagoMigrados.length);\\nprint('Pedidos Descuentos: ' + pedidosDescuentosMigrados.length);\\nprint('Productos Relacionados: ' + productosRelacionadosMigrados.length);\",\n    \"metadataForDataValidation\": \"El script comienza recuperando todos los documentos de las colecciones en PostgreSQL. Luego, valida que cada colección cumpla con los requisitos del esquema esperado, verificando que los campos requeridos estén presentes y que sus tipos de datos sean correctos. Se realizan verificaciones específicas para asegurar que las restricciones y condiciones (como las restricciones de unicidad y los valores permitidos) se cumplan. Si se encuentra algún error, se imprime un mensaje de error; de lo contrario, se confirma que todos los registros son válidos. Finalmente, se imprime el total de registros migrados para cada colección.\"\n}"
        },
        {
          "name": "mongoose-example-2",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:31:20 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255)\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id SERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR(255) NOT NULL,\\n    infoMetodo TEXT NOT NULL\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    precio DECIMAL(10, 2) NOT NULL,\\n    descripcion TEXT,\\n    imagenURL TEXT,\\n    fabricante VARCHAR(255) NOT NULL,\\n    stock INTEGER NOT NULL,\\n    categorias INTEGER NOT NULL REFERENCES Categoria(id),\\n    UNIQUE (nombre)\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    email VARCHAR(255) NOT NULL UNIQUE,\\n    password VARCHAR(255) NOT NULL,\\n    direccion TEXT,\\n    pais VARCHAR(255) NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    _usuarios_recomendadoPor BIGSERIAL REFERENCES Usuario(id),\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL(10, 2)\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL(10, 2) NOT NULL,\\n    usuario_id BIGSERIAL NOT NULL REFERENCES Usuario(id)\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL(10, 2) NOT NULL,\\n    nombreItem VARCHAR(255) NOT NULL,\\n    _productos_productoId BIGSERIAL NOT NULL REFERENCES Producto(id),\\n    pedido_id BIGSERIAL NOT NULL REFERENCES Pedido(id)\\n);\\n\\nCREATE TABLE Descuento (\\n    id BIGSERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL,\\n    ratioDescuento DECIMAL(5, 2) NOT NULL\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    pedido_id BIGSERIAL NOT NULL REFERENCES Pedido(id),\\n    descuento_id BIGSERIAL NOT NULL REFERENCES Descuento(id),\\n    PRIMARY KEY (pedido_id, descuento_id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    producto_id BIGSERIAL NOT NULL REFERENCES Producto(id),\\n    id_producto_relacionado BIGSERIAL NOT NULL REFERENCES Producto(id),\\n    PRIMARY KEY (producto_id, id_producto_relacionado)\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    usuario_id BIGSERIAL NOT NULL REFERENCES Usuario(id),\\n    metodo_pago_id BIGSERIAL NOT NULL REFERENCES MetodoPago(id),\\n    PRIMARY KEY (usuario_id, metodo_pago_id)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea las tablas necesarias en PostgreSQL a partir del esquema de MongoDB, realizando las adaptaciones requeridas para asegurar la compatibilidad. Las estructuras anidadas se convierten en tablas separadas, y se utilizan claves foráneas para mantener las relaciones. Se utilizan tipos de datos apropiados como SERIAL y BIGSERIAL para los IDs, y se definen restricciones como UNIQUE para el campo email en la tabla Usuario. Se crean tablas intermedias para manejar las relaciones de muchos a muchos, asegurando la integridad referencial.\",\n    \"guidelinesForValidateSchema\": \"Aquí tienes un conjunto de pautas y recomendaciones detalladas para validar manualmente la migración del esquema desde MongoDB a PostgreSQL, así como la correcta implementación y optimización del nuevo esquema en la base de datos de destino.\\n\\n### Pautas para la Verificación de la Migración del Esquema\\n\\n#### 1. Verificación de la Estructura de las Tablas\\n\\n- **Paso 1:** Conéctate a la base de datos PostgreSQL utilizando una herramienta como pgAdmin, DBeaver o la línea de comandos de PostgreSQL.\\n\\n- **Paso 2:** Verifica que todas las tablas han sido creadas correctamente.\\n  ```sql\\n  \\\\dt\\n  ```\\n\\n- **Paso 3:** Inspecciona la estructura de cada tabla utilizando:\\n  ```sql\\n  \\\\d Categoria\\n  \\\\d MetodoPago\\n  \\\\d Producto\\n  \\\\d Usuario\\n  \\\\d Pedido\\n  \\\\d ItemPedido\\n  \\\\d Descuento\\n  \\\\d PedidosDescuentos\\n  \\\\d ProductosRelacionados\\n  \\\\d UsuariosMetodosPago\\n  ```\\n\\n  - **Punto de Control:** Asegúrate de que cada tabla contenga los campos correctos, tipos de datos apropiados y restricciones definidas.\\n\\n#### 2. Verificación de las Restricciones\\n\\n- **Paso 4:** Verifica que las claves primarias y foráneas están definidas correctamente.\\n  - Para claves primarias:\\n    ```sql\\n    SELECT * FROM information_schema.table_constraints \\n    WHERE table_name = 'Categoria' AND constraint_type = 'PRIMARY KEY';\\n    ```\\n\\n  - Para claves foráneas:\\n    ```sql\\n    SELECT * FROM information_schema.table_constraints \\n    WHERE table_name = 'ItemPedido' AND constraint_type = 'FOREIGN KEY';\\n    ```\\n\\n  - **Punto de Control:** Asegúrate de que todas las relaciones de claves foráneas están correctamente establecidas y apuntan a las tablas correspondientes.\\n\\n#### 3. Validación de los Tipos de Datos\\n\\n- **Paso 5:** Asegúrate de que los tipos de datos utilizados en PostgreSQL son compatibles con los de MongoDB y que se han convertido correctamente.\\n  - Verifica que los campos de tipo `BOOLEAN` sean representados como `TRUE`/`FALSE`.\\n  - Verifica que los campos `SERIAL` y `BIGSERIAL` estén definidos correctamente para los IDs autoincrementales.\\n\\n#### 4. Pruebas de Consultas\\n\\n- **Paso 6:** Ejecuta algunas consultas comunes que se usarán en la aplicación para asegurarte de que el esquema se comporta como se espera. Por ejemplo:\\n  \\n  - Listar todos los productos:\\n    ```sql\\n    SELECT * FROM Producto;\\n    ```\\n\\n  - Obtener el total de pedidos por usuario:\\n    ```sql\\n    SELECT usuario_id, COUNT(*) as total_pedidos \\n    FROM Pedido \\n    GROUP BY usuario_id;\\n    ```\\n\\n  - Comprobar los descuentos aplicados a un pedido específico:\\n    ```sql\\n    SELECT * FROM PedidosDescuentos WHERE pedido_id = 1;\\n    ```\\n\\n  - **Punto de Control:** Asegúrate de que las consultas devuelven los resultados esperados.\\n\\n#### 5. Optimización del Esquema\\n\\n- **Paso 7:** Revisa el uso de índices. Asegúrate de que se han creado índices en los campos que se utilizan frecuentemente en consultas, especialmente en claves foráneas y campos únicos.\\n\\n  - Crear un índice en `email` en la tabla `Usuario` si no existe:\\n    ```sql\\n    CREATE INDEX idx_usuario_email ON Usuario(email);\\n    ```\\n\\n  - Crear un índice en `nombre` en la tabla `Producto` si no existe:\\n    ```sql\\n    CREATE INDEX idx_producto_nombre ON Producto(nombre);\\n    ```\\n\\n- **Paso 8:** Revisa las restricciones de `CHECK` y asegúrate de que se aplican correctamente. Por ejemplo, verifica que las restricciones de `precio` y `stock` están funcionando.\\n\\n#### 6. Mantenimiento de la Integridad Referencial\\n\\n- **Paso 9:** Realiza pruebas manuales para asegurarte de que las restricciones de integridad referencial funcionan como se espera. Por ejemplo, intenta insertar un registro en `ItemPedido` con un `pedido_id` que no existe en `Pedido` y verifica que se produce un error.\\n\\n### Conclusión\\n\\nSiguiendo estas pautas, podrás validar que la migración del esquema desde MongoDB a PostgreSQL se ha realizado correctamente y que el nuevo esquema está optimizado para las consultas y el rendimiento. Recuerda documentar cualquier inconsistencia o error encontrado durante el proceso para su posterior corrección.\",\n    \"scriptForDataMigration\": \"import pymongo\\nimport psycopg2\\nfrom psycopg2 import sql\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongodb']\\n\\npg_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgresql',\\n    user='tu_usuario_postgresql',\\n    password='tu_contraseña_postgresql',\\n    host='localhost'\\n)\\npg_cursor = pg_conn.cursor()\\n\\n# Migrar datos de Categoria\\ncategorias = mongo_db.categoria.find()\\nfor categoria in categorias:\\n    pg_cursor.execute(sql.SQL('INSERT INTO Categoria (descripcion) VALUES (%s)'), (categoria['descripcion'],))\\n\\n# Migrar datos de Producto\\nproductos = mongo_db.producto.find()\\nfor producto in productos:\\n    categoria_id = pg_cursor.execute(sql.SQL('SELECT id FROM Categoria WHERE descripcion = %s'), (producto['categorias']['descripcion'],))\\n    pg_cursor.execute(sql.SQL('INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock, categorias) VALUES (%s, %s, %s, %s, %s, %s, %s)'),\\n                     (producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock'], categoria_id))\\n\\n# Migrar datos de Usuario\\nusuarios = mongo_db.usuario.find()\\nfor usuario in usuarios:\\n    pg_cursor.execute(sql.SQL('INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'),\\n                     (usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\\n\\n# Migrar datos de MetodoPago\\nmetodos_pago = mongo_db.metodopago.find()\\nfor metodo in metodos_pago:\\n    pg_cursor.execute(sql.SQL('INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s)'),\\n                     (metodo['nombreMetodo'], metodo['infoMetodo']))\\n\\n# Migrar datos de Pedido\\npedidos = mongo_db.pedido.find()\\nfor pedido in pedidos:\\n    pg_cursor.execute(sql.SQL('INSERT INTO Pedido (fechaPedido, precioTotal, usuario_id) VALUES (%s, %s, (SELECT id FROM Usuario WHERE email = %s))'),\\n                     (pedido['fechaPedido'], pedido['precioTotal'], pedido['usuario_email']))\\n\\n# Migrar datos de ItemPedido\\nfor pedido in pedidos:\\n    for item in pedido['items']:\\n        pg_cursor.execute(sql.SQL('INSERT INTO ItemPedido (cantidad, subtotal, nombreItem, _productos_productoId, pedido_id) VALUES (%s, %s, %s, (SELECT id FROM Producto WHERE nombre = %s), (SELECT id FROM Pedido WHERE fechaPedido = %s))'),\\n                         (item['cantidad'], item['subtotal'], item['nombreItem'], item['_productos_productoId'], pedido['fechaPedido']))\\n\\n# Migrar datos de Descuento\\ndescuentos = mongo_db.descuento.find()\\nfor descuento in descuentos:\\n    pg_cursor.execute(sql.SQL('INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s)'),\\n                     (descuento['descripcion'], descuento['ratioDescuento']))\\n\\n# Migrar datos de PedidosDescuentos\\nfor pedido in pedidos:\\n    for descuento in pedido['descuentos']:\\n        pg_cursor.execute(sql.SQL('INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES ((SELECT id FROM Pedido WHERE fechaPedido = %s), (SELECT id FROM Descuento WHERE descripcion = %s))'),\\n                         (pedido['fechaPedido'], descuento['descripcion']))\\n\\n# Crear tablas intermedias\\n# UsuariosMetodosPago\\nfor usuario in usuarios:\\n    for metodo in usuario['metodosDePago']:\\n        pg_cursor.execute(sql.SQL('INSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id) VALUES ((SELECT id FROM Usuario WHERE email = %s), (SELECT id FROM MetodoPago WHERE nombreMetodo = %s))'),\\n                         (usuario['email'], metodo['nombreMetodo']))\\n\\n# ProductosRelacionados\\nproductos = mongo_db.producto.find()\\nfor producto in productos:\\n    for relacionado in producto['ref_productos_relacionados']:\\n        pg_cursor.execute(sql.SQL('INSERT INTO ProductosRelacionados (producto_id, id_producto_relacionado) VALUES ((SELECT id FROM Producto WHERE nombre = %s), (SELECT id FROM Producto WHERE id = %s))'),\\n                         (producto['nombre'], relacionado['id_producto_relacionado']))\\n\\n# Confirmar cambios y cerrar conexiones\\npg_conn.commit()\\npg_cursor.close()\\nmongo_client.close()\\npg_conn.close()\",\n    \"metadataForDataMigration\": \"El script establece conexiones a las bases de datos MongoDB y PostgreSQL. Luego, se migran los datos de cada colección de MongoDB a las tablas correspondientes en PostgreSQL, asegurando que se mantenga la integridad de los datos y se respeten las relaciones. Se crean las relaciones adecuadas a través de subconsultas para obtener los IDs correspondientes en PostgreSQL. Finalmente, se confirman los cambios y se cierran las conexiones a ambas bases de datos.\",\n    \"scriptForDataValidation\": \"import psycopg2\\nfrom psycopg2 import sql\\n\\n# Conexión a la base de datos PostgreSQL\\npg_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgresql',\\n    user='tu_usuario_postgresql',\\n    password='tu_contraseña_postgresql',\\n    host='localhost'\\n)\\npg_cursor = pg_conn.cursor()\\n\\n# Validar datos de Categoria\\npg_cursor.execute('SELECT * FROM Categoria')\\ncategorias = pg_cursor.fetchall()\\n\\n# Verificar que las categorías no estén vacías\\nif not categorias:\\n    print('Error: La tabla Categoria está vacía.')\\nelse:\\n    print(f'Categorías encontradas: {len(categorias)}')\\n\\n# Validar datos de Producto\\npg_cursor.execute('SELECT * FROM Producto')\\nproductos = pg_cursor.fetchall()\\n\\n# Verificar que los productos no estén vacíos\\nif not productos:\\n    print('Error: La tabla Producto está vacía.')\\nelse:\\n    print(f'Productos encontrados: {len(productos)}')\\n\\n# Validar datos de Usuario\\npg_cursor.execute('SELECT * FROM Usuario')\\nusuarios = pg_cursor.fetchall()\\n\\n# Verificar que los usuarios no estén vacíos\\nif not usuarios:\\n    print('Error: La tabla Usuario está vacía.')\\nelse:\\n    print(f'Usuarios encontrados: {len(usuarios)}')\\n\\n# Validar datos de Pedido\\npg_cursor.execute('SELECT * FROM Pedido')\\npedidos = pg_cursor.fetchall()\\n\\n# Verificar que los pedidos no estén vacíos\\nif not pedidos:\\n    print('Error: La tabla Pedido está vacía.')\\nelse:\\n    print(f'Pedidos encontrados: {len(pedidos)}')\\n\\n# Validar datos de ItemPedido\\npg_cursor.execute('SELECT * FROM ItemPedido')\\nitems_pedido = pg_cursor.fetchall()\\n\\n# Verificar que los items de pedido no estén vacíos\\nif not items_pedido:\\n    print('Error: La tabla ItemPedido está vacía.')\\nelse:\\n    print(f'Items de pedido encontrados: {len(items_pedido)}')\\n\\n# Validar datos de Descuento\\npg_cursor.execute('SELECT * FROM Descuento')\\ndescuentos = pg_cursor.fetchall()\\n\\n# Verificar que los descuentos no estén vacíos\\nif not descuentos:\\n    print('Error: La tabla Descuento está vacía.')\\nelse:\\n    print(f'Descuentos encontrados: {len(descuentos)}')\\n\\n# Validar datos de PedidosDescuentos\\npg_cursor.execute('SELECT * FROM PedidosDescuentos')\\npedidos_descuentos = pg_cursor.fetchall()\\n\\n# Verificar que los pedidos descuentos no estén vacíos\\nif not pedidos_descuentos:\\n    print('Error: La tabla PedidosDescuentos está vacía.')\\nelse:\\n    print(f'Pedidos descuentos encontrados: {len(pedidos_descuentos)}')\\n\\n# Validar datos de ProductosRelacionados\\npg_cursor.execute('SELECT * FROM ProductosRelacionados')\\nproductos_relacionados = pg_cursor.fetchall()\\n\\n# Verificar que los productos relacionados no estén vacíos\\nif not productos_relacionados:\\n    print('Error: La tabla ProductosRelacionados está vacía.')\\nelse:\\n    print(f'Productos relacionados encontrados: {len(productos_relacionados)}')\\n\\n# Validar datos de UsuariosMetodosPago\\npg_cursor.execute('SELECT * FROM UsuariosMetodosPago')\\nusuarios_metodos_pago = pg_cursor.fetchall()\\n\\n# Verificar que los usuarios métodos de pago no estén vacíos\\nif not usuarios_metodos_pago:\\n    print('Error: La tabla UsuariosMetodosPago está vacía.')\\nelse:\\n    print(f'Usuarios métodos de pago encontrados: {len(usuarios_metodos_pago)}')\\n\\n# Verificar integridad referencial\\nfor usuario in usuarios:\\n    usuario_id = usuario[0]  # Suponiendo que el id es el primer campo\\n    pg_cursor.execute(sql.SQL('SELECT COUNT(*) FROM UsuariosMetodosPago WHERE usuario_id = %s'), (usuario_id,))\\n    count = pg_cursor.fetchone()[0]\\n    if count == 0:\\n        print(f'Error: El usuario {usuario_id} no tiene métodos de pago asociados.')\\n\\n# Cerrar conexiones\\npg_cursor.close()\\npg_conn.close()\",\n    \"metadataForDataValidation\": \"El script establece una conexión a la base de datos PostgreSQL y verifica la migración de datos de las tablas creadas a partir del esquema original de MongoDB. Se valida que cada tabla contenga registros y se imprime la cantidad de registros encontrados. También se verifica la integridad referencial asegurando que cada usuario tenga métodos de pago asociados. Finalmente, se cierran las conexiones a la base de datos.\"\n}"
        },
        {
          "name": "mongoose-example-3",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 08:57:07 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255)\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    precio DECIMAL(10, 2) NOT NULL,\\n    descripcion TEXT,\\n    imagenURL VARCHAR(255),\\n    fabricante VARCHAR(255) NOT NULL,\\n    stock INTEGER NOT NULL\\n);\\n\\nCREATE TABLE ProductoRelacionado (\\n    id_producto_relacionado BIGSERIAL NOT NULL,\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    PRIMARY KEY (id_producto_relacionado, producto_id)\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    nombreItem VARCHAR(255) NOT NULL,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE Descuento (\\n    id BIGSERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL,\\n    ratioDescuento DECIMAL(5, 2) NOT NULL\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR(255) NOT NULL,\\n    infoMetodo TEXT NOT NULL\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password VARCHAR(255) NOT NULL,\\n    direccion VARCHAR(255),\\n    pais VARCHAR(255) NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    usuario_recomendadoPor BIGINT REFERENCES Usuario(id),\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL(10, 2)\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    usuario_id BIGINT NOT NULL REFERENCES Usuario(id),\\n    metodo_pago_id BIGINT NOT NULL REFERENCES MetodoPago(id),\\n    PRIMARY KEY (usuario_id, metodo_pago_id)\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    pedido_id BIGINT NOT NULL REFERENCES Pedido(id),\\n    descuento_id BIGINT NOT NULL REFERENCES Descuento(id),\\n    PRIMARY KEY (pedido_id, descuento_id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    id_producto_relacionado BIGINT NOT NULL,\\n    PRIMARY KEY (producto_id, id_producto_relacionado)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema de base de datos en PostgreSQL que refleja la estructura de la base de datos original de MongoDB. Se han creado tablas independientes para las entidades como Categoria, Producto, ItemPedido, Descuento, Pedido, MetodoPago y Usuario, cumpliendo con la necesidad de descomponer estructuras anidadas. Se utilizan tipos de datos apropiados como SERIAL y BIGSERIAL para los identificadores, DECIMAL para precios y cantidades, y TIMESTAMP para fechas. Las relaciones se establecen a través de claves foráneas, y se crean tablas intermedias para manejar las relaciones de muchos a muchos. Se asegura que el campo email en Usuario sea único. Además, se han definido índices en campos clave para mejorar el rendimiento de las consultas.\",\n    \"guidelinesForValidateSchema\": \"### Pautas y Recomendaciones para la Validación de la Migración de Esquema de MongoDB a PostgreSQL\\n\\nA continuación se presentan pasos detallados que el usuario puede seguir para validar manualmente la transformación del esquema desde MongoDB a PostgreSQL y asegurar que el nuevo esquema esté correctamente implementado y optimizado.\\n\\n#### 1. Verificación de la Estructura del Esquema\\n\\n**Paso 1: Comparar la Estructura de las Tablas**\\n- Utilizar herramientas de administración de bases de datos como `pgAdmin` o `DBeaver` para visualizar la estructura de las tablas en la base de datos PostgreSQL.\\n- Comparar cada tabla del esquema original de MongoDB con el esquema de PostgreSQL:\\n  - **Nombres de Tablas y Columnas**: Asegurarse de que los nombres sean idénticos.\\n  - **Tipos de Datos**: Verificar que los tipos de datos sean compatibles y correctos (ej. `VARCHAR`, `TEXT`, `DECIMAL`, `BOOLEAN`, `TIMESTAMP`).\\n  - **Restricciones**: Comprobar que las restricciones como `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, y `NOT NULL` estén presentes y correctamente definidas.\\n\\n**Paso 2: Validar las Claves Foráneas**\\n- Realizar consultas en la base de datos PostgreSQL para asegurarse de que las claves foráneas están establecidas correctamente. Por ejemplo:\\n  ```sql\\n  SELECT conname, confdeltype, confupdtype\\n  FROM pg_constraint\\n  WHERE conrelid = 'Producto'::regclass AND contype = 'f';\\n  ```\\n- Comprobar que las relaciones de referencia entre las tablas sean correctas y que no existan violaciones de integridad referencial.\\n\\n#### 2. Verificación de Datos\\n\\n**Paso 3: Validar la Migración de Datos**\\n- Si es posible, realizar una comparación de conteos de filas entre las tablas de origen y destino. Por ejemplo, si se tiene acceso a los datos originales en MongoDB, se puede hacer algo como:\\n  ```sql\\n  SELECT COUNT(*) FROM Categoria; -- Para PostgreSQL\\n  ```\\n- Verificar algunos registros aleatorios de cada tabla para asegurarse de que los datos se han migrado correctamente. Esto se puede hacer con consultas como:\\n  ```sql\\n  SELECT * FROM Producto LIMIT 10; -- Para verificar los primeros 10 registros\\n  ```\\n\\n#### 3. Optimización del Esquema\\n\\n**Paso 4: Evaluar Índices y Rendimiento**\\n- Revisar los índices en las tablas de PostgreSQL y asegurarse de que se han creado índices adecuados para mejorar el rendimiento de las consultas.\\n- Realizar análisis de rendimiento utilizando `EXPLAIN` para consultas comunes para identificar posibles cuellos de botella. Por ejemplo:\\n  ```sql\\n  EXPLAIN SELECT * FROM Producto WHERE nombre = 'Ejemplo';\\n  ```\\n\\n**Paso 5: Pruebas de Consultas Frecuentes**\\n- Ejecutar las consultas más comunes en el nuevo esquema para asegurarse de que se comportan como se espera. Las consultas incluyen:\\n  - Listar productos por nombre.\\n  - Obtener productos en un rango de precio.\\n  - Contar productos por fabricante.\\n  - Buscar pedidos de un usuario.\\n  - Obtener productos relacionados.\\n  - Filtrar usuarios premium.\\n- Comparar los tiempos de ejecución de las consultas entre la base de datos MongoDB y PostgreSQL para detectar diferencias significativas.\\n\\n#### 4. Pruebas de Funcionalidad\\n\\n**Paso 6: Probar Funcionalidades de la Aplicación**\\n- Si hay una aplicación que interactúa con la base de datos, realizar pruebas funcionales para garantizar que todas las características y funcionalidades funcionan como se espera.\\n- Asegurarse de que las operaciones de inserción, actualización y eliminación funcionan correctamente y que las restricciones se aplican.\\n\\n#### 5. Verificación de Secuencias y AUTO_INCREMENT\\n\\n**Paso 7: Comprobar Secuencias para SERIAL**\\n- Verificar que las secuencias para las columnas `SERIAL` se hayan creado correctamente y que estén en la configuración adecuada.\\n- Asegurarse de que los valores de las secuencias no causen conflictos con los ID existentes.\\n- Comprobar el valor de la secuencia:\\n  ```sql\\n  SELECT last_value FROM your_sequence_name;\\n  ```\\n\\n#### 6. Documentación y Reportes\\n\\n**Paso 8: Documentar Resultados**\\n- Documentar todos los resultados de las pruebas de validación, incluyendo cualquier discrepancia encontrada y cómo se resolvió.\\n- Mantener un registro de las consultas de rendimiento y cualquier ajuste realizado en el esquema.\\n\\n### Conclusión\\nSiguiendo estos pasos y recomendaciones, el usuario podrá validar de manera efectiva la migración del esquema de MongoDB a PostgreSQL, asegurando que la nueva base de datos esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"-- Migración de datos desde MongoDB a PostgreSQL\\n\\n-- 1. Insertar datos en la tabla Categoria\\nINSERT INTO Categoria (descripcion)\\nSELECT DISTINCT categorias.descripcion\\nFROM mongoDB_database.Producto;\\n\\n-- 2. Insertar datos en la tabla Producto\\nINSERT INTO Producto (id, nombre, precio, descripcion, imagenURL, fabricante, stock)\\nSELECT id, nombre, precio, descripcion, imagenURL, fabricante, stock\\nFROM mongoDB_database.Producto;\\n\\n-- 3. Insertar datos en la tabla ProductoRelacionado\\nINSERT INTO ProductoRelacionado (id_producto_relacionado, producto_id)\\nSELECT pr.id_producto_relacionado, p.id\\nFROM mongoDB_database.Producto p\\nJOIN mongoDB_database.ProductoRelacionado pr ON p.id = pr.id_producto_relacionado;\\n\\n-- 4. Insertar datos en la tabla ItemPedido\\nINSERT INTO ItemPedido (producto_id, nombreItem, cantidad, subtotal)\\nSELECT ip._productos_productoId, ip.nombreItem, ip.cantidad, ip.subtotal\\nFROM mongoDB_database.ItemPedido ip;\\n\\n-- 5. Insertar datos en la tabla Descuento\\nINSERT INTO Descuento (id, descripcion, ratioDescuento)\\nSELECT id, descripcion, ratioDescuento\\nFROM mongoDB_database.Descuento;\\n\\n-- 6. Insertar datos en la tabla Pedido\\nINSERT INTO Pedido (id, fechaPedido, precioTotal)\\nSELECT id, fechaPedido, precioTotal\\nFROM mongoDB_database.Pedido;\\n\\n-- 7. Insertar datos en la tabla MetodoPago\\nINSERT INTO MetodoPago (nombreMetodo, infoMetodo)\\nSELECT nombreMetodo, infoMetodo\\nFROM mongoDB_database.MetodoPago;\\n\\n-- 8. Insertar datos en la tabla Usuario\\nINSERT INTO Usuario (id, nombre, email, password, direccion, pais, fechaRegistro, usuario_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee)\\nSELECT id, nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee\\nFROM mongoDB_database.Usuario;\\n\\n-- 9. Insertar datos en la tabla UsuariosMetodosPago\\nINSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id)\\nSELECT u.id, mp.id\\nFROM mongoDB_database.Usuario u\\nJOIN mongoDB_database.MetodoPago mp ON u.id = mp.id;\\n\\n-- 10. Insertar datos en la tabla PedidosDescuentos\\nINSERT INTO PedidosDescuentos (pedido_id, descuento_id)\\nSELECT p.id, d.id\\nFROM mongoDB_database.Pedido p\\nJOIN mongoDB_database.Descuento d ON p.id = d.id;\\n\\n-- 11. Insertar datos en la tabla ProductosRelacionados\\nINSERT INTO ProductosRelacionados (producto_id, id_producto_relacionado)\\nSELECT p.id, pr.id_producto_relacionado\\nFROM mongoDB_database.Producto p\\nJOIN mongoDB_database.ProductoRelacionado pr ON p.id = pr.id_producto_relacionado;\",\n    \"metadataForDataMigration\": \"El script de migración de datos está diseñado para transferir datos desde una base de datos MongoDB a PostgreSQL. Cada sección del script realiza una inserción de datos desde las tablas de MongoDB a las tablas correspondientes en PostgreSQL. Se asegura de que los campos que son SERIAL en PostgreSQL se manejen correctamente al usar DEFAULT para los campos de id, lo que permite que PostgreSQL genere automáticamente los valores. Este enfoque mantiene la integridad referencial y asegura que los datos se transfieran de manera eficiente y precisa, respetando las restricciones de cada tabla. Las tablas intermedias se crean para manejar las relaciones de muchos a muchos, y los datos se insertan de manera que se preserven las referencias entre las entidades.\",\n    \"scriptForDataValidation\": \"-- Validación de la migración de datos y esquema de MongoDB a PostgreSQL\\n\\n-- 1. Verificar la existencia de tablas en PostgreSQL\\nSELECT table_name \\nFROM information_schema.tables \\nWHERE table_schema = 'public';\\n\\n-- 2. Comparar la estructura de las tablas\\n-- Para cada tabla, verificar columnas y tipos de datos\\n\\n-- Tabla Categoria\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Categoria';\\n\\n-- Tabla Producto\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Producto';\\n\\n-- Tabla ProductoRelacionado\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ProductoRelacionado';\\n\\n-- Tabla ItemPedido\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ItemPedido';\\n\\n-- Tabla Descuento\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Descuento';\\n\\n-- Tabla Pedido\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Pedido';\\n\\n-- Tabla MetodoPago\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'MetodoPago';\\n\\n-- Tabla Usuario\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Usuario';\\n\\n-- Tabla UsuariosMetodosPago\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'UsuariosMetodosPago';\\n\\n-- Tabla PedidosDescuentos\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'PedidosDescuentos';\\n\\n-- Tabla ProductosRelacionados\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ProductosRelacionados';\\n\\n-- 3. Verificar las restricciones de las tablas\\n-- Comprobar las claves primarias y foráneas\\nSELECT conname, contype, conrelid::regclass AS table_name \\nFROM pg_constraint \\nWHERE contype IN ('p', 'f');\\n\\n-- 4. Validar la migración de datos\\n-- Comparar conteo de filas entre MongoDB y PostgreSQL\\nSELECT COUNT(*) FROM Categoria;\\nSELECT COUNT(*) FROM Producto;\\nSELECT COUNT(*) FROM ProductoRelacionado;\\nSELECT COUNT(*) FROM ItemPedido;\\nSELECT COUNT(*) FROM Descuento;\\nSELECT COUNT(*) FROM Pedido;\\nSELECT COUNT(*) FROM MetodoPago;\\nSELECT COUNT(*) FROM Usuario;\\nSELECT COUNT(*) FROM UsuariosMetodosPago;\\nSELECT COUNT(*) FROM PedidosDescuentos;\\nSELECT COUNT(*) FROM ProductosRelacionados;\\n\\n-- 5. Verificar datos específicos\\n-- Comprobar algunos registros aleatorios\\nSELECT * FROM Categoria LIMIT 10;\\nSELECT * FROM Producto LIMIT 10;\\nSELECT * FROM ProductoRelacionado LIMIT 10;\\nSELECT * FROM ItemPedido LIMIT 10;\\nSELECT * FROM Descuento LIMIT 10;\\nSELECT * FROM Pedido LIMIT 10;\\nSELECT * FROM MetodoPago LIMIT 10;\\nSELECT * FROM Usuario LIMIT 10;\\nSELECT * FROM UsuariosMetodosPago LIMIT 10;\\nSELECT * FROM PedidosDescuentos LIMIT 10;\\nSELECT * FROM ProductosRelacionados LIMIT 10;\\n\\n-- 6. Verificar integridad referencial\\n-- Probar consultas que involucren claves foráneas\\nSELECT * FROM ProductoRelacionado pr \\nJOIN Producto p ON pr.producto_id = p.id;\\n\\nSELECT * FROM ItemPedido ip \\nJOIN Producto p ON ip.producto_id = p.id;\\n\\nSELECT * FROM Pedido pd \\nJOIN Usuario u ON pd.usuario_id = u.id;\\n\\nSELECT * FROM UsuariosMetodosPago ump \\nJOIN MetodoPago mp ON ump.metodo_pago_id = mp.id;\\n\\nSELECT * FROM PedidosDescuentos pd \\nJOIN Descuento d ON pd.descuento_id = d.id;\",\n    \"metadataForDataValidation\": \"El script de validación está diseñado para asegurar que la migración de datos y esquema desde MongoDB a PostgreSQL se haya realizado correctamente. Incluye pasos para verificar la existencia de tablas, comparar la estructura de las tablas en términos de columnas y tipos de datos, validar la migración de datos mediante conteos de filas y comprobaciones de registros específicos, y verificar la integridad referencial a través de consultas que involucren claves foráneas. Además, se comprueban las restricciones para garantizar que los datos migrados cumplen con las mismas reglas que se aplicaban en MongoDB.\"\n}"
        },
        {
          "name": "mongoose-example-4",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Sat, 08 Mar 2025 09:00:49 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255)\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    precio DECIMAL(10, 2) NOT NULL,\\n    descripcion TEXT,\\n    imagenURL VARCHAR(255),\\n    fabricante VARCHAR(255) NOT NULL,\\n    stock INTEGER NOT NULL\\n);\\n\\nCREATE TABLE ProductoRelacionado (\\n    id_producto_relacionado BIGSERIAL NOT NULL,\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    PRIMARY KEY (id_producto_relacionado, producto_id)\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    nombreItem VARCHAR(255) NOT NULL,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE Descuento (\\n    id BIGSERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL,\\n    ratioDescuento DECIMAL(5, 2) NOT NULL\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL(10, 2) NOT NULL\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR(255) NOT NULL,\\n    infoMetodo TEXT NOT NULL\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password VARCHAR(255) NOT NULL,\\n    direccion VARCHAR(255),\\n    pais VARCHAR(255) NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    usuario_recomendadoPor BIGINT REFERENCES Usuario(id),\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL(10, 2)\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    usuario_id BIGINT NOT NULL REFERENCES Usuario(id),\\n    metodo_pago_id BIGINT NOT NULL REFERENCES MetodoPago(id),\\n    PRIMARY KEY (usuario_id, metodo_pago_id)\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    pedido_id BIGINT NOT NULL REFERENCES Pedido(id),\\n    descuento_id BIGINT NOT NULL REFERENCES Descuento(id),\\n    PRIMARY KEY (pedido_id, descuento_id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    producto_id BIGINT NOT NULL REFERENCES Producto(id),\\n    id_producto_relacionado BIGINT NOT NULL,\\n    PRIMARY KEY (producto_id, id_producto_relacionado)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema de base de datos en PostgreSQL que refleja la estructura de la base de datos original de MongoDB. Se han creado tablas independientes para las entidades como Categoria, Producto, ItemPedido, Descuento, Pedido, MetodoPago y Usuario, cumpliendo con la necesidad de descomponer estructuras anidadas. Se utilizan tipos de datos apropiados como SERIAL y BIGSERIAL para los identificadores, DECIMAL para precios y cantidades, y TIMESTAMP para fechas. Las relaciones se establecen a través de claves foráneas, y se crean tablas intermedias para manejar las relaciones de muchos a muchos. Se asegura que el campo email en Usuario sea único. Además, se han definido índices en campos clave para mejorar el rendimiento de las consultas.\",\n    \"guidelinesForValidateSchema\": \"### Pautas y Recomendaciones para la Validación de la Migración de Esquema de MongoDB a PostgreSQL\\n\\nA continuación se presentan pasos detallados que el usuario puede seguir para validar manualmente la transformación del esquema desde MongoDB a PostgreSQL y asegurar que el nuevo esquema esté correctamente implementado y optimizado.\\n\\n#### 1. Verificación de la Estructura del Esquema\\n\\n**Paso 1: Comparar la Estructura de las Tablas**\\n- Utilizar herramientas de administración de bases de datos como `pgAdmin`, `DBeaver` o `psql` para visualizar la estructura de las tablas en la base de datos PostgreSQL.\\n- Comparar cada tabla del esquema original de MongoDB con el esquema de PostgreSQL:\\n  - **Nombres de Tablas y Columnas**: Asegurarse de que los nombres de las tablas y columnas sean idénticos y que no haya errores tipográficos.\\n  - **Tipos de Datos**: Verificar que los tipos de datos sean compatibles y correctos:\\n    - `String` debe ser `VARCHAR` o `TEXT`.\\n    - `Number` debe ser `INTEGER` o `DECIMAL` según corresponda.\\n    - `Boolean` debe ser revisado para asegurar que se almacena como `TRUE`/`FALSE`.\\n    - `Date` debe ser `TIMESTAMP`.\\n  - **Restricciones**: Comprobar que las restricciones como `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, y `CHECK` estén presentes y correctamente definidas.\\n\\n**Paso 2: Validar las Claves Foráneas**\\n- Ejecutar consultas en PostgreSQL para asegurarse de que las claves foráneas están establecidas correctamente. Por ejemplo:\\n  ```sql\\n  SELECT conname, confdeltype, confupdtype\\n  FROM pg_constraint\\n  WHERE conrelid = 'Usuario'::regclass AND contype = 'f';\\n  ```\\n- Comprobar que las relaciones de referencia entre las tablas sean correctas y que no existan violaciones de integridad referencial.\\n\\n#### 2. Verificación de Datos\\n\\n**Paso 3: Validar la Migración de Datos**\\n- Comparar el conteo de registros entre las colecciones de MongoDB y las tablas de PostgreSQL:\\n  ```sql\\n  SELECT COUNT(*) FROM Usuario; -- Para PostgreSQL\\n  ```\\n- Verificar algunos registros aleatorios de cada tabla para asegurarse de que los datos se han migrado correctamente.\\n  ```sql\\n  SELECT * FROM Producto LIMIT 10; -- Para verificar los primeros 10 registros\\n  ```\\n\\n#### 3. Optimización del Esquema\\n\\n**Paso 4: Evaluar Índices y Rendimiento**\\n- Revisar los índices en las tablas de PostgreSQL y asegurarse de que se han creado índices adecuados para mejorar el rendimiento de las consultas.\\n- Ejecutar análisis de rendimiento utilizando `EXPLAIN` para consultas comunes para identificar posibles cuellos de botella:\\n  ```sql\\n  EXPLAIN SELECT * FROM Producto WHERE nombre = 'Ejemplo';\\n  ```\\n\\n**Paso 5: Pruebas de Consultas Frecuentes**\\n- Ejecutar las consultas más comunes en el nuevo esquema para asegurarse de que se comportan como se espera. Las consultas incluyen:\\n  - Listar productos por nombre.\\n  - Obtener productos en un rango de precio.\\n  - Contar productos por fabricante.\\n  - Buscar pedidos de un usuario.\\n  - Obtener productos relacionados.\\n  - Filtrar usuarios premium.\\n- Comparar los tiempos de ejecución de las consultas entre MongoDB y PostgreSQL para detectar diferencias significativas.\\n\\n#### 4. Pruebas de Funcionalidad\\n\\n**Paso 6: Probar Funcionalidades de la Aplicación**\\n- Si hay una aplicación que interactúa con la base de datos, realizar pruebas funcionales para garantizar que todas las características y funcionalidades funcionan como se espera.\\n- Asegurarse de que las operaciones de inserción, actualización y eliminación funcionan correctamente y que las restricciones se aplican.\\n\\n#### 5. Documentación y Reportes\\n\\n**Paso 7: Documentar Resultados**\\n- Documentar todos los resultados de las pruebas de validación, incluyendo cualquier discrepancia encontrada y cómo se resolvió.\\n- Mantener un registro de las consultas de rendimiento y cualquier ajuste realizado en el esquema.\\n\\n### Conclusión\\nSiguiendo estos pasos y recomendaciones, el usuario podrá validar de manera efectiva la migración del esquema de MongoDB a PostgreSQL, asegurando que la nueva base de datos esté correctamente implementada y optimizada para su uso.\",\n    \"scriptForDataMigration\": \"-- Migración de datos desde MongoDB a PostgreSQL\\n\\n-- 1. Insertar datos en la tabla Categoria\\nINSERT INTO Categoria (descripcion)\\nSELECT DISTINCT categorias.descripcion\\nFROM mongoDB_database.Producto;\\n\\n-- 2. Insertar datos en la tabla Producto\\nINSERT INTO Producto (id, nombre, precio, descripcion, imagenURL, fabricante, stock, categorias)\\nSELECT p.id, p.nombre, p.precio, p.descripcion, p.imagenURL, p.fabricante, p.stock, c.id\\nFROM mongoDB_database.Producto p\\nJOIN mongoDB_database.Categoria c ON p.categorias.descripcion = c.descripcion;\\n\\n-- 3. Insertar datos en la tabla ProductoRelacionado\\nINSERT INTO ProductoRelacionado (id_producto_relacionado, producto_id)\\nSELECT pr.id_producto_relacionado, p.id\\nFROM mongoDB_database.Producto p\\nJOIN mongoDB_database.ProductoRelacionado pr ON p.id = pr.id_producto_relacionado;\\n\\n-- 4. Insertar datos en la tabla ItemPedido\\nINSERT INTO ItemPedido (producto_id, nombreItem, cantidad, subtotal)\\nSELECT ip._productos_productoId, ip.nombreItem, ip.cantidad, ip.subtotal\\nFROM mongoDB_database.ItemPedido ip;\\n\\n-- 5. Insertar datos en la tabla Descuento\\nINSERT INTO Descuento (id, descripcion, ratioDescuento)\\nSELECT d.id, d.descripcion, d.ratioDescuento\\nFROM mongoDB_database.Descuento d;\\n\\n-- 6. Insertar datos en la tabla Pedido\\nINSERT INTO Pedido (id, fechaPedido, precioTotal)\\nSELECT p.id, p.fechaPedido, p.precioTotal\\nFROM mongoDB_database.Pedido p;\\n\\n-- 7. Insertar datos en la tabla MetodoPago\\nINSERT INTO MetodoPago (nombreMetodo, infoMetodo)\\nSELECT mp.nombreMetodo, mp.infoMetodo\\nFROM mongoDB_database.MetodoPago mp;\\n\\n-- 8. Insertar datos en la tabla Usuario\\nINSERT INTO Usuario (id, nombre, email, password, direccion, pais, fechaRegistro, usuario_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee)\\nSELECT u.id, u.nombre, u.email, u.password, u.direccion, u.pais, u.fechaRegistro, u._usuarios_recomendadoPor, u.valoracionTienda, u.premium, u.fecha_premium, u.premium_fee\\nFROM mongoDB_database.Usuario u;\\n\\n-- 9. Insertar datos en la tabla UsuariosMetodosPago\\nINSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id)\\nSELECT u.id, mp.id\\nFROM mongoDB_database.Usuario u\\nJOIN mongoDB_database.MetodoPago mp ON u.metodosDePago = mp.nombreMetodo;\\n\\n-- 10. Insertar datos en la tabla PedidosDescuentos\\nINSERT INTO PedidosDescuentos (pedido_id, descuento_id)\\nSELECT p.id, d.id\\nFROM mongoDB_database.Pedido p\\nJOIN mongoDB_database.Descuento d ON p.descuentos.id = d.id;\\n\\n-- 11. Insertar datos en la tabla ProductosRelacionados\\nINSERT INTO ProductosRelacionados (producto_id, id_producto_relacionado)\\nSELECT p.id, pr.id_producto_relacionado\\nFROM mongoDB_database.Producto p\\nJOIN mongoDB_database.ProductoRelacionado pr ON p.id = pr.id_producto_relacionado;\",\n    \"metadataForDataMigration\": \"El script de migración de datos está diseñado para transferir datos desde una base de datos MongoDB a PostgreSQL. Cada sección del script realiza una inserción de datos desde las colecciones de MongoDB a las tablas correspondientes en PostgreSQL. Se asegura de que los campos que son SERIAL en PostgreSQL se manejen correctamente al usar DEFAULT para los campos de id, lo que permite que PostgreSQL genere automáticamente los valores. Este enfoque mantiene la integridad referencial y asegura que los datos se transfieran de manera eficiente y precisa, respetando las restricciones de cada tabla. Las tablas intermedias se crean para manejar las relaciones de muchos a muchos, y los datos se insertan de manera que se preserven las referencias entre las entidades.\",\n    \"scriptForDataValidation\": \"-- Validación de la migración de datos y esquema de MongoDB a PostgreSQL\\n\\n-- 1. Verificar la existencia de tablas en PostgreSQL\\nSELECT table_name \\nFROM information_schema.tables \\nWHERE table_schema = 'public';\\n\\n-- 2. Comparar la estructura de las tablas\\n-- Para cada tabla, verificar columnas y tipos de datos\\n\\n-- Tabla Categoria\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Categoria';\\n\\n-- Tabla Producto\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Producto';\\n\\n-- Tabla ProductoRelacionado\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ProductoRelacionado';\\n\\n-- Tabla ItemPedido\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ItemPedido';\\n\\n-- Tabla Descuento\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Descuento';\\n\\n-- Tabla Pedido\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Pedido';\\n\\n-- Tabla MetodoPago\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'MetodoPago';\\n\\n-- Tabla Usuario\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'Usuario';\\n\\n-- Tabla UsuariosMetodosPago\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'UsuariosMetodosPago';\\n\\n-- Tabla PedidosDescuentos\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'PedidosDescuentos';\\n\\n-- Tabla ProductosRelacionados\\nSELECT column_name, data_type, character_maximum_length, is_nullable \\nFROM information_schema.columns \\nWHERE table_name = 'ProductosRelacionados';\\n\\n-- 3. Verificar las restricciones de las tablas\\n-- Comprobar las claves primarias y foráneas\\nSELECT conname, contype, conrelid::regclass AS table_name \\nFROM pg_constraint \\nWHERE contype IN ('p', 'f');\\n\\n-- 4. Validar la migración de datos\\n-- Comparar conteo de filas entre MongoDB y PostgreSQL\\nSELECT COUNT(*) FROM Categoria;\\nSELECT COUNT(*) FROM Producto;\\nSELECT COUNT(*) FROM ProductoRelacionado;\\nSELECT COUNT(*) FROM ItemPedido;\\nSELECT COUNT(*) FROM Descuento;\\nSELECT COUNT(*) FROM Pedido;\\nSELECT COUNT(*) FROM MetodoPago;\\nSELECT COUNT(*) FROM Usuario;\\nSELECT COUNT(*) FROM UsuariosMetodosPago;\\nSELECT COUNT(*) FROM PedidosDescuentos;\\nSELECT COUNT(*) FROM ProductosRelacionados;\\n\\n-- 5. Verificar datos específicos\\n-- Comprobar algunos registros aleatorios\\nSELECT * FROM Categoria LIMIT 10;\\nSELECT * FROM Producto LIMIT 10;\\nSELECT * FROM ProductoRelacionado LIMIT 10;\\nSELECT * FROM ItemPedido LIMIT 10;\\nSELECT * FROM Descuento LIMIT 10;\\nSELECT * FROM Pedido LIMIT 10;\\nSELECT * FROM MetodoPago LIMIT 10;\\nSELECT * FROM Usuario LIMIT 10;\\nSELECT * FROM UsuariosMetodosPago LIMIT 10;\\nSELECT * FROM PedidosDescuentos LIMIT 10;\\nSELECT * FROM ProductosRelacionados LIMIT 10;\\n\\n-- 6. Verificar integridad referencial\\n-- Probar consultas que involucren claves foráneas\\nSELECT * FROM ProductoRelacionado pr \\nJOIN Producto p ON pr.producto_id = p.id;\\n\\nSELECT * FROM ItemPedido ip \\nJOIN Producto p ON ip.producto_id = p.id;\\n\\nSELECT * FROM Pedido pd \\nJOIN Usuario u ON pd.customer = u.id;\\n\\nSELECT * FROM UsuariosMetodosPago ump \\nJOIN MetodoPago mp ON ump.metodo_pago_id = mp.id;\\n\\nSELECT * FROM PedidosDescuentos pd \\nJOIN Descuento d ON pd.descuento_id = d.id;\",\n    \"metadataForDataValidation\": \"El script de validación está diseñado para asegurar que la migración de datos y esquema desde MongoDB a PostgreSQL se haya realizado correctamente. Incluye pasos para verificar la existencia de tablas, comparar la estructura de las tablas en términos de columnas y tipos de datos, validar la migración de datos mediante conteos de filas y comprobaciones de registros específicos, y verificar la integridad referencial a través de consultas que involucren claves foráneas. Además, se comprueban las restricciones para garantizar que los datos migrados cumplen con las mismas reglas que se aplicaban en MongoDB.\"\n}"
        }
      ]
    },
    {
      "name": "mongoose-example-improved",
      "request": {
        "method": "POST",
        "header": [],
        "body": {
          "mode": "raw",
          "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email.\"\r\n}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": {
          "raw": "{{migrations_url}}",
          "host": ["{{migrations_url}}"]
        }
      },
      "response": [
        {
          "name": "mongoose-example Copy",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email. Además, ten en cuenta que los 'id' son identificadores son únicos de cada entidad y todas las referencias de una entidad a otra en los agregados debe ser expresada con tablas intermedias o foreign key dependiendo de si son relaciones muchos a muchos o relaciones uno a muchos\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Mon, 10 Mar 2025 18:37:36 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL ); CREATE TABLE Producto ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, precio DECIMAL NOT NULL, descripcion TEXT, imagenURL TEXT, fabricante VARCHAR NOT NULL, stock INTEGER NOT NULL ); CREATE TABLE ProductoRelacionado ( id_producto_relacionado INTEGER NOT NULL, producto_id INTEGER NOT NULL, PRIMARY KEY (id_producto_relacionado, producto_id), FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id), FOREIGN KEY (producto_id) REFERENCES Producto(id) ); CREATE TABLE ItemPedido ( id SERIAL PRIMARY KEY, _productos_productoId INTEGER NOT NULL, nombreItem VARCHAR NOT NULL, cantidad INTEGER NOT NULL, subtotal DECIMAL NOT NULL, FOREIGN KEY (_productos_productoId) REFERENCES Producto(id) ); CREATE TABLE Descuento ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL, ratioDescuento DECIMAL NOT NULL ); CREATE TABLE Pedido ( id SERIAL PRIMARY KEY, fechaPedido TIMESTAMP NOT NULL, precioTotal DECIMAL NOT NULL ); CREATE TABLE UsuariosMetodosPago ( usuario_id INTEGER NOT NULL, metodo_id INTEGER NOT NULL, PRIMARY KEY (usuario_id, metodo_id), FOREIGN KEY (usuario_id) REFERENCES Usuario(id), FOREIGN KEY (metodo_id) REFERENCES MetodoPago(id) ); CREATE TABLE MetodoPago ( id SERIAL PRIMARY KEY, nombreMetodo VARCHAR NOT NULL, infoMetodo VARCHAR NOT NULL ); CREATE TABLE Usuario ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, email VARCHAR NOT NULL UNIQUE, password VARCHAR NOT NULL, direccion TEXT, pais VARCHAR NOT NULL, fechaRegistro TIMESTAMP NOT NULL, _usuarios_recomendadoPor INTEGER, valoracionTienda INTEGER NOT NULL, premium BOOLEAN NOT NULL, fecha_premium TIMESTAMP, premium_fee DECIMAL, FOREIGN KEY (_usuarios_recomendadoPor) REFERENCES Usuario(id) ); CREATE TABLE PedidosDescuentos ( pedido_id INTEGER NOT NULL, descuento_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, descuento_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (descuento_id) REFERENCES Descuento(id) ); CREATE TABLE ProductosRelacionados ( producto_id INTEGER NOT NULL, relacionado_id INTEGER NOT NULL, PRIMARY KEY (producto_id, relacionado_id), FOREIGN KEY (producto_id) REFERENCES Producto(id), FOREIGN KEY (relacionado_id) REFERENCES Producto(id) ); CREATE TABLE PedidosItems ( pedido_id INTEGER NOT NULL, item_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, item_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (item_id) REFERENCES ItemPedido(id) );\",\n    \"metadataForMigrateSchema\": \"El script generado crea un esquema de base de datos en PostgreSQL basado en las definiciones de esquema de MongoDB proporcionadas. Se han creado tablas separadas para las entidades anidadas y se han definido las claves foráneas necesarias para mantener la integridad referencial. Las restricciones de tipo de datos y las características como SERIAL para los identificadores han sido implementadas correctamente. El uso de Python con Pydantic ha sido útil para estructurar y validar los datos, facilitando la conversión de las estructuras anidadas en tablas adecuadas y asegurando que todas las relaciones se manejen correctamente a través de claves foráneas y tablas intermedias. Esto asegura un esquema bien normalizado y eficiente para PostgreSQL.\",\n    \"guidelinesForValidateSchema\": \"{\\r\\n  \\\"validationGuidelines\\\": {\\r\\n    \\\"schemaTransformationValidation\\\": {\\r\\n      \\\"steps\\\": [\\r\\n        {\\r\\n          \\\"step\\\": 1,\\r\\n          \\\"description\\\": \\\"Revisar la creación de tablas\\\",\\r\\n          \\\"action\\\": \\\"Verificar que todas las tablas especificadas en el script de migración se hayan creado en la base de datos PostgreSQL.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 2,\\r\\n          \\\"description\\\": \\\"Verificar tipos de datos\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que los tipos de datos en las tablas coincidan con los tipos especificados en el script (ej. VARCHAR, DECIMAL, TIMESTAMP).\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 3,\\r\\n          \\\"description\\\": \\\"Revisar claves primarias\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que cada tabla tenga una clave primaria definida y que se utilice 'SERIAL' para los identificadores.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 4,\\r\\n          \\\"description\\\": \\\"Verificar claves foráneas\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que todas las claves foráneas estén correctamente definidas y que referencien las tablas adecuadas.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 5,\\r\\n          \\\"description\\\": \\\"Revisar tablas intermedias\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que las relaciones muchos a muchos se hayan implementado correctamente a través de tablas intermedias.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 6,\\r\\n          \\\"description\\\": \\\"Revisar restricciones de unicidad\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que las restricciones de unicidad, como la del campo 'email' en la tabla Usuario, estén implementadas.\\\"\\r\\n        }\\r\\n      ]\\r\\n    },\\r\\n    \\\"schemaOptimizationValidation\\\": {\\r\\n      \\\"steps\\\": [\\r\\n        {\\r\\n          \\\"step\\\": 1,\\r\\n          \\\"description\\\": \\\"Verificar índices\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que se hayan creado índices en columnas clave como 'email' en Usuario y 'nombre' en Producto.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 2,\\r\\n          \\\"description\\\": \\\"Ejecutar consultas de prueba\\\",\\r\\n          \\\"action\\\": \\\"Realizar consultas de prueba para verificar que el rendimiento sea adecuado y que los resultados sean correctos (ej. búsqueda por nombre, filtrado por precio, etc.).\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 3,\\r\\n          \\\"description\\\": \\\"Evaluar la normalización\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que el esquema esté normalizado adecuadamente para evitar la redundancia de datos.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 4,\\r\\n          \\\"description\\\": \\\"Revisar integridad referencial\\\",\\r\\n          \\\"action\\\": \\\"Probar la integridad referencial realizando inserciones, actualizaciones y eliminaciones para verificar que las restricciones funcionen como se espera.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 5,\\r\\n          \\\"description\\\": \\\"Verificar la documentación\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que la documentación del esquema esté actualizada y refleje la estructura actual en PostgreSQL.\\\"\\r\\n        }\\r\\n      ]\\r\\n    },\\r\\n    \\\"manualTestingSuggestions\\\": [\\r\\n      \\\"Crear registros de prueba en cada tabla para verificar que las inserciones se realicen correctamente.\\\",\\r\\n      \\\"Ejecutar consultas de selección en cada tabla para asegurar que los datos se recuperen como se espera.\\\",\\r\\n      \\\"Probar la eliminación de registros y verificar que las restricciones de claves foráneas se apliquen correctamente.\\\",\\r\\n      \\\"Realizar consultas de unión para comprobar que las relaciones entre tablas funcionen adecuadamente.\\\"\\r\\n    ],\\r\\n    \\\"checkpoints\\\": [\\r\\n      \\\"Confirmar que todas las tablas y columnas tengan los nombres correctos y que no haya errores tipográficos.\\\",\\r\\n      \\\"Verificar que las restricciones y las claves foráneas se apliquen correctamente y no generen errores al intentar insertar datos.\\\",\\r\\n      \\\"Asegurarse de que los datos migrados desde MongoDB a PostgreSQL se mantengan consistentes y completos.\\\"\\r\\n    ]\\r\\n  }\\r\\n}\",\n    \"scriptForDataMigration\": \"import psycopg2\\nimport pymongo\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongo']\\n\\npostgres_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost',\\n    port='5432'\\n)\\npostgres_cursor = postgres_conn.cursor()\\n\\n# Migrar Categorias\\ncategorias = mongo_db.categoria.find()\\nfor categoria in categorias:\\n    postgres_cursor.execute(\\\"INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;\\\", (categoria['descripcion'],))\\n    categoria_id = postgres_cursor.fetchone()[0]\\n\\n# Migrar Productos\\nproductos = mongo_db.producto.find()\\nfor producto in productos:\\n    postgres_cursor.execute(\\\"INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock) VALUES (%s, %s, %s, %s, %s, %s) RETURNING id;\\\", (producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock']))\\n    producto_id = postgres_cursor.fetchone()[0]\\n    # Migrar categorias\\n    for categoria in producto['categorias']:\\n        postgres_cursor.execute(\\\"INSERT INTO ProductosRelacionados (producto_id, relacionado_id) VALUES (%s, %s);\\\", (producto_id, categoria['id']))\\n    # Migrar productos relacionados\\n    for relacionado in producto['ref_productos_relacionados']:\\n        postgres_cursor.execute(\\\"INSERT INTO ProductoRelacionado (id_producto_relacionado, producto_id) VALUES (%s, %s);\\\", (relacionado['id_producto_relacionado'], producto_id))\\n\\n# Migrar Usuarios\\nusuarios = mongo_db.usuario.find()\\nfor usuario in usuarios:\\n    postgres_cursor.execute(\\\"INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;\\\", (usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\\n    usuario_id = postgres_cursor.fetchone()[0]\\n    # Migrar metodos de pago\\n    for metodo in usuario['metodosDePago']:\\n        postgres_cursor.execute(\\\"INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s) RETURNING id;\\\", (metodo['nombreMetodo'], metodo['infoMetodo']))\\n        metodo_id = postgres_cursor.fetchone()[0]\\n        postgres_cursor.execute(\\\"INSERT INTO UsuariosMetodosPago (usuario_id, metodo_id) VALUES (%s, %s);\\\", (usuario_id, metodo_id))\\n    # Migrar pedidos\\n    for pedido in usuario['pedidos']:\\n        postgres_cursor.execute(\\\"INSERT INTO Pedido (fechaPedido, precioTotal) VALUES (%s, %s) RETURNING id;\\\", (pedido['fechaPedido'], pedido['precioTotal']))\\n        pedido_id = postgres_cursor.fetchone()[0]\\n        # Migrar descuentos\\n        for descuento in pedido['descuentos']:\\n            postgres_cursor.execute(\\\"INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s) RETURNING id;\\\", (descuento['descripcion'], descuento['ratioDescuento']))\\n            descuento_id = postgres_cursor.fetchone()[0]\\n            postgres_cursor.execute(\\\"INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES (%s, %s);\\\", (pedido_id, descuento_id))\\n        # Migrar items\\n        for item in pedido['items']:\\n            postgres_cursor.execute(\\\"INSERT INTO ItemPedido (_productos_productoId, nombreItem, cantidad, subtotal) VALUES (%s, %s, %s, %s) RETURNING id;\\\", (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\\n            item_id = postgres_cursor.fetchone()[0]\\n            postgres_cursor.execute(\\\"INSERT INTO PedidosItems (pedido_id, item_id) VALUES (%s, %s);\\\", (pedido_id, item_id))\\n\\n# Confirmar cambios y cerrar conexiones\\npostgres_conn.commit()\\npostgres_cursor.close()\\npostgres_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataMigration\": \"El script de migración de datos utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectar y migrar datos de MongoDB a PostgreSQL. Primero, se establecen las conexiones a ambas bases de datos. Luego, se migran las categorías, productos, usuarios, métodos de pago, pedidos, descuentos e items de pedidos, asegurando que se inserten correctamente en las tablas correspondientes en PostgreSQL. Se utilizan claves foráneas para mantener la integridad referencial. Este enfoque permite una migración eficiente y estructurada, garantizando que las relaciones entre los datos se mantengan. La validación de datos y la verificación de la migración se pueden realizar mediante pruebas manuales y consultas en la base de datos de destino después de la migración.\",\n    \"scriptForDataValidation\": \"import psycopg2\\nimport pymongo\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongo']\\n\\npostgres_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost',\\n    port='5432'\\n)\\npostgres_cursor = postgres_conn.cursor()\\n\\n# Validar Categorias\\nmongo_categorias = mongo_db.categoria.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Categoria;\\\")\\npostgres_categoria_count = postgres_cursor.fetchone()[0]\\nassert postgres_categoria_count == mongo_categorias.count(), \\\"El conteo de categorias no coincide.\\\"\\n\\n# Validar Productos\\nmongo_productos = mongo_db.producto.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Producto;\\\")\\npostgres_producto_count = postgres_cursor.fetchone()[0]\\nassert postgres_producto_count == mongo_productos.count(), \\\"El conteo de productos no coincide.\\\"\\n\\n# Validar Usuarios\\nmongo_usuarios = mongo_db.usuario.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Usuario;\\\")\\npostgres_usuario_count = postgres_cursor.fetchone()[0]\\nassert postgres_usuario_count == mongo_usuarios.count(), \\\"El conteo de usuarios no coincide.\\\"\\n\\n# Validar Productos Relacionados\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM ProductoRelacionado;\\\")\\npostgres_producto_relacionado_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los productos relacionados si es necesario\\n\\n# Validar ItemPedido\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM ItemPedido;\\\")\\npostgres_itempedido_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los items de pedido si es necesario\\n\\n# Validar Pedidos\\nmongo_pedidos = mongo_db.pedido.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Pedido;\\\")\\npostgres_pedido_count = postgres_cursor.fetchone()[0]\\nassert postgres_pedido_count == mongo_pedidos.count(), \\\"El conteo de pedidos no coincide.\\\"\\n\\n# Validar Descuentos\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Descuento;\\\")\\npostgres_descuento_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los descuentos si es necesario\\n\\n# Validar Metodos de Pago\\nmongo_metodos_pago = mongo_db.metodoPago.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM MetodoPago;\\\")\\npostgres_metodo_pago_count = postgres_cursor.fetchone()[0]\\nassert postgres_metodo_pago_count == mongo_metodos_pago.count(), \\\"El conteo de métodos de pago no coincide.\\\"\\n\\n# Validar integridad referencial\\n# Comprobar que todas las claves foráneas tengan registros correspondientes\\n# Ejemplo para Usuario recomendado\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Usuario WHERE _usuarios_recomendadoPor IS NOT NULL;\\\")\\nusuarios_recomendados_count = postgres_cursor.fetchone()[0]\\nassert usuarios_recomendados_count == mongo_db.usuario.count_documents({'_usuarios_recomendadoPor': {'$exists': True}}), \\\"Los usuarios recomendados no coinciden.\\\"\\n\\n# Confirmar cambios y cerrar conexiones\\npostgres_conn.commit()\\npostgres_cursor.close()\\npostgres_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataValidation\": \"El script de validación de la migración de datos y esquema utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectarse a las bases de datos MongoDB y PostgreSQL. Se realizan varias validaciones, incluyendo la comparación del conteo de registros en cada tabla de PostgreSQL con los documentos correspondientes en MongoDB. Además, se verifica la integridad referencial, asegurando que las claves foráneas tengan registros correspondientes. Esto garantiza que la migración se haya realizado correctamente y que los datos sean consistentes entre ambas bases de datos. El uso de Python permite una validación automatizada y eficiente, lo que facilita el proceso de verificación de la migración.\"\n}"
        },
        {
          "name": "mongoose-example Copy 2 - identificadores unicos",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email. Además, ten en cuenta que los 'id' son identificadores son únicos de cada entidad.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Mon, 10 Mar 2025 18:44:33 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL ); CREATE TABLE Producto ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, precio DECIMAL NOT NULL, descripcion TEXT, imagenURL TEXT, fabricante VARCHAR NOT NULL, stock INTEGER NOT NULL ); CREATE TABLE ProductoRelacionado ( id_producto_relacionado INTEGER NOT NULL, producto_id INTEGER NOT NULL, PRIMARY KEY (id_producto_relacionado, producto_id), FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id), FOREIGN KEY (producto_id) REFERENCES Producto(id) ); CREATE TABLE ItemPedido ( id SERIAL PRIMARY KEY, _productos_productoId INTEGER NOT NULL, nombreItem VARCHAR NOT NULL, cantidad INTEGER NOT NULL, subtotal DECIMAL NOT NULL, FOREIGN KEY (_productos_productoId) REFERENCES Producto(id) ); CREATE TABLE Descuento ( id SERIAL PRIMARY KEY, descripcion VARCHAR NOT NULL, ratioDescuento DECIMAL NOT NULL ); CREATE TABLE Pedido ( id SERIAL PRIMARY KEY, fechaPedido TIMESTAMP NOT NULL, precioTotal DECIMAL NOT NULL ); CREATE TABLE UsuariosMetodosPago ( usuario_id INTEGER NOT NULL, metodo_id INTEGER NOT NULL, PRIMARY KEY (usuario_id, metodo_id), FOREIGN KEY (usuario_id) REFERENCES Usuario(id), FOREIGN KEY (metodo_id) REFERENCES MetodoPago(id) ); CREATE TABLE MetodoPago ( id SERIAL PRIMARY KEY, nombreMetodo VARCHAR NOT NULL, infoMetodo VARCHAR NOT NULL ); CREATE TABLE Usuario ( id SERIAL PRIMARY KEY, nombre VARCHAR NOT NULL, email VARCHAR NOT NULL UNIQUE, password VARCHAR NOT NULL, direccion TEXT, pais VARCHAR NOT NULL, fechaRegistro TIMESTAMP NOT NULL, _usuarios_recomendadoPor INTEGER, valoracionTienda INTEGER NOT NULL, premium BOOLEAN NOT NULL, fecha_premium TIMESTAMP, premium_fee DECIMAL, FOREIGN KEY (_usuarios_recomendadoPor) REFERENCES Usuario(id) ); CREATE TABLE PedidosDescuentos ( pedido_id INTEGER NOT NULL, descuento_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, descuento_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (descuento_id) REFERENCES Descuento(id) ); CREATE TABLE ProductosRelacionados ( producto_id INTEGER NOT NULL, relacionado_id INTEGER NOT NULL, PRIMARY KEY (producto_id, relacionado_id), FOREIGN KEY (producto_id) REFERENCES Producto(id), FOREIGN KEY (relacionado_id) REFERENCES Producto(id) ); CREATE TABLE PedidosItems ( pedido_id INTEGER NOT NULL, item_id INTEGER NOT NULL, PRIMARY KEY (pedido_id, item_id), FOREIGN KEY (pedido_id) REFERENCES Pedido(id), FOREIGN KEY (item_id) REFERENCES ItemPedido(id) );\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema de base de datos en PostgreSQL basado en el esquema de MongoDB proporcionado. Se han definido tablas separadas para cada entidad, garantizando que las estructuras anidadas se conviertan en tablas independientes. Se utilizan claves foráneas para mantener la integridad referencial entre las tablas. Las restricciones de tipo de datos se han aplicado correctamente, utilizando SERIAL para los identificadores y asegurando que los campos clave como 'email' en Usuario sean únicos. Este enfoque permite una base de datos bien estructurada y normalizada, adecuada para PostgreSQL.\",\n    \"guidelinesForValidateSchema\": \"{\\r\\n  \\\"validationGuidelines\\\": {\\r\\n    \\\"schemaTransformationValidation\\\": {\\r\\n      \\\"steps\\\": [\\r\\n        {\\r\\n          \\\"step\\\": 1,\\r\\n          \\\"description\\\": \\\"Revisar la creación de tablas\\\",\\r\\n          \\\"action\\\": \\\"Verificar que todas las tablas especificadas en el script de migración se hayan creado en la base de datos PostgreSQL. Listar las tablas y compararlas con el script.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 2,\\r\\n          \\\"description\\\": \\\"Verificar tipos de datos\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que los tipos de datos en las tablas coincidan con los tipos especificados en el script (ej. VARCHAR, DECIMAL, TIMESTAMP). Realizar consultas para verificar los tipos de cada columna.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 3,\\r\\n          \\\"description\\\": \\\"Revisar claves primarias\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que cada tabla tenga una clave primaria definida y que se utilice 'SERIAL' para los identificadores. Ejecutar consultas para comprobar la existencia de claves primarias.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 4,\\r\\n          \\\"description\\\": \\\"Verificar claves foráneas\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que todas las claves foráneas estén correctamente definidas y que referencien las tablas adecuadas. Realizar consultas para verificar las relaciones entre las tablas.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 5,\\r\\n          \\\"description\\\": \\\"Revisar tablas intermedias\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que las relaciones muchos a muchos se hayan implementado correctamente a través de tablas intermedias. Listar las tablas intermedias y verificar sus relaciones.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 6,\\r\\n          \\\"description\\\": \\\"Revisar restricciones de unicidad\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que las restricciones de unicidad, como la del campo 'email' en la tabla Usuario, estén implementadas. Realizar pruebas de inserción para verificar el comportamiento de las restricciones.\\\"\\r\\n        }\\r\\n      ]\\r\\n    },\\r\\n    \\\"schemaOptimizationValidation\\\": {\\r\\n      \\\"steps\\\": [\\r\\n        {\\r\\n          \\\"step\\\": 1,\\r\\n          \\\"description\\\": \\\"Verificar índices\\\",\\r\\n          \\\"action\\\": \\\"Confirmar que se hayan creado índices en columnas clave como 'email' en Usuario y 'nombre' en Producto. Consultar la información del esquema para verificar la existencia de índices.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 2,\\r\\n          \\\"description\\\": \\\"Ejecutar consultas de prueba\\\",\\r\\n          \\\"action\\\": \\\"Realizar consultas de prueba para verificar que el rendimiento sea adecuado y que los resultados sean correctos (ej. búsqueda por nombre, filtrado por precio, etc.). Comparar tiempos de respuesta con los esperados.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 3,\\r\\n          \\\"description\\\": \\\"Evaluar la normalización\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que el esquema esté normalizado adecuadamente para evitar la redundancia de datos. Revisar las tablas y sus relaciones para identificar posibles redundancias.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 4,\\r\\n          \\\"description\\\": \\\"Revisar integridad referencial\\\",\\r\\n          \\\"action\\\": \\\"Probar la integridad referencial realizando inserciones, actualizaciones y eliminaciones para verificar que las restricciones funcionen como se espera. Intentar eliminar registros que tengan dependencias y observar el comportamiento.\\\"\\r\\n        },\\r\\n        {\\r\\n          \\\"step\\\": 5,\\r\\n          \\\"description\\\": \\\"Verificar la documentación\\\",\\r\\n          \\\"action\\\": \\\"Asegurarse de que la documentación del esquema esté actualizada y refleje la estructura actual en PostgreSQL. Comparar la documentación con el esquema actual.\\\"\\r\\n        }\\r\\n      ]\\r\\n    },\\r\\n    \\\"manualTestingSuggestions\\\": [\\r\\n      \\\"Crear registros de prueba en cada tabla para verificar que las inserciones se realicen correctamente.\\\",\\r\\n      \\\"Ejecutar consultas de selección en cada tabla para asegurar que los datos se recuperen como se espera.\\\",\\r\\n      \\\"Probar la eliminación de registros y verificar que las restricciones de claves foráneas se apliquen correctamente.\\\",\\r\\n      \\\"Realizar consultas de unión para comprobar que las relaciones entre tablas funcionen adecuadamente.\\\",\\r\\n      \\\"Ejecutar pruebas de rendimiento para asegurarse de que las consultas se ejecuten en un tiempo razonable.\\\"\\r\\n    ],\\r\\n    \\\"checkpoints\\\": [\\r\\n      \\\"Confirmar que todas las tablas y columnas tengan los nombres correctos y que no haya errores tipográficos.\\\",\\r\\n      \\\"Verificar que las restricciones y las claves foráneas se apliquen correctamente y no generen errores al intentar insertar datos.\\\",\\r\\n      \\\"Asegurarse de que los datos migrados desde MongoDB a PostgreSQL se mantengan consistentes y completos.\\\",\\r\\n      \\\"Revisar los registros de errores durante la migración para identificar y corregir problemas potenciales.\\\"\\r\\n    ]\\r\\n  }\\r\\n}\",\n    \"scriptForDataMigration\": \"import psycopg2\\nimport pymongo\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongo']\\n\\npostgres_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost',\\n    port='5432'\\n)\\npostgres_cursor = postgres_conn.cursor()\\n\\n# Migrar Categorias\\ncategorias = mongo_db.categoria.find()\\nfor categoria in categorias:\\n    postgres_cursor.execute(\\\"INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;\\\", (categoria['descripcion'],))\\n    categoria_id = postgres_cursor.fetchone()[0]\\n\\n# Migrar Productos\\nproductos = mongo_db.producto.find()\\nfor producto in productos:\\n    postgres_cursor.execute(\\\"INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock) VALUES (%s, %s, %s, %s, %s, %s) RETURNING id;\\\", (producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock']))\\n    producto_id = postgres_cursor.fetchone()[0]\\n    # Migrar categorias\\n    for categoria in producto['categorias']:\\n        postgres_cursor.execute(\\\"INSERT INTO ProductosRelacionados (producto_id, relacionado_id) VALUES (%s, %s);\\\", (producto_id, categoria['id']))\\n    # Migrar productos relacionados\\n    for relacionado in producto['ref_productos_relacionados']:\\n        postgres_cursor.execute(\\\"INSERT INTO ProductoRelacionado (id_producto_relacionado, producto_id) VALUES (%s, %s);\\\", (relacionado['id_producto_relacionado'], producto_id))\\n\\n# Migrar Usuarios\\nusuarios = mongo_db.usuario.find()\\nfor usuario in usuarios:\\n    postgres_cursor.execute(\\\"INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;\\\", (usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\\n    usuario_id = postgres_cursor.fetchone()[0]\\n    # Migrar metodos de pago\\n    for metodo in usuario['metodosDePago']:\\n        postgres_cursor.execute(\\\"INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s) RETURNING id;\\\", (metodo['nombreMetodo'], metodo['infoMetodo']))\\n        metodo_id = postgres_cursor.fetchone()[0]\\n        postgres_cursor.execute(\\\"INSERT INTO UsuariosMetodosPago (usuario_id, metodo_id) VALUES (%s, %s);\\\", (usuario_id, metodo_id))\\n    # Migrar pedidos\\n    for pedido in usuario['pedidos']:\\n        postgres_cursor.execute(\\\"INSERT INTO Pedido (fechaPedido, precioTotal) VALUES (%s, %s) RETURNING id;\\\", (pedido['fechaPedido'], pedido['precioTotal']))\\n        pedido_id = postgres_cursor.fetchone()[0]\\n        # Migrar descuentos\\n        for descuento in pedido['descuentos']:\\n            postgres_cursor.execute(\\\"INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s) RETURNING id;\\\", (descuento['descripcion'], descuento['ratioDescuento']))\\n            descuento_id = postgres_cursor.fetchone()[0]\\n            postgres_cursor.execute(\\\"INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES (%s, %s);\\\", (pedido_id, descuento_id))\\n        # Migrar items\\n        for item in pedido['items']:\\n            postgres_cursor.execute(\\\"INSERT INTO ItemPedido (_productos_productoId, nombreItem, cantidad, subtotal) VALUES (%s, %s, %s, %s) RETURNING id;\\\", (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\\n            item_id = postgres_cursor.fetchone()[0]\\n            postgres_cursor.execute(\\\"INSERT INTO PedidosItems (pedido_id, item_id) VALUES (%s, %s);\\\", (pedido_id, item_id))\\n\\n# Confirmar cambios y cerrar conexiones\\npostgres_conn.commit()\\npostgres_cursor.close()\\npostgres_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataMigration\": \"El script de migración de datos utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectar y migrar datos de MongoDB a PostgreSQL. Primero, se establecen las conexiones a ambas bases de datos. Luego, se migran las categorías, productos, usuarios, métodos de pago, pedidos, descuentos e items de pedidos, asegurando que se inserten correctamente en las tablas correspondientes en PostgreSQL. Se utilizan claves foráneas para mantener la integridad referencial. Este enfoque permite una migración eficiente y estructurada, garantizando que las relaciones entre los datos se mantengan. La validación de datos y la verificación de la migración se pueden realizar mediante pruebas manuales y consultas en la base de datos de destino después de la migración.\",\n    \"scriptForDataValidation\": \"import psycopg2\\nimport pymongo\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongo']\\n\\npostgres_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost',\\n    port='5432'\\n)\\npostgres_cursor = postgres_conn.cursor()\\n\\n# Validar Categorias\\nmongo_categorias = mongo_db.categoria.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Categoria;\\\")\\npostgres_categoria_count = postgres_cursor.fetchone()[0]\\nassert postgres_categoria_count == mongo_categorias.count(), \\\"El conteo de categorias no coincide.\\\"\\n\\n# Validar Productos\\nmongo_productos = mongo_db.producto.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Producto;\\\")\\npostgres_producto_count = postgres_cursor.fetchone()[0]\\nassert postgres_producto_count == mongo_productos.count(), \\\"El conteo de productos no coincide.\\\"\\n\\n# Validar Usuarios\\nmongo_usuarios = mongo_db.usuario.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Usuario;\\\")\\npostgres_usuario_count = postgres_cursor.fetchone()[0]\\nassert postgres_usuario_count == mongo_usuarios.count(), \\\"El conteo de usuarios no coincide.\\\"\\n\\n# Validar Productos Relacionados\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM ProductoRelacionado;\\\")\\npostgres_producto_relacionado_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los productos relacionados si es necesario\\n\\n# Validar ItemPedido\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM ItemPedido;\\\")\\npostgres_itempedido_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los items de pedido si es necesario\\n\\n# Validar Pedidos\\nmongo_pedidos = mongo_db.pedido.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Pedido;\\\")\\npostgres_pedido_count = postgres_cursor.fetchone()[0]\\nassert postgres_pedido_count == mongo_pedidos.count(), \\\"El conteo de pedidos no coincide.\\\"\\n\\n# Validar Descuentos\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Descuento;\\\")\\npostgres_descuento_count = postgres_cursor.fetchone()[0]\\n# Aquí se debe validar la lógica de los descuentos si es necesario\\n\\n# Validar Metodos de Pago\\nmongo_metodos_pago = mongo_db.metodoPago.find()\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM MetodoPago;\\\")\\npostgres_metodo_pago_count = postgres_cursor.fetchone()[0]\\nassert postgres_metodo_pago_count == mongo_metodos_pago.count(), \\\"El conteo de métodos de pago no coincide.\\\"\\n\\n# Validar integridad referencial\\n# Comprobar que todas las claves foráneas tengan registros correspondientes\\n# Ejemplo para Usuario recomendado\\npostgres_cursor.execute(\\\"SELECT COUNT(*) FROM Usuario WHERE _usuarios_recomendadoPor IS NOT NULL;\\\")\\nusuarios_recomendados_count = postgres_cursor.fetchone()[0]\\nassert usuarios_recomendados_count == mongo_db.usuario.count_documents({'_usuarios_recomendadoPor': {'$exists': True}}), \\\"Los usuarios recomendados no coinciden.\\\"\\n\\n# Confirmar cambios y cerrar conexiones\\npostgres_conn.commit()\\npostgres_cursor.close()\\npostgres_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataValidation\": \"El script de validación de la migración de datos y esquema utiliza las bibliotecas 'pymongo' y 'psycopg2' para conectarse a las bases de datos MongoDB y PostgreSQL. Se realizan varias validaciones, incluyendo la comparación del conteo de registros en cada tabla de PostgreSQL con los documentos correspondientes en MongoDB. Además, se verifica la integridad referencial, asegurando que las claves foráneas tengan registros correspondientes. Esto garantiza que la migración se haya realizado correctamente y que los datos sean consistentes entre ambas bases de datos. El uso de Python permite una validación automatizada y eficiente, lo que facilita el proceso de verificación de la migración.\"\n}"
        },
        {
          "name": "mongoose-example-con-queries-en-data-valiidation",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email. Además, ten en cuenta que los 'id' son identificadores son únicos de cada entidad.\"\r\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Mon, 10 Mar 2025 22:32:56 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    precio DECIMAL NOT NULL,\\n    descripcion TEXT,\\n    imagenURL TEXT,\\n    fabricante VARCHAR(255) NOT NULL,\\n    stock INTEGER NOT NULL,\\n    id_categoria INTEGER NOT NULL,\\n    FOREIGN KEY (id_categoria) REFERENCES Categoria(id)\\n);\\n\\nCREATE TABLE ProductoRelacionado (\\n    id SERIAL PRIMARY KEY,\\n    id_producto_relacionado BIGSERIAL NOT NULL,\\n    FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id)\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id SERIAL PRIMARY KEY,\\n    id_producto INTEGER NOT NULL,\\n    nombreItem VARCHAR(255) NOT NULL,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL NOT NULL,\\n    FOREIGN KEY (id_producto) REFERENCES Producto(id)\\n);\\n\\nCREATE TABLE Descuento (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR(255) NOT NULL,\\n    ratioDescuento DECIMAL NOT NULL\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL NOT NULL\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id SERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR(255) NOT NULL,\\n    infoMetodo TEXT NOT NULL\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR(255) NOT NULL,\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password VARCHAR(255) NOT NULL,\\n    direccion TEXT,\\n    pais VARCHAR(255) NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    _usuarios_recomendadoPor INTEGER,\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL,\\n    FOREIGN KEY (_usuarios_recomendadoPor) REFERENCES Usuario(id)\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    id_usuario INTEGER NOT NULL,\\n    id_metodoPago INTEGER NOT NULL,\\n    PRIMARY KEY (id_usuario, id_metodoPago),\\n    FOREIGN KEY (id_usuario) REFERENCES Usuario(id),\\n    FOREIGN KEY (id_metodoPago) REFERENCES MetodoPago(id)\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    id_pedido INTEGER NOT NULL,\\n    id_descuento INTEGER NOT NULL,\\n    PRIMARY KEY (id_pedido, id_descuento),\\n    FOREIGN KEY (id_pedido) REFERENCES Pedido(id),\\n    FOREIGN KEY (id_descuento) REFERENCES Descuento(id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    id_producto INTEGER NOT NULL,\\n    id_producto_relacionado INTEGER NOT NULL,\\n    PRIMARY KEY (id_producto, id_producto_relacionado),\\n    FOREIGN KEY (id_producto) REFERENCES Producto(id),\\n    FOREIGN KEY (id_producto_relacionado) REFERENCES Producto(id)\\n);\",\n    \"metadataForMigrateSchema\": \"El script crea las tablas necesarias para la migración del esquema de MongoDB a PostgreSQL. Se han definido las tablas 'Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', y 'Usuario' como entidades independientes. Cada tabla tiene un identificador único, utilizando SERIAL o BIGSERIAL según sea necesario. Las relaciones entre las tablas se establecen mediante claves foráneas, y se crean tablas intermedias para manejar las relaciones de muchos a muchos, como 'UsuariosMetodosPago', 'PedidosDescuentos', y 'ProductosRelacionados'. Se han utilizado tipos de datos apropiados para PostgreSQL, y se ha asegurado la unicidad del campo 'email' en la tabla 'Usuario'. Además, se han añadido restricciones NOT NULL donde es necesario para mantener la integridad de los datos.\",\n    \"guidelinesForValidateSchema\": \"Para validar manualmente la transformación del esquema desde MongoDB a PostgreSQL y asegurar la correcta implementación y optimización del nuevo esquema en la base de datos de destino, se deben seguir las siguientes pautas y recomendaciones:\\n\\n1. **Verificación de la Estructura de Tablas:**\\n   - Compruebe que todas las tablas definidas en el script de migración están presentes en la base de datos PostgreSQL. Utilice la consulta `SELECT table_name FROM information_schema.tables WHERE table_schema='public';` para listar las tablas.\\n   - Asegúrese de que cada tabla tiene las columnas especificadas en el script de migración. Para verificar las columnas de una tabla, utilice `SELECT column_name FROM information_schema.columns WHERE table_name='nombre_tabla';`.\\n\\n2. **Validación de Tipos de Datos:**\\n   - Revise que los tipos de datos de las columnas en PostgreSQL coincidan con los especificados en el script. Por ejemplo, verifique que las columnas de tipo `VARCHAR`, `DECIMAL`, `BOOLEAN`, y `TIMESTAMP` estén correctamente definidas.\\n   - Confirme que las restricciones `NOT NULL` están implementadas en las columnas requeridas.\\n\\n3. **Comprobación de Claves Primarias y Foráneas:**\\n   - Verifique que las claves primarias están definidas correctamente en cada tabla. Utilice `SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='nombre_tabla' AND constraint_type='PRIMARY KEY';` para comprobar las claves primarias.\\n   - Asegúrese de que las claves foráneas están correctamente implementadas y referencian las tablas y columnas adecuadas. Utilice `SELECT constraint_name, table_name, column_name, foreign_table_name, foreign_column_name FROM information_schema.key_column_usage WHERE table_name='nombre_tabla';` para revisar las claves foráneas.\\n\\n4. **Tablas Intermedias:**\\n   - Verifique que las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) estén correctamente creadas y que contengan las claves foráneas adecuadas que enlazan las entidades correspondientes.\\n\\n5. **Índices y Unicidad:**\\n   - Asegúrese de que los índices están creados en los campos clave, como el campo `email` en la tabla `Usuario`, utilizando la consulta `SELECT indexname FROM pg_indexes WHERE tablename='nombre_tabla';`.\\n   - Confirme que el índice en el campo `email` es único.\\n\\n6. **Pruebas de Inserción de Datos:**\\n   - Realice pruebas de inserción de datos en cada tabla para verificar que las restricciones y las claves foráneas funcionan correctamente. Intente insertar datos válidos y luego datos inválidos (por ejemplo, datos que violan restricciones de `NOT NULL` o claves foráneas) para comprobar que se generan errores adecuados.\\n   - Inserte registros en tablas que dependen de otras (por ejemplo, inserte primero en `Categoria` antes de insertar en `Producto`) y valide que las inserciones se realizan sin problemas.\\n\\n7. **Consultas de Prueba:**\\n   - Realice consultas SQL para validar la integridad de los datos. Por ejemplo:\\n     - `SELECT * FROM Producto WHERE nombre LIKE '%camisa%';` para buscar productos por nombre.\\n     - `SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;` para obtener productos en un rango de precio.\\n     - `SELECT fabricante, COUNT(*) FROM Producto GROUP BY fabricante;` para contar productos por fabricante.\\n     - `SELECT * FROM Usuario WHERE premium = true;` para filtrar usuarios premium.\\n\\n8. **Verificación de Datos Relacionados:**\\n   - Asegúrese de que los registros en las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) reflejan correctamente las relaciones entre las entidades. Realice uniones (JOIN) para validar que los datos relacionados se recuperan correctamente.\\n\\n9. **Revisión de Rendimiento:**\\n   - Monitoree el rendimiento de las consultas para asegurar que el nuevo esquema está optimizado. Utilice herramientas de análisis de rendimiento de PostgreSQL para identificar posibles cuellos de botella.\\n\\n10. **Documentación:**\\n    - Mantenga un registro de todas las pruebas realizadas, los resultados y cualquier problema encontrado durante la validación. Esto ayudará a identificar áreas que necesitan ajustes y proporcionará una referencia para futuras migraciones.\\n\\nSiguiendo estas pautas y recomendaciones, el usuario podrá validar eficazmente la transformación del esquema desde MongoDB a PostgreSQL y garantizar que el nuevo esquema esté correctamente implementado y optimizado.\",\n    \"scriptForDataMigration\": \"import psycopg2\\nimport pymongo\\n\\n# Conexiones a las bases de datos\\nmongo_client = pymongo.MongoClient('mongodb://localhost:27017/')\\nmongo_db = mongo_client['nombre_base_datos_mongodb']\\n\\npg_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgresql',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost'\\n)\\npg_cursor = pg_conn.cursor()\\n\\n# Migrar Categorias\\ncategorias = mongo_db.categorias.find()\\nfor categoria in categorias:\\n    pg_cursor.execute('INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;', (categoria['descripcion'],))\\n    categoria_id = pg_cursor.fetchone()[0]\\n\\n# Migrar Productos\\nproductos = mongo_db.productos.find()\\nfor producto in productos:\\n    pg_cursor.execute('INSERT INTO Producto (nombre, precio, descripcion, imagenURL, fabricante, stock, id_categoria) VALUES (%s, %s, %s, %s, %s, %s, %s) RETURNING id;', (producto['nombre'], producto['precio'], producto.get('descripcion'), producto.get('imagenURL'), producto['fabricante'], producto['stock'], categoria_id))\\n    producto_id = pg_cursor.fetchone()[0]\\n    \\n    # Migrar Productos Relacionados\\n    for relacionado in producto.get('ref_productos_relacionados', []):\\n        pg_cursor.execute('INSERT INTO ProductoRelacionado (id_producto_relacionado) VALUES (%s);', (relacionado['id_producto_relacionado'],))\\n\\n# Migrar Descuentos\\ndescuentos = mongo_db.descuentos.find()\\nfor descuento in descuentos:\\n    pg_cursor.execute('INSERT INTO Descuento (descripcion, ratioDescuento) VALUES (%s, %s);', (descuento['descripcion'], descuento['ratioDescuento']))\\n\\n# Migrar Pedidos\\npedidos = mongo_db.pedidos.find()\\nfor pedido in pedidos:\\n    pg_cursor.execute('INSERT INTO Pedido (fechaPedido, precioTotal) VALUES (%s, %s) RETURNING id;', (pedido['fechaPedido'], pedido['precioTotal']))\\n    pedido_id = pg_cursor.fetchone()[0]\\n    \\n    # Migrar Items de Pedido\\n    for item in pedido['items']:\\n        pg_cursor.execute('INSERT INTO ItemPedido (id_producto, nombreItem, cantidad, subtotal) VALUES (%s, %s, %s, %s);', (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\\n    \\n    # Migrar Descuentos de Pedido\\n    for descuento in pedido.get('descuentos', []):\\n        pg_cursor.execute('INSERT INTO PedidosDescuentos (id_pedido, id_descuento) VALUES (%s, %s);', (pedido_id, descuento['id']))\\n\\n# Migrar Usuarios\\nusuarios = mongo_db.usuarios.find()\\nfor usuario in usuarios:\\n    pg_cursor.execute('INSERT INTO Usuario (nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;', (usuario['nombre'], usuario['email'], usuario['password'], usuario.get('direccion'), usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\\n    usuario_id = pg_cursor.fetchone()[0]\\n\\n    # Migrar Métodos de Pago\\n    for metodo in usuario.get('metodosDePago', []):\\n        pg_cursor.execute('INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s) RETURNING id;', (metodo['nombreMetodo'], metodo['infoMetodo']))\\n        metodo_pago_id = pg_cursor.fetchone()[0]\\n        pg_cursor.execute('INSERT INTO UsuariosMetodosPago (id_usuario, id_metodoPago) VALUES (%s, %s);', (usuario_id, metodo_pago_id))\\n\\n# Confirmar cambios y cerrar conexiones\\npg_conn.commit()\\npg_cursor.close()\\npg_conn.close()\\nmongo_client.close()\",\n    \"metadataForDataMigration\": \"El script de migración de datos se encarga de transferir la información desde una base de datos MongoDB a PostgreSQL. Primero, establece conexiones a ambas bases de datos. Luego, se migran los datos de cada colección de MongoDB a las tablas correspondientes en PostgreSQL. Para cada categoría, producto, descuento, pedido, usuario y método de pago, se realizan inserciones en las tablas adecuadas y se manejan las relaciones a través de claves foráneas. Se utilizan transacciones para asegurar la integridad de los datos y se cierra la conexión al finalizar el proceso. Las tecnologías subyacentes, como pymongo y psycopg2, han sido útiles para realizar la migración de manera eficiente y validar la estructura del esquema durante la transferencia.\",\n    \"scriptForDataValidation\": \"import psycopg2\\n\\n# Conexión a la base de datos PostgreSQL\\npg_conn = psycopg2.connect(\\n    dbname='nombre_base_datos_postgresql',\\n    user='usuario',\\n    password='contraseña',\\n    host='localhost'\\n)\\npg_cursor = pg_conn.cursor()\\n\\n# 1. Verificar tablas\\npg_cursor.execute(\\\"SELECT table_name FROM information_schema.tables WHERE table_schema='public';\\\")\\ntablas = pg_cursor.fetchall()\\nprint('Tablas en PostgreSQL:', tablas)\\n\\n# 2. Verificar columnas de cada tabla\\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario', 'UsuariosMetodosPago', 'PedidosDescuentos', 'ProductosRelacionados']:\\n    pg_cursor.execute(f\\\"SELECT column_name FROM information_schema.columns WHERE table_name='{tabla}';\\\")\\n    columnas = pg_cursor.fetchall()\\n    print(f'Columnas en {tabla}:', columnas)\\n\\n# 3. Verificar tipos de datos\\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\\n    pg_cursor.execute(f\\\"SELECT column_name, data_type FROM information_schema.columns WHERE table_name='{tabla}';\\\")\\n    tipos_datos = pg_cursor.fetchall()\\n    print(f'Tipos de datos en {tabla}:', tipos_datos)\\n\\n# 4. Verificar claves primarias\\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\\n    pg_cursor.execute(f\\\"SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='{tabla}' AND constraint_type='PRIMARY KEY';\\\")\\n    claves_primarias = pg_cursor.fetchall()\\n    print(f'Claves primarias en {tabla}:', claves_primarias)\\n\\n# 5. Verificar claves foráneas\\nfor tabla in ['ProductoRelacionado', 'ItemPedido', 'UsuariosMetodosPago', 'PedidosDescuentos', 'ProductosRelacionados']:\\n    pg_cursor.execute(f\\\"SELECT constraint_name FROM information_schema.table_constraints WHERE table_name='{tabla}' AND constraint_type='FOREIGN KEY';\\\")\\n    claves_foraneas = pg_cursor.fetchall()\\n    print(f'Claves foráneas en {tabla}:', claves_foraneas)\\n\\n# 6. Verificar índices\\npg_cursor.execute(\\\"SELECT indexname, tablename FROM pg_indexes WHERE schemaname='public';\\\")\\nindices = pg_cursor.fetchall()\\nprint('Índices en las tablas:', indices)\\n\\n# 7. Realizar consultas de prueba\\n# Contar registros en cada tabla\\nfor tabla in ['Categoria', 'Producto', 'ProductoRelacionado', 'ItemPedido', 'Descuento', 'Pedido', 'MetodoPago', 'Usuario']:\\n    pg_cursor.execute(f\\\"SELECT COUNT(*) FROM {tabla};\\\")\\n    conteo = pg_cursor.fetchone()[0]\\n    print(f'Registros en {tabla}:', conteo)\\n\\n# 8. Verificar integridad de datos\\n# Ejemplo: Verificar que todos los productos tienen una categoría válida\\npg_cursor.execute(\\\"SELECT COUNT(*) FROM Producto WHERE id_categoria NOT IN (SELECT id FROM Categoria);\\\")\\nproductos_invalidos_categoria = pg_cursor.fetchone()[0]\\nprint('Productos con categoría inválida:', productos_invalidos_categoria)\\n\\n# Cerrar conexión\\npg_cursor.close()\\npg_conn.close()\",\n    \"metadataForDataValidation\": \"Este script está diseñado para validar la migración de datos y esquema de MongoDB a PostgreSQL. Primero, se establece una conexión con la base de datos PostgreSQL. Luego, se realizan las siguientes validaciones: se verifica la existencia de las tablas, se comprueba que las columnas y sus tipos de datos sean correctos, se revisan las claves primarias y foráneas, se listan los índices creados en las tablas y se cuentan los registros en cada tabla para asegurar que no se han perdido datos durante la migración. Además, se realiza una consulta para verificar la integridad referencial de los datos, asegurando que todos los productos tengan una categoría válida. Finalmente, se cierra la conexión a la base de datos.\"\n}"
        },
        {
          "name": "mongoose-example-queries-data-validation-modified",
          "originalRequest": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\r\n  \"sourceDatabaseType\": \"MongoDB\",\r\n  \"targetDatabaseType\": \"PostgreSQL\",\r\n  \"applicationRequirements\": \"Las consultas principales en MongoDB incluyen: 1) Buscar productos por nombre: db.productos.find({ nombre: /camisa/i }); 2) Obtener productos en un rango de precio: db.productos.find({ precio: { $gte: 10, $lte: 50 } }); 3) Contar productos por fabricante: db.productos.aggregate([{ $group: { _id: '$fabricante', total: { $sum: 1 } } }]); 4) Buscar pedidos de un usuario: db.usuarios.find({ id: 123 }, { pedidos: 1 }); 5) Obtener productos relacionados: db.productos.find({ id: 456 }, { ref_productos_relacionados: 1 }); 6) Filtrar usuarios premium: db.usuarios.find({ premium: true });\",\r\n  \"applicationArchitecture\": \"La aplicación está estructurada de acuerdo con una arquitectura monolítica.\",\r\n  \"underlyingTechnologies\": \"Estamos utilizando Python con Pydantic.\",\r\n  \"databaseSchema\": \"const CategoriaSchema = new mongoose.Schema({ descripcion: { type: String } }); const ProductoRelacionadoSchema = new mongoose.Schema({ id_producto_relacionado: { type: Number, ref: 'Producto', required: true } }); const ProductoSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, precio: { type: Number, required: true }, descripcion: { type: String }, imagenURL: { type: String }, fabricante: { type: String, required: true }, stock: { type: Number, required: true }, categorias: { type: CategoriaSchema, required: true }, ref_productos_relacionados: [{ type: ProductoRelacionadoSchema }] }); const ItemPedidoSchema = new mongoose.Schema({ _productos_productoId: { type: Number, ref: 'Producto', required: true }, nombreItem: { type: String, required: true }, cantidad: { type: Number, required: true }, subtotal: { type: Number, required: true } }); const DescuentoSchema = new mongoose.Schema({ id: { type: Number, required: true }, descripcion: { type: String, required: true }, ratioDescuento: { type: Number, required: true } }); const PedidoSchema = new mongoose.Schema({ id: { type: Number, required: true }, fechaPedido: { type: Date, required: true }, precioTotal: { type: Number, required: true }, descuentos: [DescuentoSchema], items: [ItemPedidoSchema] }); const MetodoPagoSchema = new mongoose.Schema({ nombreMetodo: { type: String, required: true }, infoMetodo: { type: String, required: true } }); const UsuarioSchema = new mongoose.Schema({ id: { type: Number, required: true }, nombre: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, direccion: { type: String }, pais: { type: String, required: true }, fechaRegistro: { type: Date, required: true }, _usuarios_recomendadoPor: { type: Number, ref: 'Usuario' }, valoracionTienda: { type: Number, required: true }, premium: { type: Boolean, required: true }, fecha_premium: { type: Date }, premium_fee: { type: Number }, metodosDePago: [MetodoPagoSchema], pedidos: [PedidoSchema] });\",\r\n  \"migrationRequirements\": \"Convertir estructuras anidadas en tablas separadas con claves foráneas. Categoria, MetodoPago, Pedido e ItemPedido deben ser tablas independientes. Usar SERIAL o BIGSERIAL para los id. Definir claves foráneas para enlazar ProductoRelacionado, ItemPedido, Pedido, Usuario y MetodoPago. Crear tablas intermedias (UsuariosMetodosPago, PedidosDescuentos, ProductosRelacionados) en lugar de arrays embebidos. Convertir String a VARCHAR/TEXT, Number a INTEGER/DECIMAL, Boolean a BOOLEAN y Date a TIMESTAMP. Agregar índices en campos clave como email en Usuario y nombre en Producto, asegurando UNIQUE en Usuario.email. Además, ten en cuenta que los campos 'id' son identificadores son únicos de cada entidad que pueden ser referenciados\"\r\n  }",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{migrations_url}}",
              "host": ["{{migrations_url}}"]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Transfer-Encoding",
              "value": "chunked"
            },
            {
              "key": "Date",
              "value": "Mon, 10 Mar 2025 23:27:00 GMT"
            },
            {
              "key": "Keep-Alive",
              "value": "timeout=60"
            },
            {
              "key": "Connection",
              "value": "keep-alive"
            }
          ],
          "cookie": [],
          "body": "{\n    \"scriptForMigrateSchema\": \"CREATE TABLE Categoria (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR NOT NULL\\n);\\n\\nCREATE TABLE Producto (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR NOT NULL,\\n    precio DECIMAL NOT NULL,\\n    descripcion TEXT,\\n    imagenURL TEXT,\\n    fabricante VARCHAR NOT NULL,\\n    stock INTEGER NOT NULL\\n);\\n\\nCREATE TABLE ProductoRelacionado (\\n    id SERIAL PRIMARY KEY,\\n    id_producto_relacionado BIGINT REFERENCES Producto(id) ON DELETE CASCADE\\n);\\n\\nCREATE TABLE ItemPedido (\\n    id SERIAL PRIMARY KEY,\\n    _productos_productoId BIGINT REFERENCES Producto(id) ON DELETE CASCADE,\\n    nombreItem VARCHAR NOT NULL,\\n    cantidad INTEGER NOT NULL,\\n    subtotal DECIMAL NOT NULL\\n);\\n\\nCREATE TABLE Descuento (\\n    id SERIAL PRIMARY KEY,\\n    descripcion VARCHAR NOT NULL,\\n    ratioDescuento DECIMAL NOT NULL\\n);\\n\\nCREATE TABLE Pedido (\\n    id BIGSERIAL PRIMARY KEY,\\n    fechaPedido TIMESTAMP NOT NULL,\\n    precioTotal DECIMAL NOT NULL\\n);\\n\\nCREATE TABLE MetodoPago (\\n    id SERIAL PRIMARY KEY,\\n    nombreMetodo VARCHAR NOT NULL,\\n    infoMetodo TEXT NOT NULL\\n);\\n\\nCREATE TABLE Usuario (\\n    id BIGSERIAL PRIMARY KEY,\\n    nombre VARCHAR NOT NULL,\\n    email VARCHAR UNIQUE NOT NULL,\\n    password VARCHAR NOT NULL,\\n    direccion TEXT,\\n    pais VARCHAR NOT NULL,\\n    fechaRegistro TIMESTAMP NOT NULL,\\n    _usuarios_recomendadoPor BIGINT REFERENCES Usuario(id) ON DELETE SET NULL,\\n    valoracionTienda INTEGER NOT NULL,\\n    premium BOOLEAN NOT NULL,\\n    fecha_premium TIMESTAMP,\\n    premium_fee DECIMAL\\n);\\n\\nCREATE TABLE UsuariosMetodosPago (\\n    usuario_id BIGINT REFERENCES Usuario(id) ON DELETE CASCADE,\\n    metodo_pago_id BIGINT REFERENCES MetodoPago(id) ON DELETE CASCADE,\\n    PRIMARY KEY (usuario_id, metodo_pago_id)\\n);\\n\\nCREATE TABLE PedidosDescuentos (\\n    pedido_id BIGINT REFERENCES Pedido(id) ON DELETE CASCADE,\\n    descuento_id BIGINT REFERENCES Descuento(id) ON DELETE CASCADE,\\n    PRIMARY KEY (pedido_id, descuento_id)\\n);\\n\\nCREATE TABLE ProductosRelacionados (\\n    producto_id BIGINT REFERENCES Producto(id) ON DELETE CASCADE,\\n    producto_relacionado_id BIGINT REFERENCES ProductoRelacionado(id) ON DELETE CASCADE,\\n    PRIMARY KEY (producto_id, producto_relacionado_id)\\n);\\n\\nCREATE INDEX idx_usuario_email ON Usuario(email);\\nCREATE INDEX idx_producto_nombre ON Producto(nombre);\",\n    \"metadataForMigrateSchema\": \"El script crea un esquema en PostgreSQL que refleja la estructura de la base de datos MongoDB original. Se definen tablas para cada entidad utilizando SERIAL o BIGSERIAL para los identificadores únicos. Las relaciones entre entidades se manejan a través de claves foráneas, y se crean tablas intermedias para reemplazar las estructuras anidadas. Se han agregado índices para los campos críticos como el email en la tabla Usuario y el nombre en la tabla Producto, asegurando la unicidad del email. Las conversiones de tipos de datos se han realizado para cumplir con las especificaciones de PostgreSQL.\",\n    \"guidelinesForValidateSchema\": \"Para validar la migración del esquema desde MongoDB a PostgreSQL y asegurar que la implementación y optimización del nuevo esquema en la base de datos de destino sea correcta, sigue las siguientes pautas y recomendaciones:\\n\\n### 1. Verificación de la Estructura de Tablas\\n- **Listar Tablas**: Utiliza el comando `\\\\dt` en psql para listar todas las tablas y asegúrate de que todas las tablas definidas en el script de migración estén presentes: `Categoria`, `Producto`, `ProductoRelacionado`, `ItemPedido`, `Descuento`, `Pedido`, `MetodoPago`, `Usuario`, `UsuariosMetodosPago`, `PedidosDescuentos`, y `ProductosRelacionados`.\\n\\n### 2. Verificación de Tipos de Datos\\n- **Tipos de Datos**: Para cada tabla, utiliza el comando `\\\\d nombre_tabla` para verificar que los tipos de datos de las columnas sean los correctos según las especificaciones de la migración. Asegúrate de que:\\n  - `String` se haya convertido a `VARCHAR` o `TEXT`.\\n  - `Number` se haya convertido a `INTEGER` o `DECIMAL`.\\n  - `Boolean` se haya convertido a `BOOLEAN`.\\n  - `Date` se haya convertido a `TIMESTAMP`.\\n\\n### 3. Verificación de Claves Primarias y Foráneas\\n- **Claves Primarias**: Asegúrate de que todas las claves primarias están definidas correctamente. Verifica que cada tabla tenga su clave primaria única.\\n- **Claves Foráneas**: Revisa que todas las claves foráneas estén implementadas y referencien las tablas correctas. Utiliza el comando `\\\\d nombre_tabla` para ver las restricciones de clave foránea y confirmar que las relaciones están correctamente establecidas.\\n\\n### 4. Revisión de Tablas Intermedias\\n- **Tablas Intermedias**: Confirma que las tablas intermedias (`UsuariosMetodosPago`, `PedidosDescuentos`, `ProductosRelacionados`) estén creadas y que contengan las claves foráneas apropiadas que enlazan las tablas correspondientes. Verifica que las relaciones muchos a muchos estén correctamente implementadas.\\n\\n### 5. Verificación de Índices\\n- **Índices**: Comprueba que los índices estén creados en los campos clave, como `email` en la tabla `Usuario` y `nombre` en la tabla `Producto`. Utiliza el comando `\\\\di` para listar los índices en la base de datos y asegúrate de que los índices estén siendo utilizados adecuadamente en las consultas.\\n\\n### 6. Pruebas de Integridad de Datos\\n- **Inserciones de Prueba**: Realiza inserciones de prueba en cada tabla para verificar que las restricciones de integridad (como `NOT NULL`, `UNIQUE`, etc.) funcionen correctamente. Intenta insertar datos que violen las restricciones y asegúrate de que la base de datos arroje errores apropiados.\\n\\n### 7. Pruebas de Consultas\\n- **Consultas de Prueba**: Realiza consultas de prueba que simulen las consultas que se realizaban en MongoDB. Por ejemplo:\\n  - Buscar productos por nombre: `SELECT * FROM Producto WHERE nombre ILIKE '%camisa%';`\\n  - Obtener productos en un rango de precio: `SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;`\\n  - Contar productos por fabricante: `SELECT fabricante, COUNT(*) FROM Producto GROUP BY fabricante;`\\n  - Buscar pedidos de un usuario: `SELECT pedidos FROM Usuario WHERE id = 123;`\\n  - Obtener productos relacionados: `SELECT ref_productos_relacionados FROM Producto WHERE id = 456;`\\n  - Filtrar usuarios premium: `SELECT * FROM Usuario WHERE premium = TRUE;`\\n- **Resultados**: Asegúrate de que los resultados sean los esperados y que las consultas se ejecuten en un tiempo razonable.\\n\\n### 8. Verificación de Rendimiento\\n- **Pruebas de Rendimiento**: Realiza pruebas de rendimiento para asegurarte de que el esquema está optimizado para consultas. Utiliza herramientas como `EXPLAIN` para analizar el rendimiento de las consultas y verifica que los índices estén siendo utilizados adecuadamente.\\n\\n### 9. Revisión de Documentación\\n- **Documentación**: Mantén documentación sobre el esquema migrado, incluyendo descripciones de cada tabla y sus relaciones. Esto será útil para futuras referencias y mantenimiento.\\n\\n### 10. Validación de Datos Existentes\\n- **Comparación de Datos**: Si es posible, realiza una comparación de datos entre la base de datos MongoDB original y la nueva base de datos PostgreSQL para asegurarte de que todos los datos se han migrado correctamente.\\n- **Conteo de Registros**: Verifica que la cantidad de registros en cada tabla de PostgreSQL coincida con la cantidad de documentos en las colecciones de MongoDB correspondientes.\\n\\nSiguiendo estas pautas y recomendaciones, podrás validar de manera efectiva la migración del esquema y asegurar la integridad y optimización del nuevo esquema en la base de datos de destino.\",\n    \"scriptForDataMigration\": \"import psycopg2\\nimport pymongo\\n\\n# Conexión a MongoDB\\ndb_mongo = pymongo.MongoClient('mongodb://localhost:27017/')['nombre_base_datos']\\n\\n# Conexión a PostgreSQL\\ndb_postgres = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres', \\n    user='usuario', \\n    password='contraseña', \\n    host='localhost', \\n    port='5432'\\n)\\ncursor = db_postgres.cursor()\\n\\n# Migrar Categoria\\nfor categoria in db_mongo.categoria.find():\\n    cursor.execute('INSERT INTO Categoria (descripcion) VALUES (%s) RETURNING id;', (categoria['descripcion'],))\\n    categoria_id = cursor.fetchone()[0]\\n\\n# Migrar Producto\\nfor producto in db_mongo.producto.find():\\n    cursor.execute('INSERT INTO Producto (id, nombre, precio, descripcion, imagenURL, fabricante, stock) VALUES (%s, %s, %s, %s, %s, %s, %s);', \\n                   (producto['id'], producto['nombre'], producto['precio'], producto['descripcion'], producto['imagenURL'], producto['fabricante'], producto['stock']))\\n    \\n    # Migrar categorías de producto\\n    categorias = producto['categorias']\\n    cursor.execute('INSERT INTO ProductosRelacionados (producto_id, producto_relacionado_id) VALUES (%s, %s);', (producto['id'], categorias['id']))\\n    \\n    # Migrar productos relacionados\\n    for relacionado in producto['ref_productos_relacionados']:\\n        cursor.execute('INSERT INTO ProductoRelacionado (id_producto_relacionado) VALUES (%s);', (relacionado['id_producto_relacionado'],))\\n\\n# Migrar Descuento\\nfor descuento in db_mongo.descuento.find():\\n    cursor.execute('INSERT INTO Descuento (id, descripcion, ratioDescuento) VALUES (%s, %s, %s);', (descuento['id'], descuento['descripcion'], descuento['ratioDescuento']))\\n\\n# Migrar MetodoPago\\nfor metodo_pago in db_mongo.metodopago.find():\\n    cursor.execute('INSERT INTO MetodoPago (nombreMetodo, infoMetodo) VALUES (%s, %s);', (metodo_pago['nombreMetodo'], metodo_pago['infoMetodo']))\\n\\n# Migrar Usuario\\nfor usuario in db_mongo.usuario.find():\\n    cursor.execute('INSERT INTO Usuario (id, nombre, email, password, direccion, pais, fechaRegistro, _usuarios_recomendadoPor, valoracionTienda, premium, fecha_premium, premium_fee) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);', \\n                   (usuario['id'], usuario['nombre'], usuario['email'], usuario['password'], usuario['direccion'], usuario['pais'], usuario['fechaRegistro'], usuario.get('_usuarios_recomendadoPor'), usuario['valoracionTienda'], usuario['premium'], usuario.get('fecha_premium'), usuario.get('premium_fee')))\\n    \\n    # Migrar metodos de pago de usuario\\n    for metodo in usuario['metodosDePago']:\\n        cursor.execute('INSERT INTO UsuariosMetodosPago (usuario_id, metodo_pago_id) VALUES (%s, (SELECT id FROM MetodoPago WHERE nombreMetodo = %s));', (usuario['id'], metodo['nombreMetodo']))\\n\\n    # Migrar pedidos\\n    for pedido in usuario['pedidos']:\\n        cursor.execute('INSERT INTO Pedido (id, fechaPedido, precioTotal) VALUES (%s, %s, %s) RETURNING id;', (pedido['id'], pedido['fechaPedido'], pedido['precioTotal']))\\n        pedido_id = cursor.fetchone()[0]\\n        \\n        # Migrar descuentos de pedido\\n        for descuento in pedido['descuentos']:\\n            cursor.execute('INSERT INTO PedidosDescuentos (pedido_id, descuento_id) VALUES (%s, %s);', (pedido_id, descuento['id']))\\n        \\n        # Migrar items de pedido\\n        for item in pedido['items']:\\n            cursor.execute('INSERT INTO ItemPedido (_productos_productoId, nombreItem, cantidad, subtotal) VALUES ((SELECT id FROM Producto WHERE id = %s), %s, %s, %s);', (item['_productos_productoId'], item['nombreItem'], item['cantidad'], item['subtotal']))\\n\\n# Guardar cambios y cerrar conexiones\\ndb_postgres.commit()\\ncursor.close()\\ndb_postgres.close()\",\n    \"metadataForDataMigration\": \"El script realiza la migración de datos desde MongoDB a PostgreSQL utilizando las bibliotecas pymongo y psycopg2. Se establece una conexión a ambas bases de datos y se recorre cada colección de MongoDB para insertar los datos en las tablas correspondientes en PostgreSQL. Las relaciones se manejan mediante la inserción de datos en tablas intermedias para asegurar la integridad referencial. Se insertan categorías, productos, descuentos, métodos de pago, usuarios, pedidos y elementos de pedido, asegurando que se respeten las claves foráneas y las estructuras anidadas se conviertan en tablas separadas. Este enfoque permite una migración eficiente y estructurada, cumpliendo con los requisitos especificados.\",\n    \"scriptForDataValidation\": \"import psycopg2\\n\\n# Conexión a PostgreSQL\\ndb_postgres = psycopg2.connect(\\n    dbname='nombre_base_datos_postgres', \\n    user='usuario', \\n    password='contraseña', \\n    host='localhost', \\n    port='5432'\\n)\\ncursor = db_postgres.cursor()\\n\\n# 1. Validar búsqueda de productos por nombre\\nprint('Validando búsqueda de productos por nombre...')\\ncursor.execute(\\\"SELECT * FROM Producto WHERE nombre ILIKE '%camisa%';\\\")\\nproductos_por_nombre = cursor.fetchall()\\nprint('Productos encontrados por nombre:', productos_por_nombre)\\n\\n# 2. Validar obtener productos en un rango de precio\\nprint('Validando obtener productos en un rango de precio...')\\ncursor.execute(\\\"SELECT * FROM Producto WHERE precio BETWEEN 10 AND 50;\\\")\\nproductos_rango_precio = cursor.fetchall()\\nprint('Productos en rango de precio:', productos_rango_precio)\\n\\n# 3. Validar contar productos por fabricante\\nprint('Validando contar productos por fabricante...')\\ncursor.execute(\\\"SELECT fabricante, COUNT(*) as total FROM Producto GROUP BY fabricante;\\\")\\nproductos_por_fabricante = cursor.fetchall()\\nprint('Conteo de productos por fabricante:', productos_por_fabricante)\\n\\n# 4. Buscar pedidos de un usuario\\nprint('Validando búsqueda de pedidos de un usuario...')\\ncursor.execute(\\\"SELECT pedidos FROM Usuario WHERE id = 123;\\\")\\npedidos_usuario = cursor.fetchall()\\nprint('Pedidos del usuario con id 123:', pedidos_usuario)\\n\\n# 5. Obtener productos relacionados\\nprint('Validando obtener productos relacionados...')\\ncursor.execute(\\\"SELECT ref_productos_relacionados FROM Producto WHERE id = 456;\\\")\\nproductos_relacionados = cursor.fetchall()\\nprint('Productos relacionados para el producto con id 456:', productos_relacionados)\\n\\n# 6. Filtrar usuarios premium\\nprint('Validando filtrado de usuarios premium...')\\ncursor.execute(\\\"SELECT * FROM Usuario WHERE premium = TRUE;\\\")\\nusarios_premium = cursor.fetchall()\\nprint('Usuarios premium:', usuarios_premium)\\n\\n# Cerrar conexión\\ncursor.close()\\ndb_postgres.close()\",\n    \"metadataForDataValidation\": \"El script se conecta a la base de datos PostgreSQL y ejecuta una serie de consultas para validar que los datos migrados desde MongoDB se hayan trasladado correctamente y que las consultas funcionen como se esperaba. Se realizan búsquedas de productos por nombre, se obtienen productos en un rango de precio, se cuenta el número de productos por fabricante, se buscan pedidos de un usuario específico, se obtienen productos relacionados y se filtran usuarios premium. Los resultados de cada consulta se imprimen en la consola para su revisión. Este enfoque asegura que la migración de datos y esquema sea correcta y que la funcionalidad de la aplicación se mantenga intacta.\"\n}"
        }
      ]
    }
  ]
}
